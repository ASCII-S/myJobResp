---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- gemm-opt
- gemm-opt/Strassen.md
related_outlines: []
---
首先给你一个标准、口语化的Strassen算法介绍，帮你快速理解核心逻辑和关键问题：

简单说，Strassen算法是一种“用更少乘法换时间”的矩阵乘法优化算法，核心思路是“分而治之”，专门解决朴素算法O(n³)复杂度太高的问题。

### 1. 核心原理（以两个n×n矩阵相乘为例，n是2的幂，非2的幂可补零处理）
- 第一步“分”：把输入矩阵A、B和待输出矩阵C，都切成4个大小相同的子矩阵，比如A分成A₁₁、A₁₂、A₂₁、A₂₂，B分成B₁₁、B₁₂、B₂₁、B₂₂，C分成C₁₁、C₁₂、C₂₁、C₂₂，每个子矩阵都是(n/2)×(n/2)大小。
- 第二步“算”：朴素分治会用8次“子矩阵乘法”计算C的4个子矩阵（比如C₁₁=A₁₁×B₁₁ + A₁₂×B₂₁），而Strassen巧妙设计了7个“中间矩阵”（比如M₁=(A₁₁+A₂₂)×(B₁₁+B₂₂)、M₂=(A₂₁+A₂₂)×B₁₁…），只需要7次子矩阵乘法，再通过加减运算就能算出C的4个子矩阵。
- 第三步“合”：把算好的C的4个子矩阵拼回成完整的输出矩阵C。

### 2. 时间复杂度
因为每次递归都会把矩阵规模缩小到原来的1/2，且每次递归的核心计算量是7次“(n/2)×(n/2)矩阵乘法”，所以复杂度递推公式是T(n) = 7×T(n/2) + O(n²)（O(n²)是子矩阵加减的时间）。  
解这个递推公式，最终得到时间复杂度是**O(n^log₂7)≈O(n².807)**——比朴素算法的O(n³)低，n越大，优势越明显（比如n=1000时，计算量能少一大半）。

### 3. 实际应用中“不常用”的关键原因（这是面试常考的点）
虽然复杂度更低，但它有两个致命问题，导致很多场景不如朴素算法优化版（比如分块GEMM）实用：
- 第一，**数值稳定性差**：Strassen算法里有大量子矩阵加减，会放大浮点运算的精度误差。比如科学计算中解线性方程组、深度学习中对精度敏感的模型训练，用它可能导致结果偏差甚至错误，而朴素算法的精度更稳定。
- 第二，**实际效率未必高**：
  - 它的“7次乘法+多次加减”里，加减运算的 overhead（额外开销）很高，尤其是在硬件层面（比如CPU缓存、GPU显存），加减的并行性远不如乘法，反而会抵消“少一次乘法”的优势；
  - 朴素算法容易做“分块优化”（Cache Blocking），能很好适配计算机的内存层次（寄存器→L1→L2→主存），提升缓存命中率，而Strassen算法的子矩阵分割逻辑复杂，很难和硬件缓存高效结合，小矩阵相乘时反而比优化后的朴素算法慢。

现在你可以试着总结一下：Strassen算法相比朴素矩阵乘法，核心优势和主要缺陷分别是什么？用口语化的话讲清楚就行，不用太学术。

---

## 相关笔记
<!-- 自动生成 -->

暂无相关笔记

