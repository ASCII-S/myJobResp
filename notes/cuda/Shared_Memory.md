---
created: '2025-10-19'
last_reviewed: '2025-10-19'
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- cuda
- cuda/Shared_Memory.md
related_outlines: []
---

# 共享内存（Shared Memory）

Shared Memory 位于 SM 内，延迟几十个 cycles，容量 48–100KB，一个 block 内线程共享，速度比全局内存快一个数量级。
它被分成多个 bank（通常 32 个），warp 内线程访问时按地址对 bank 数取模决定落在哪个 bank。
如果多个线程访问同一 bank 的不同地址，就会触发 bank 冲突，硬件会串行化这些访问，性能下降。但如果多个线程访问同一个地址，硬件会做 广播，不算冲突。
避免冲突的方法包括：让线程尽量连续访问地址；对数据结构做 padding，避免数组维度正好是 bank 数的倍数。

## 基本特性

* **位置**：位于每个 SM（Streaming Multiprocessor）内部
* **可见性**：同一个 block 内的所有线程都可以访问
* **容量**：通常 64KB-96KB（依架构而定），可配置为共享内存和 L1 Cache
* **延迟**：约几十个时钟周期，比全局内存快很多
* **带宽**：非常高，接近寄存器访问速度

## 面试常见问题与回答

### Q1: 共享内存的特点是什么？
**A**: 共享内存位于 SM 内部，同一个 block 内的线程可以共享访问。延迟只有几十个 cycle，比全局内存快很多。容量通常是 64KB 级别，主要用作缓存来减少全局内存访问。

### Q2: 什么是 Bank 冲突？
**A**: 共享内存被分为 32 个 bank，每个 bank 宽度为 4 字节。当 warp 内多个线程同时访问同一个 bank 的不同地址时，就会发生 bank 冲突，导致访问被串行化，严重影响性能。

### Q3: 如何避免 Bank 冲突？  
**A**: 
1. **确保连续访问**：让 thread i 访问地址 i，这样会映射到不同的 bank
2. **使用 padding**：在数据结构中添加填充，改变内存布局
3. **广播访问**：多个线程访问同一个地址不会产生冲突
4. **合理设计算法**：避免跨步访问等会导致冲突的模式

### Q4: 共享内存的典型使用场景？
**A**: 
1. **Tiling 优化**：矩阵乘法中将数据块加载到共享内存，减少全局内存访问
2. **数据重用**：当多个线程需要访问相同数据时
3. **线程间通信**：同一 block 内线程进行数据交换
4. **缓存频繁访问的数据**：避免重复的全局内存访问

### Q5: 动态共享内存和静态共享内存的区别？
**A**: 
- 静态共享内存用 __shared__ 声明，大小在编译时固定，适合 tile 尺寸已知的场景，比如矩阵乘法分块。
- 动态共享内存用 extern __shared__ type array[] 声明，大小在编译时未知，而是在 kernel 启动时通过第三个参数指定字节数，适合归约、排序等运行时决定大小的场景。
- 两者底层都是 SM 上的共享内存，总量有限。如果 kernel 里同时用了静态和动态共享内存，动态部分会占用剩余空间。


### Q6: 共享内存在矩阵乘法中如何优化性能？
**A**: 将矩阵的子块（tile）加载到共享内存中，让 block 内所有线程重复使用这些数据，避免每次都从全局内存读取。这样可以将全局内存访问从 O(N³) 降低到 O(N²)，大幅提升性能。

### 为什么数组维度等于bank倍数时会发生bank冲突？

在 CUDA 中，如果二维 tile 的列数正好是 bank 数的倍数，那么 warp 内按列访问时，每个线程的地址都会映射到同一个 bank，不同地址就会触发 bank 冲突，导致 warp 内访问串行化。
解决办法是给 tile 的列数 加 1 做 padding，这样 pitch 不再是 bank 的倍数，线程地址映射会均匀分布到不同 bank，从而消除冲突。
在 CPU 里有类似的现象：当数组步长正好让访问落到同一个 cache set 时，会出现 cache conflict miss，性能下降。GPU 的 bank 冲突和 CPU 的 cache 冲突，本质上都是地址映射引发的资源争用问题。

共享内存的存储布局 —— 是你在 __shared__ 定义数组时决定的。比如

```cpp
__shared__ float B_tile[32][32];   // pitch = 32 → 容易冲突  
__shared__ float B_tile[32][33];   // pitch = 33 → 避免冲突  
```
逻辑上都是存 tile，但物理地址分布不同。

加载方式 —— 线程把全局内存的矩阵 B 分块搬到 B_tile 里时，存放规则完全按你声明的维度来走。
所以即使全局内存里 B 的列数是 1024，你在共享内存里存 tile 时，如果 pitch=32，就会有冲突；如果 pitch=33，就能消除冲突。

---

## 相关笔记
<!-- 自动生成 -->

- [Bank冲突的概念和避免方法](notes/cuda/Bank冲突的概念和避免方法.md) - 相似度: 31% | 标签: cuda, cuda/Bank冲突的概念和避免方法.md

