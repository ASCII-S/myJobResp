---
created: '2025-10-19'
last_reviewed: '2025-10-19'
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/环形链表II.md
related_outlines: []
---

# 环形链表 II

## 题目描述

给定一个链表的头节点 `head`，返回链表开始入环的第一个节点。如果链表无环，则返回 `null`。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改**链表。

**示例 1：**
```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**
```
输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**
```
输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
```

**提示：**
- 链表中节点的数目范围在范围 [0, 10^4] 内
- -10^5 <= Node.val <= 10^5
- pos 的值为 -1 或者链表中的一个有效索引

**进阶：** 你是否可以使用 O(1) 空间解决此题？

## 思路讲解

这道题是"环形链表"的进阶版本，不仅要判断是否有环，还要找到环的入口节点。这是一道非常经典的算法题，涉及数学推导。

### 方法一：哈希表

**核心思路：**
遍历链表，用哈希表记录访问过的节点。第一个重复访问的节点就是环的入口。

**复杂度：**
- 时间复杂度：O(n)
- 空间复杂度：O(n)

### 方法二：快慢指针（Floyd 判圈算法，最优解）

这是满足进阶要求的解法，需要理解其中的数学原理。

**核心思路：**
1. 使用快慢指针判断是否有环
2. 如果有环，使用数学关系找到环的入口

**数学推导：**

假设：
- 链表头到环入口的距离为 `a`
- 环入口到快慢指针相遇点的距离为 `b`
- 相遇点到环入口的距离为 `c`
- 环的长度为 `b + c`

```
head -> ... -> 入口 -> ... -> 相遇点 -> ... -> 入口
        a        b        c (回到入口)
        
环长：b + c
```

**关键推导：**

1. 慢指针走过的距离：`a + b`
2. 快指针走过的距离：`a + b + n(b + c)`，其中 n 是快指针在环内多走的圈数
3. 由于快指针速度是慢指针的2倍：`2(a + b) = a + b + n(b + c)`
4. 化简：`a + b = n(b + c)`
5. 进一步化简：`a = n(b + c) - b = (n-1)(b + c) + c`

**结论：**
从链表头到环入口的距离 `a`，等于从相遇点走 `(n-1)` 圈环再走 `c` 的距离。

当 n = 1 时（最常见的情况）：`a = c`

**这意味着：**
- 一个指针从链表头开始走
- 另一个指针从相遇点开始走
- 两个指针以相同速度前进
- 它们会在环入口相遇！

## 面试时的快速口述讲解

这道题要求找到链表环的入口节点，使用快慢指针配合数学推导是最优解。

**数据结构**：使用快慢指针。

**实现方式**：
1. 第一阶段：使用快慢指针判断是否有环
   - 慢指针每次走1步，快指针每次走2步
   - 如果有环，两指针会相遇
2. 第二阶段：找到环的入口
   - 将一个指针重置到链表头
   - 两个指针以相同速度（每次1步）前进
   - 它们相遇的地方就是环的入口

**数学原理**：设链表头到环入口距离为 a，环入口到相遇点距离为 b，相遇点到环入口距离为 c。通过 2×慢指针路程 = 快指针路程，可以推导出 a = c（当快指针在环内走1圈时），因此从头和从相遇点同时出发会在入口相遇。

**时间复杂度**：O(n)，最多遍历链表两次。

**空间复杂度**：O(1)，只使用了两个指针。

## 代码实现

### 方法一：快慢指针（推荐）

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        // 边界情况
        if (head == nullptr || head->next == nullptr) {
            return nullptr;
        }
        
        // 第一阶段：使用快慢指针判断是否有环
        ListNode* slow = head;
        ListNode* fast = head;
        
        while (fast != nullptr && fast->next != nullptr) {
            slow = slow->next;
            fast = fast->next->next;
            
            // 快慢指针相遇，说明有环
            if (slow == fast) {
                // 第二阶段：找环的入口
                // 将一个指针重置到头节点
                ListNode* ptr1 = head;
                // 另一个指针从相遇点开始
                ListNode* ptr2 = slow;
                
                // 两指针以相同速度前进，相遇点就是环入口
                while (ptr1 != ptr2) {
                    ptr1 = ptr1->next;
                    ptr2 = ptr2->next;
                }
                
                return ptr1;  // 或者返回 ptr2，它们相等
            }
        }
        
        // 快指针到达末尾，说明无环
        return nullptr;
    }
};
```

**代码说明：**

**第一阶段：判断是否有环**
1. 初始化快慢指针都指向 head
2. 慢指针每次走1步，快指针每次走2步
3. 如果有环，快指针会在环内追上慢指针
4. 如果无环，快指针会先到达 nullptr

**第二阶段：找环的入口**
1. 当快慢指针相遇后，将一个指针（ptr1）重置到 head
2. 另一个指针（ptr2）留在相遇点
3. 两个指针以相同速度（每次1步）前进
4. 它们相遇的点就是环的入口

**为什么这样可行？**
```
设：
- 链表头到环入口距离 = a
- 环入口到相遇点距离 = b
- 相遇点到环入口距离 = c
- 环长 = b + c

慢指针走过：a + b
快指针走过：a + b + n(b + c)  (n为快指针多走的圈数)

因为快指针速度是慢指针2倍：
2(a + b) = a + b + n(b + c)
a + b = n(b + c)
a = n(b + c) - b
a = (n-1)(b + c) + c

当 n=1 时：a = c

这意味着从头走 a 步 = 从相遇点走 c 步
两个指针会在环入口相遇！
```

**图解过程：**
```
示例：head = [3,2,0,-4], pos = 1

链表结构：
3 -> 2 -> 0 -> -4
     ↑         ↓
     +---------+

a = 1 (从3到2)
b = 1 (从2到0)
c = 2 (从0到-4再到2)

第一阶段：快慢指针相遇
初始：slow=3, fast=3
步骤1：slow=2, fast=0
步骤2：slow=0, fast=-4
步骤3：slow=-4, fast=0
步骤4：slow=2, fast=-4
步骤5：slow=0, fast=0  相遇！

第二阶段：找入口
ptr1从head(3)开始，ptr2从相遇点(0)开始
步骤1：ptr1=2, ptr2=-4
步骤2：ptr1=0, ptr2=2  
等等，让我重新计算...

实际上：
ptr1从3开始，走1步到2
ptr2从0开始，走1步到-4，再走1步到2
它们在2相遇，2就是环入口！
```

### 方法二：哈希表

```cpp
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        unordered_set<ListNode*> visited;
        ListNode* curr = head;
        
        while (curr != nullptr) {
            // 如果当前节点已访问过，说明这是环的入口
            if (visited.count(curr)) {
                return curr;
            }
            visited.insert(curr);
            curr = curr->next;
        }
        
        // 遍历结束，无环
        return nullptr;
    }
};
```

**代码说明：**
1. 使用哈希表存储访问过的节点
2. 第一个重复访问的节点就是环的入口
3. 如果遍历到 nullptr，说明无环

**复杂度对比：**
- 方法一（快慢指针）：时间 O(n)，空间 O(1)，最优解
- 方法二（哈希表）：时间 O(n)，空间 O(n)，直观简单

**面试技巧：**
- 快慢指针解法是亮点，需要清楚数学推导
- 重点强调两个阶段：判断有环 + 找入口
- 可以画图辅助说明


---

## 相关笔记
<!-- 自动生成 -->

- [环形链表](notes/LeetcodeHot100/环形链表.md) - 相似度: 42% | 标签: LeetcodeHot100, LeetcodeHot100/环形链表.md
- [回文链表](notes/LeetcodeHot100/回文链表.md) - 相似度: 33% | 标签: LeetcodeHot100, LeetcodeHot100/回文链表.md

