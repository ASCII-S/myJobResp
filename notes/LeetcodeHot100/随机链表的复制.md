---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/随机链表的复制.md
related_outlines: []
---
# 随机链表的复制

## 题目描述

给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random`，该指针可以指向链表中的任何节点或空节点。

构造这个链表的**深拷贝**。深拷贝应该正好由 `n` 个**全新**节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点**。

例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y`。那么在复制链表中对应的两个节点 `x` 和 `y`，同样有 `x.random --> y`。

返回复制链表的头节点。

用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：
- `val`：一个表示 `Node.val` 的整数。
- `random_index`：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为 `null`。

你的代码**只**接受原链表的头节点 `head` 作为传入参数。

**示例 1：**
```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

**示例 2：**
```
输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
```

**示例 3：**
```
输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
```

**提示：**
- 0 <= n <= 1000
- -10^4 <= Node.val <= 10^4
- Node.random 为 null 或指向链表中的节点

## 思路讲解

这道题的难点在于复制 random 指针，因为 random 可以指向链表中的任意节点。

### 方法一：哈希表

**核心思路：**
使用哈希表建立原节点到新节点的映射关系。

**步骤：**
1. 第一次遍历：创建所有新节点，建立原节点 -> 新节点的映射
2. 第二次遍历：根据映射关系，设置新节点的 next 和 random 指针

**复杂度：**
- 时间复杂度：O(n)
- 空间复杂度：O(n)

### 方法二：原地复制 + 拆分（最优解）

这是一个非常巧妙的方法，不需要额外的哈希表空间。

**核心思路：**
1. 在每个原节点后面插入一个复制节点
2. 设置复制节点的 random 指针
3. 拆分链表，恢复原链表并得到复制链表

**详细步骤：**

**第1步：复制节点并插入**
```
原链表：A -> B -> C
复制后：A -> A' -> B -> B' -> C -> C'
```

**第2步：设置 random 指针**
- 如果 A->random = C
- 那么 A'->random = A->random->next = C'

**第3步：拆分链表**
```
恢复原链表：A -> B -> C
得到新链表：A' -> B' -> C'
```

**关键优势：**
- 通过在原节点后插入新节点，可以轻松找到对应关系
- 不需要额外的哈希表空间
- 三次遍历即可完成

## 面试时的快速口述讲解

这道题要求深拷贝一个带有随机指针的链表，关键是如何正确复制 random 指针。

**数据结构**：方法一使用哈希表存储原节点到新节点的映射；方法二原地复制不需要额外空间。

**实现方式（哈希表法）**：
1. 第一次遍历：创建所有新节点，用哈希表存储原节点 -> 新节点的映射
2. 第二次遍历：根据哈希表设置每个新节点的 next 和 random 指针
3. 返回新链表的头节点

**实现方式（原地复制法，O(1) 空间）**：
1. 第一步：在每个原节点后面插入其复制节点
2. 第二步：设置复制节点的 random 指针（通过原节点的 random->next 找到）
3. 第三步：拆分链表，恢复原链表并得到新链表

**时间复杂度**：O(n)，需要遍历链表2-3次。

**空间复杂度**：哈希表法 O(n)，原地复制法 O(1)（不考虑返回值占用的空间）。

## 代码实现

### 方法一：哈希表（推荐，容易理解）

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/

class Solution {
public:
    Node* copyRandomList(Node* head) {
        if (head == nullptr) {
            return nullptr;
        }
        
        // 哈希表：原节点 -> 新节点
        unordered_map<Node*, Node*> nodeMap;
        
        // 第一次遍历：创建所有新节点
        Node* curr = head;
        while (curr != nullptr) {
            // 创建新节点（只设置值，暂不设置指针）
            nodeMap[curr] = new Node(curr->val);
            curr = curr->next;
        }
        
        // 第二次遍历：设置新节点的 next 和 random 指针
        curr = head;
        while (curr != nullptr) {
            // 设置新节点的 next 指针
            if (curr->next != nullptr) {
                nodeMap[curr]->next = nodeMap[curr->next];
            }
            // 设置新节点的 random 指针
            if (curr->random != nullptr) {
                nodeMap[curr]->random = nodeMap[curr->random];
            }
            curr = curr->next;
        }
        
        // 返回新链表的头节点
        return nodeMap[head];
    }
};
```

**代码说明：**

1. **第一次遍历**：
   - 遍历原链表，为每个原节点创建对应的新节点
   - 只设置新节点的值，不设置指针
   - 将映射关系存入哈希表

2. **第二次遍历**：
   - 再次遍历原链表
   - 根据哈希表设置新节点的 next 和 random 指针
   - `nodeMap[curr]->next = nodeMap[curr->next]`：通过原节点找到新节点
   - `nodeMap[curr]->random = nodeMap[curr->random]`：同理

3. **返回结果**：
   - 返回原头节点对应的新头节点

**图解过程：**
```
原链表：
  7 -> 13 -> 11 -> 10 -> 1
  ↓     ↓     ↓     ↓    ↓
 null   7    1     11    7

第一次遍历后，哈希表：
{7:7', 13:13', 11:11', 10:10', 1:1'}

第二次遍历，设置指针：
7'->next = 13', 7'->random = null
13'->next = 11', 13'->random = 7'
11'->next = 10', 11'->random = 1'
10'->next = 1', 10'->random = 11'
1'->next = null, 1'->random = 7'
```

### 方法二：原地复制（O(1) 空间，最优解）

```cpp
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if (head == nullptr) {
            return nullptr;
        }
        
        // 第1步：在每个原节点后面插入复制节点
        // A -> B -> C  变成  A -> A' -> B -> B' -> C -> C'
        Node* curr = head;
        while (curr != nullptr) {
            Node* copy = new Node(curr->val);
            copy->next = curr->next;
            curr->next = copy;
            curr = copy->next;  // 跳到下一个原节点
        }
        
        // 第2步：设置复制节点的 random 指针
        curr = head;
        while (curr != nullptr) {
            if (curr->random != nullptr) {
                // 复制节点的 random 指向原节点 random 的下一个节点
                curr->next->random = curr->random->next;
            }
            curr = curr->next->next;  // 跳到下一个原节点
        }
        
        // 第3步：拆分链表
        curr = head;
        Node* newHead = head->next;
        Node* copy = newHead;
        
        while (curr != nullptr) {
            // 恢复原链表
            curr->next = curr->next->next;
            // 构建新链表
            if (copy->next != nullptr) {
                copy->next = copy->next->next;
            }
            // 移动指针
            curr = curr->next;
            copy = copy->next;
        }
        
        return newHead;
    }
};
```

**代码说明：**

**第1步：插入复制节点**
```
原链表：A -> B -> C -> null

处理 A：
A -> A' -> B -> C -> null

处理 B：
A -> A' -> B -> B' -> C -> null

处理 C：
A -> A' -> B -> B' -> C -> C' -> null
```

**第2步：设置 random 指针**
```
如果 A->random = C
那么 A' 在 A 后面，C' 在 C 后面
所以 A'->random = A->random->next = C->next = C'
```

**第3步：拆分链表**
```
交织链表：A -> A' -> B -> B' -> C -> C' -> null

拆分为：
原链表：A -> B -> C -> null
新链表：A' -> B' -> C' -> null
```

**图解完整过程：**
```
原链表：
1(random->2) -> 2(random->1) -> null

第1步插入后：
1 -> 1' -> 2 -> 2' -> null
(1的random指向2)

第2步设置random：
1' 的 random = 1->random->next = 2->next = 2'
2' 的 random = 2->random->next = 1->next = 1'

结果：
1 -> 1'(random->2') -> 2 -> 2'(random->1') -> null

第3步拆分：
原链表：1 -> 2 -> null
新链表：1'(random->2') -> 2'(random->1') -> null
```

**复杂度对比：**
- 方法一（哈希表）：时间 O(n)，空间 O(n)，代码清晰，推荐面试使用
- 方法二（原地复制）：时间 O(n)，空间 O(1)，代码复杂，面试亮点

**面试技巧：**
- 优先说哈希表解法，容易理解和实现
- 如果面试官追问空间优化，再说原地复制法
- 强调原地复制法的三个步骤
- 画图辅助说明会更清楚


---

## 相关笔记
<!-- 自动生成 -->

- [反转链表](notes/LeetcodeHot100/反转链表.md) - 相似度: 33% | 标签: LeetcodeHot100, LeetcodeHot100/反转链表.md
- [删除链表的倒数第N个结点](notes/LeetcodeHot100/删除链表的倒数第N个结点.md) - 相似度: 31% | 标签: LeetcodeHot100, LeetcodeHot100/删除链表的倒数第N个结点.md

