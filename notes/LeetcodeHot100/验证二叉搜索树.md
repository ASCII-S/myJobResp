---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/验证二叉搜索树.md
related_outlines: []
---
# 验证二叉搜索树

## 题目描述

给你一个二叉树的根节点 `root`，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：
- 节点的左子树只包含**小于**当前节点的数
- 节点的右子树只包含**大于**当前节点的数
- 所有左子树和右子树自身必须也是二叉搜索树

**示例 1：**
```
输入：root = [2,1,3]
输出：true
```

**示例 2：**
```
输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
```

**提示：**
- 树中节点数目范围在 [1, 10^4] 内
- -2^31 <= Node.val <= 2^31 - 1

## 思路讲解

验证 BST 是经典问题，关键是理解 BST 的性质和常见陷阱。

### 常见陷阱

❌ **错误思路**：只判断 `node.left.val < node.val < node.right.val`

这样做是不够的！例如：
```
    5
   / \
  1   6
     / \
    3   7
```
节点 6 的左子节点是 3，虽然 3 < 6，但 3 < 5，违反了 BST 的定义。

✅ **正确理解**：
- 左子树的**所有**节点都要小于当前节点
- 右子树的**所有**节点都要大于当前节点

### 方法一：递归（范围限制法）

为每个节点维护一个有效值范围 `(min, max)`：
1. 根节点的范围是 `(-∞, +∞)`
2. 左子节点的范围是 `(min, node.val)`
3. 右子节点的范围是 `(node.val, max)`
4. 递归检查每个节点是否在其有效范围内

### 方法二：中序遍历

BST 的中序遍历是严格递增的：
1. 进行中序遍历（左-根-右）
2. 记录前一个访问的节点值
3. 如果当前节点值 <= 前一个节点值，返回 false
4. 遍历结束后返回 true

### 关键点

- **范围限制法**：清晰直观，直接利用 BST 的定义
- **中序遍历法**：利用 BST 的性质，代码简洁
- **注意边界**：使用 long long 或 nullptr 处理 INT_MIN 和 INT_MAX

## 面试时的快速口述讲解

这道题要求验证一棵树是否是有效的二叉搜索树。

**数据结构**：
- 递归法：递归调用栈
- 中序遍历法：递归或栈

**实现方式**：
- **方法一（范围限制）**：递归时为每个节点维护一个有效值范围，根节点范围是 (-∞, +∞)，左子节点范围是 (父节点的下界, 父节点值)，右子节点范围是 (父节点值, 父节点的上界)
- **方法二（中序遍历）**：进行中序遍历，检查遍历序列是否严格递增。用一个变量记录前一个节点的值，如果当前值不大于前一个值，则不是 BST

**时间复杂度**：O(n)，需要访问所有节点。

**空间复杂度**：O(h)，h 是树的高度，递归调用栈的深度。

## 代码实现

### 方法一：递归（范围限制法）

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        // 使用 long long 避免边界问题
        return validate(root, LONG_MIN, LONG_MAX);
    }
    
private:
    bool validate(TreeNode* node, long long minVal, long long maxVal) {
        // 空节点是有效的 BST
        if (node == nullptr) {
            return true;
        }
        
        // 当前节点的值必须在 (minVal, maxVal) 范围内
        if (node->val <= minVal || node->val >= maxVal) {
            return false;
        }
        
        // 递归验证左右子树
        // 左子树：上界更新为当前节点值
        // 右子树：下界更新为当前节点值
        return validate(node->left, minVal, node->val) &&
               validate(node->right, node->val, maxVal);
    }
};
```

### 方法二：中序遍历

```cpp
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        TreeNode* prev = nullptr;  // 记录中序遍历的前一个节点
        return inorder(root, prev);
    }
    
private:
    bool inorder(TreeNode* node, TreeNode*& prev) {
        // 空节点
        if (node == nullptr) {
            return true;
        }
        
        // 中序遍历：左 -> 根 -> 右
        
        // 遍历左子树
        if (!inorder(node->left, prev)) {
            return false;
        }
        
        // 访问当前节点：检查是否大于前一个节点
        if (prev != nullptr && node->val <= prev->val) {
            return false;
        }
        
        // 更新 prev 为当前节点
        prev = node;
        
        // 遍历右子树
        return inorder(node->right, prev);
    }
};
```

**代码说明：**

**方法一（范围限制法）：**
1. **主函数**：调用 `validate`，初始范围为 `(LONG_MIN, LONG_MAX)`
2. **validate 函数**：
   - 递归终止：空节点返回 true
   - 检查当前节点值是否在有效范围 `(minVal, maxVal)` 内
   - 递归验证左子树：上界更新为 `node->val`（左子树所有节点必须小于当前节点）
   - 递归验证右子树：下界更新为 `node->val`（右子树所有节点必须大于当前节点）

**为什么使用 LONG_MIN 和 LONG_MAX？**
- 题目中节点值范围是 `[-2^31, 2^31 - 1]`（int 的范围）
- 如果根节点的值是 INT_MIN 或 INT_MAX，使用 int 作为边界会有问题
- 使用 long long 可以避免这个边界问题

**方法二（中序遍历法）：**
1. 使用指针 `prev` 记录中序遍历中的前一个节点
2. 中序遍历顺序：左 -> 根 -> 右
3. 访问当前节点时，检查其值是否大于 `prev->val`
4. 如果不是严格递增，返回 false
5. 更新 `prev` 为当前节点，继续遍历右子树

**两种方法的对比：**
- **范围限制法**：
  - 优点：直接利用 BST 定义，逻辑清晰
  - 缺点：需要处理边界值问题
  
- **中序遍历法**：
  - 优点：利用 BST 性质，代码简洁
  - 缺点：需要维护前驱节点，稍微不太直观

两种方法都是正确的，面试中推荐使用**范围限制法**，因为它更直接地体现了 BST 的定义。

**常见错误：**
```cpp
// ❌ 错误做法：只检查直接子节点
bool isValidBST(TreeNode* root) {
    if (!root) return true;
    if (root->left && root->left->val >= root->val) return false;
    if (root->right && root->right->val <= root->val) return false;
    return isValidBST(root->left) && isValidBST(root->right);
}
```
这种做法无法检测到示例 2 中的情况（节点 3 < 节点 6 但 节点 3 < 节点 5）。


---

## 相关笔记
<!-- 自动生成 -->

- [二叉搜索树中第K小的元素](notes/LeetcodeHot100/二叉搜索树中第K小的元素.md) - 相似度: 36% | 标签: LeetcodeHot100, LeetcodeHot100/二叉搜索树中第K小的元素.md
- [将有序数组转换为二叉搜索树](notes/LeetcodeHot100/将有序数组转换为二叉搜索树.md) - 相似度: 31% | 标签: LeetcodeHot100, LeetcodeHot100/将有序数组转换为二叉搜索树.md
- [二叉树的中序遍历](notes/LeetcodeHot100/二叉树的中序遍历.md) - 相似度: 31% | 标签: LeetcodeHot100, LeetcodeHot100/二叉树的中序遍历.md

