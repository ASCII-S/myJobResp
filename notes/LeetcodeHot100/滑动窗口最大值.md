# 滑动窗口最大值

## 题目描述

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

**示例 1：**
```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**示例 2：**
```
输入：nums = [1], k = 1
输出：[1]
```

**提示：**
- 1 <= nums.length <= 10^5
- -10^4 <= nums[i] <= 10^4
- 1 <= k <= nums.length

## 思路讲解

这是一道经典的困难题，要求在滑动窗口中高效地维护最大值。

### 方法一：暴力法（超时）

对每个窗口遍历找最大值，时间复杂度 O(n × k)，会超时。

### 方法二：单调队列（最优解）

**核心思想：**
使用单调递减的双端队列（deque）维护窗口内可能成为最大值的元素。

**单调队列的性质：**
- 队列中存储元素的索引（不是值）
- 队列从队首到队尾，对应的元素值单调递减
- 队首元素就是当前窗口的最大值

**为什么可以删除某些元素？**
- 如果新元素 `nums[i]` 大于等于队尾元素 `nums[deque.back()]`
- 那么队尾元素永远不可能成为最大值（因为新元素更大且更靠后）
- 可以安全地移除队尾元素

**算法步骤：**
1. 维护一个单调递减的双端队列
2. 对于每个新元素：
   - 移除队首已经不在窗口内的元素（索引 < i - k + 1）
   - 移除队尾所有小于当前元素的元素
   - 将当前元素索引加入队尾
3. 当窗口形成后（i >= k - 1），队首元素就是当前窗口最大值

**示例演示：**
```
nums = [1,3,-1,-3,5,3,6,7], k = 3

i=0, nums[0]=1, deque=[0], 窗口未形成
i=1, nums[1]=3>1, 移除0, deque=[1], 窗口未形成
i=2, nums[2]=-1<3, deque=[1,2], 窗口[1,3,-1], 最大值=nums[1]=3

i=3, nums[3]=-3<-1, deque=[1,2,3], 窗口[3,-1,-3], 最大值=nums[1]=3
i=4, nums[4]=5>所有, 移除1,2,3, deque=[4], 窗口[-1,-3,5], 最大值=nums[4]=5
i=5, nums[5]=3<5, deque=[4,5], 窗口[-3,5,3], 最大值=nums[4]=5
i=6, nums[6]=6>3, 移除5, 6>5, 移除4, deque=[6], 窗口[5,3,6], 最大值=nums[6]=6
i=7, nums[7]=7>6, 移除6, deque=[7], 窗口[3,6,7], 最大值=nums[7]=7

结果: [3,3,5,5,6,7]
```

### 方法三：优先队列（堆）

使用最大堆维护窗口元素，但需要额外处理过期元素，不如单调队列优雅。

## 面试时的快速口述讲解

这道题要求返回滑动窗口中的最大值，窗口大小固定。

**数据结构**：单调递减双端队列（deque），存储元素的索引。

**实现方式**：
1. 维护一个单调递减的双端队列，队首是当前窗口最大值的索引
2. 遍历数组，对每个元素：
   - 移除队首过期的索引（不在当前窗口内）
   - 从队尾移除所有小于当前元素的索引（它们不可能是最大值）
   - 将当前索引加入队尾
   - 如果窗口已形成，记录队首元素（最大值）

**关键点**：
- 队列存储索引而不是值，方便判断是否在窗口内
- 单调递减保证队首是最大值
- 移除队尾较小元素是关键优化

**时间复杂度**：O(n)，每个元素最多入队和出队各一次。

**空间复杂度**：O(k)，队列最多存储 k 个元素。

## 代码实现

### 方法一：单调队列（推荐）

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> result;
        deque<int> dq;  // 存储索引，单调递减
        
        for (int i = 0; i < nums.size(); i++) {
            // 移除不在窗口内的元素（队首）
            while (!dq.empty() && dq.front() < i - k + 1) {
                dq.pop_front();
            }
            
            // 移除队尾所有小于当前元素的索引
            // 因为它们不可能成为最大值
            while (!dq.empty() && nums[dq.back()] < nums[i]) {
                dq.pop_back();
            }
            
            // 将当前索引加入队尾
            dq.push_back(i);
            
            // 如果窗口已经形成，记录最大值
            if (i >= k - 1) {
                result.push_back(nums[dq.front()]);
            }
        }
        
        return result;
    }
};
```

**代码说明：**
1. 使用 `deque<int>` 存储元素索引
2. 对于每个位置 i：
   - 检查队首元素是否还在窗口内，不在则移除
   - 从队尾移除所有小于 `nums[i]` 的元素
   - 将 i 加入队尾
   - 如果窗口已形成（i >= k - 1），记录队首元素值
3. 返回结果数组

**为什么队列是单调递减的？**
- 因为我们会移除队尾所有小于当前元素的值
- 所以队列中的元素值始终保持递减
- 队首是最大值

### 方法二：优先队列

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> result;
        // 最大堆：pair<值, 索引>
        priority_queue<pair<int, int>> maxHeap;
        
        for (int i = 0; i < nums.size(); i++) {
            maxHeap.push({nums[i], i});
            
            // 窗口形成后
            if (i >= k - 1) {
                // 移除堆顶过期的元素
                while (maxHeap.top().second < i - k + 1) {
                    maxHeap.pop();
                }
                result.push_back(maxHeap.top().first);
            }
        }
        
        return result;
    }
};
```

这个方法的时间复杂度是 O(n log n)，因为堆操作是 O(log n)。

### 方法三：分块（动态规划）

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int n = nums.size();
        // prefixMax[i]: 从块开始到i的最大值
        // suffixMax[i]: 从i到块结束的最大值
        vector<int> prefixMax(n), suffixMax(n);
        
        for (int i = 0; i < n; i++) {
            if (i % k == 0) {
                prefixMax[i] = nums[i];
            } else {
                prefixMax[i] = max(prefixMax[i - 1], nums[i]);
            }
        }
        
        for (int i = n - 1; i >= 0; i--) {
            if (i == n - 1 || (i + 1) % k == 0) {
                suffixMax[i] = nums[i];
            } else {
                suffixMax[i] = max(suffixMax[i + 1], nums[i]);
            }
        }
        
        vector<int> result;
        for (int i = 0; i <= n - k; i++) {
            result.push_back(max(suffixMax[i], prefixMax[i + k - 1]));
        }
        
        return result;
    }
};
```

**三种方法对比：**
| 方法     | 时间复杂度 | 空间复杂度 | 难度 |
| -------- | ---------- | ---------- | ---- |
| 单调队列 | O(n)       | O(k)       | 中等 |
| 优先队列 | O(n log n) | O(n)       | 简单 |
| 分块(DP) | O(n)       | O(n)       | 较难 |

**面试推荐**：单调队列是最优解，也是最常考的方法。

**易错点：**
1. 队列存储的是索引，不是值
2. 判断窗口是否形成：`i >= k - 1`
3. 判断元素是否在窗口内：`index >= i - k + 1`
4. 单调队列是递减的，移除的是队尾的较小元素

