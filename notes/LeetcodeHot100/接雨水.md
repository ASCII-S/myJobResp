---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/接雨水.md
related_outlines: []
---
# 接雨水

## 题目描述

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**示例 1：**
```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，
在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。
```

**示例 2：**
```
输入：height = [4,2,0,3,2,5]
输出：9
```

**提示：**
- n == height.length
- 1 <= n <= 2 × 10^4
- 0 <= height[i] <= 10^5

## 思路讲解

这是一道经典的困难题，有多种解法。核心思想是：**每个位置能接的雨水量 = min(左边最高, 右边最高) - 当前高度**。

### 方法一：动态规划

**核心思想：**
提前计算每个位置左边和右边的最大高度。

**算法步骤：**
1. 创建两个数组 `leftMax` 和 `rightMax`
   - `leftMax[i]` 表示 `[0, i]` 范围内的最大高度
   - `rightMax[i]` 表示 `[i, n-1]` 范围内的最大高度
2. 遍历一遍计算 `leftMax`，从左到右
3. 遍历一遍计算 `rightMax`，从右到左
4. 遍历每个位置，计算能接的雨水：`min(leftMax[i], rightMax[i]) - height[i]`

**时间复杂度**：O(n)，需要三次遍历  
**空间复杂度**：O(n)，需要两个辅助数组

### 方法二：双指针（最优解）

**核心思想：**
使用双指针从两端向中间移动，动态维护左右两边的最大高度。

**关键观察：**
- 如果 `leftMax < rightMax`，那么左边位置的接水量只取决于 `leftMax`
- 因为右边一定有更高的柱子（至少是 `rightMax`）
- 反之亦然

**算法步骤：**
1. 初始化左右指针 `left = 0, right = n - 1`
2. 维护 `leftMax` 和 `rightMax`
3. 当 `left < right` 时：
   - 如果 `height[left] < height[right]`：
     - 如果 `height[left] >= leftMax`，更新 `leftMax`
     - 否则，当前位置能接水 `leftMax - height[left]`
     - 移动 `left++`
   - 否则处理右边，逻辑类似
4. 返回总的接水量

**为什么这样正确？**
- 当 `height[left] < height[right]` 时，左边位置的接水量取决于 `leftMax`
- 因为右边至少有 `height[right]` 这么高，而 `height[right] > height[left]`
- 所以右边一定能"挡住"水，左边的接水量只取决于 `leftMax`

**时间复杂度**：O(n)，只需一次遍历  
**空间复杂度**：O(1)，只使用常数空间

### 方法三：单调栈

使用单调栈维护递减序列，当遇到更高的柱子时，说明可以形成凹槽接水。适合理解"横向"接水的思路。

## 面试时的快速口述讲解

这道题要计算柱状图能接多少雨水。关键是理解：每个位置能接的水取决于它左右两边最高柱子中的较小值。

**数据结构**：使用双指针，不需要额外空间。

**实现方式**：
1. 左右双指针从两端开始
2. 维护左边最大高度 `leftMax` 和右边最大高度 `rightMax`
3. 每次处理较矮的一边：
   - 如果当前高度小于该边的最大高度，能接水
   - 否则更新该边的最大高度
4. 移动指针，继续处理

**关键点**：较矮的一边能接多少水只取决于该边的最大高度，因为另一边一定更高。

**时间复杂度**：O(n)，双指针只遍历一次。

**空间复杂度**：O(1)，只使用常数额外空间。

## 代码实现

### 方法一：动态规划

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        if (n <= 2) return 0;
        
        // 计算每个位置左边的最大高度
        vector<int> leftMax(n);
        leftMax[0] = height[0];
        for (int i = 1; i < n; i++) {
            leftMax[i] = max(leftMax[i - 1], height[i]);
        }
        
        // 计算每个位置右边的最大高度
        vector<int> rightMax(n);
        rightMax[n - 1] = height[n - 1];
        for (int i = n - 2; i >= 0; i--) {
            rightMax[i] = max(rightMax[i + 1], height[i]);
        }
        
        // 计算总的接水量
        int water = 0;
        for (int i = 0; i < n; i++) {
            water += min(leftMax[i], rightMax[i]) - height[i];
        }
        
        return water;
    }
};
```

### 方法二：双指针（推荐）

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        if (n <= 2) return 0;
        
        int left = 0, right = n - 1;
        int leftMax = 0, rightMax = 0;
        int water = 0;
        
        while (left < right) {
            // 处理较矮的一边
            if (height[left] < height[right]) {
                // 处理左边
                if (height[left] >= leftMax) {
                    // 当前位置更高，更新最大高度
                    leftMax = height[left];
                } else {
                    // 当前位置能接水
                    water += leftMax - height[left];
                }
                left++;
            } else {
                // 处理右边
                if (height[right] >= rightMax) {
                    // 当前位置更高，更新最大高度
                    rightMax = height[right];
                } else {
                    // 当前位置能接水
                    water += rightMax - height[right];
                }
                right--;
            }
        }
        
        return water;
    }
};
```

**代码说明（双指针）：**
1. 初始化左右指针和左右最大高度
2. 当 `left < right` 时循环：
   - 比较两边高度，处理较矮的一边
   - 如果当前高度 >= 该边最大高度，更新最大高度
   - 否则，当前位置能接水：`该边最大高度 - 当前高度`
   - 移动对应指针
3. 返回总接水量

### 方法三：单调栈

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        stack<int> st;  // 单调递减栈，存储索引
        int water = 0;
        
        for (int i = 0; i < n; i++) {
            // 当前柱子比栈顶高，说明可以接水
            while (!st.empty() && height[i] > height[st.top()]) {
                int top = st.top();
                st.pop();
                
                if (st.empty()) break;
                
                // 计算接水宽度和高度
                int left = st.top();
                int width = i - left - 1;
                int h = min(height[left], height[i]) - height[top];
                water += width * h;
            }
            st.push(i);
        }
        
        return water;
    }
};
```

**三种方法对比：**
| 方法     | 时间复杂度 | 空间复杂度 | 难度 |
| -------- | ---------- | ---------- | ---- |
| 动态规划 | O(n)       | O(n)       | 简单 |
| 双指针   | O(n)       | O(1)       | 中等 |
| 单调栈   | O(n)       | O(n)       | 较难 |

**面试推荐**：掌握动态规划和双指针两种方法，双指针是最优解。单调栈思路独特，可以作为加分项。


---

## 相关笔记
<!-- 自动生成 -->

暂无相关笔记

