---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/二叉树的最近公共祖先.md
related_outlines: []
---
# 二叉树的最近公共祖先

## 题目描述

给定一个二叉树，找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为："对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。"

**示例 1：**
```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

**示例 2：**
```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```

**示例 3：**
```
输入：root = [1,2], p = 1, q = 2
输出：1
```

**提示：**
- 树中节点数目在范围 [2, 10^5] 内
- -10^9 <= Node.val <= 10^9
- 所有 `Node.val` **互不相同**
- `p != q`
- `p` 和 `q` 均存在于给定的二叉树中

## 思路讲解

这是一道经典的二叉树递归问题，关键是理解递归的返回值含义。

### 核心思想

对于当前节点，有以下几种情况：
1. 如果当前节点是 p 或 q，那么当前节点就是最近公共祖先的候选
2. 递归查找左右子树
3. 根据左右子树的返回值判断：
   - 如果 p 和 q 分别在左右子树，当前节点就是最近公共祖先
   - 如果 p 和 q 都在左子树，返回左子树的结果
   - 如果 p 和 q 都在右子树，返回右子树的结果

### 递归返回值的含义

递归函数的返回值表示：
- 如果子树中包含 p 或 q，返回 p 或 q 的节点
- 如果子树中既包含 p 又包含 q，返回它们的最近公共祖先
- 如果子树中既不包含 p 也不包含 q，返回 nullptr

### 三种情况

1. **左右子树都返回非空**：说明 p 和 q 分别在左右子树，当前节点是 LCA
2. **只有左子树返回非空**：说明 p 和 q 都在左子树，或者左子树包含 p/q 之一
3. **只有右子树返回非空**：说明 p 和 q 都在右子树，或者右子树包含 p/q 之一

### 关键点

- **后序遍历**：左 -> 右 -> 根，需要先知道子树的信息，才能判断当前节点
- **递归的多重含义**：返回值既可能是 p/q 本身，也可能是它们的 LCA
- **自身可以是祖先**：如果 p 是 q 的祖先，那么 p 就是 LCA

## 面试时的快速口述讲解

这道题要求找到二叉树中两个节点的最近公共祖先。

**数据结构**：使用递归（后序遍历）。

**实现方式**：
使用后序遍历（左-右-根）的递归方法：
1. 如果当前节点为空，或等于 p 或 q，返回当前节点
2. 递归查找左右子树
3. 根据左右子树的返回值判断：
   - 如果左右都非空，说明 p 和 q 分别在两侧，当前节点就是 LCA
   - 如果只有左边非空，返回左边的结果（p 和 q 都在左子树）
   - 如果只有右边非空，返回右边的结果（p 和 q 都在右子树）

**时间复杂度**：O(n)，最坏情况下需要遍历所有节点。

**空间复杂度**：O(h)，h 是树的高度，递归调用栈的深度。

## 代码实现

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        // 递归终止条件
        // 1. 节点为空，返回 nullptr
        // 2. 节点等于 p 或 q，返回该节点
        if (root == nullptr || root == p || root == q) {
            return root;
        }
        
        // 递归查找左右子树
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        
        // 根据左右子树的返回值判断
        
        // 情况1：左右子树都返回非空
        // 说明 p 和 q 分别在左右子树，当前节点是它们的 LCA
        if (left != nullptr && right != nullptr) {
            return root;
        }
        
        // 情况2：只有左子树返回非空
        // 说明 p 和 q 都在左子树，返回左子树的结果
        if (left != nullptr) {
            return left;
        }
        
        // 情况3：只有右子树返回非空（或都为空）
        // 说明 p 和 q 都在右子树，返回右子树的结果
        return right;
    }
};
```

**代码说明：**

1. **递归终止条件**：
   - 如果节点为空，返回 nullptr
   - 如果节点等于 p 或 q，返回该节点
   - 这里体现了"节点可以是自己的祖先"

2. **递归查找**：
   - 递归查找左子树：`left = lowestCommonAncestor(root->left, p, q)`
   - 递归查找右子树：`right = lowestCommonAncestor(root->right, p, q)`

3. **根据返回值判断**：
   - **左右都非空**：p 和 q 分别在两侧，当前节点是 LCA
   - **只有左非空**：p 和 q 都在左子树，或左子树只包含其中一个
   - **只有右非空**：p 和 q 都在右子树，或右子树只包含其中一个
   - **都为空**：当前子树不包含 p 和 q

**执行过程示例**（以示例 1 为例）：

```
树：        3
          /   \
         5     1
        / \   / \
       6   2 0   8
          / \
         7   4

p = 5, q = 1

递归过程（简化）：
1. 从根节点3开始
   - 递归左子树（节点5）
     - 节点5 == p，返回5
   - 递归右子树（节点1）
     - 节点1 == q，返回1
   - left=5（非空），right=1（非空）
   - 返回当前节点3（LCA）

另一个例子：p = 5, q = 4
1. 从根节点3开始
   - 递归左子树（节点5）
     - 节点5 == p，返回5
   - 递归右子树（节点1）
     - 不包含p和q，返回nullptr
   - left=5（非空），right=nullptr
   - 返回left=5（LCA）

为什么返回5是正确的？
因为在左子树的递归中，节点5==p时直接返回，
后续的递归会发现节点4，但由于5已经返回，
说明p和q都在以5为根的子树中，所以5就是LCA。
```

**关键理解：**

这个算法的巧妙之处在于：
1. **提前返回**：遇到 p 或 q 就返回，不继续向下
2. **信息传递**：通过返回值向上传递信息
3. **后序遍历**：先处理子树，再处理当前节点

**为什么这样是对的？**

假设 p 是 q 的祖先：
- 当递归到 p 时，直接返回 p
- 即使 q 在 p 的子树中，由于已经返回，不会继续查找
- 最终 p 会被返回为 LCA，这是正确的（节点可以是自己的祖先）

假设 p 和 q 在不同子树：
- 它们会分别被返回到它们的公共祖先节点
- 在公共祖先节点，左右子树都返回非空
- 该节点被返回为 LCA

**简化版本（合并情况2和3）：**

```cpp
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (root == nullptr || root == p || root == q) {
        return root;
    }
    
    TreeNode* left = lowestCommonAncestor(root->left, p, q);
    TreeNode* right = lowestCommonAncestor(root->right, p, q);
    
    // 如果左右都非空，返回root
    // 否则返回非空的那个（如果都为空，返回nullptr）
    return (left != nullptr && right != nullptr) ? root : 
           (left != nullptr ? left : right);
}
```

这个问题体现了递归的精妙之处，理解递归返回值的多重含义是解题的关键。


---

## 相关笔记
<!-- 自动生成 -->

暂无相关笔记

