---
created: '2025-10-19'
last_reviewed: '2025-10-19'
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/字母异位词分组.md
related_outlines: []
---

# 字母异位词分组

## 题目描述

给你一个字符串数组，请你将字母异位词组合在一起。可以按任意顺序返回结果列表。

字母异位词是由重新排列源单词的所有字母得到的一个新单词。

**示例 1：**
```
输入: strs = ["eat","tea","tan","ate","nat","bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

**示例 2：**
```
输入: strs = [""]
输出: [[""]]
```

**示例 3：**
```
输入: strs = ["a"]
输出: [["a"]]
```

**提示：**
- 1 <= strs.length <= 10^4
- 0 <= strs[i].length <= 100
- strs[i] 仅包含小写字母

## 思路讲解

字母异位词的特点是：包含相同的字符，只是顺序不同。关键是如何判断两个字符串是否为字母异位词。

### 方法一：排序作为键
最直观的方法是对每个字符串排序，排序后的结果相同的字符串就是字母异位词。

**步骤：**
1. 创建哈希表，键是排序后的字符串，值是原始字符串的列表
2. 遍历字符串数组，对每个字符串进行排序
3. 将排序后的字符串作为键，将原字符串加入对应的列表
4. 最后返回哈希表中所有的值

**示例：**
- "eat" 排序后 -> "aet"
- "tea" 排序后 -> "aet"
- "tan" 排序后 -> "ant"
- "ate" 排序后 -> "aet"

所以 "eat", "tea", "ate" 会被分到同一组。

### 方法二：字符计数作为键
另一种方法是统计每个字符串中各字符出现的次数，计数相同的字符串就是字母异位词。

**步骤：**
1. 对每个字符串，统计 26 个字母出现的次数
2. 将计数数组转换为字符串作为哈希表的键
3. 将原字符串加入对应的列表

**本题采用方法一**，因为实现更简洁，且对于长度不大的字符串，排序的开销是可接受的。

## 面试时的快速口述讲解

这道题要求把字母异位词分组，字母异位词就是包含相同字母但顺序不同的单词。

**数据结构**：使用哈希表（unordered_map），键是字符串的某种"标准形式"，值是属于该组的所有字符串列表。

**实现方式**：
1. 遍历所有字符串
2. 对每个字符串排序，得到其"标准形式"
3. 将排序后的字符串作为键，把原字符串加入对应的分组
4. 最后将哈希表中所有分组输出

**关键点**：排序后相同的字符串一定是字母异位词，因为它们包含完全相同的字符。

**时间复杂度**：O(n * k log k)，其中 n 是字符串数量，k 是字符串的最大长度。每个字符串需要排序。

**空间复杂度**：O(n * k)，需要存储所有字符串。

## 代码实现

```cpp
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        // 哈希表：排序后的字符串 -> 原字符串列表
        unordered_map<string, vector<string>> hashMap;
        
        for (const string& str : strs) {
            // 将字符串排序作为键
            string key = str;
            sort(key.begin(), key.end());
            
            // 将原字符串加入对应的分组
            hashMap[key].push_back(str);
        }
        
        // 收集所有分组
        vector<vector<string>> result;
        for (auto& pair : hashMap) {
            result.push_back(pair.second);
        }
        
        return result;
    }
};
```

**代码说明：**
1. 创建哈希表 `hashMap`，键是排序后的字符串，值是字符串列表
2. 遍历输入的字符串数组：
   - 将当前字符串复制一份并排序，作为键
   - 将原字符串加入对应键的列表中
3. 遍历哈希表，将所有分组收集到结果数组中
4. 返回结果

**优化版本（使用字符计数）：**
```cpp
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> hashMap;
        
        for (const string& str : strs) {
            // 统计字符出现次数
            string key = getKey(str);
            hashMap[key].push_back(str);
        }
        
        vector<vector<string>> result;
        for (auto& pair : hashMap) {
            result.push_back(pair.second);
        }
        
        return result;
    }
    
private:
    // 将字符串转换为计数字符串
    string getKey(const string& str) {
        vector<int> count(26, 0);
        for (char c : str) {
            count[c - 'a']++;
        }
        
        string key;
        for (int i = 0; i < 26; i++) {
            if (count[i] > 0) {
                key += string(count[i], 'a' + i);
            }
        }
        return key;
    }
};
```

这个优化版本的时间复杂度是 O(n * k)，因为避免了排序操作。


---

## 相关笔记
<!-- 自动生成 -->

暂无相关笔记

