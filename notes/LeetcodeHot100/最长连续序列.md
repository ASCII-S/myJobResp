---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/最长连续序列.md
related_outlines: []
---
# 最长连续序列

## 题目描述

给定一个未排序的整数数组 `nums`，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 O(n) 的算法解决此问题。

**示例 1：**
```
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

**示例 2：**
```
输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
解释：最长连续序列是 [0,1,2,3,4,5,6,7,8]。
```

**提示：**
- 0 <= nums.length <= 10^5
- -10^9 <= nums[i] <= 10^9

## 思路讲解

这道题的关键在于要求 O(n) 时间复杂度，所以不能使用排序（排序至少是 O(n log n)）。

### 哈希集合解法

**核心思想：**
使用哈希集合来实现 O(1) 的查找，然后智能地遍历来避免重复计算。

**关键观察：**
- 对于一个连续序列 [1, 2, 3, 4]，我们只需要从序列的起点 1 开始遍历即可
- 如果一个数 x 是序列的起点，那么 x-1 一定不在数组中
- 因此，我们只从序列起点开始计数，避免重复计算

**算法步骤：**
1. 将所有数字放入哈希集合，便于 O(1) 查找
2. 遍历数组中的每个数 num：
   - 检查 num-1 是否在集合中
   - 如果 num-1 不存在，说明 num 是一个序列的起点
   - 从 num 开始，依次检查 num+1, num+2, ... 是否在集合中
   - 记录当前序列的长度
3. 返回最长序列的长度

**为什么是 O(n)？**
虽然有两层循环，但内层循环只会在序列起点时执行，每个数字最多被访问两次（外层一次，内层一次），所以总时间复杂度是 O(n)。

**示例分析：**
对于 [100, 4, 200, 1, 3, 2]：
- 100 是起点（99 不存在），长度为 1
- 1 是起点（0 不存在），连续到 4，长度为 4
- 200 是起点（199 不存在），长度为 1
- 2, 3, 4 不是起点（1, 2, 3 都存在），跳过

## 面试时的快速口述讲解

这道题要求在未排序数组中找最长连续序列，且要求 O(n) 时间复杂度。

**数据结构**：使用哈希集合（unordered_set）存储所有数字，实现 O(1) 的查找。

**实现方式**：
1. 先将所有数字放入哈希集合
2. 遍历每个数字，判断它是否是连续序列的起点（即 num-1 不在集合中）
3. 如果是起点，就向后连续查找 num+1, num+2, ... 直到找不到为止
4. 记录最长的序列长度

**关键优化**：只从序列起点开始计数，避免对中间数字重复计算。每个数字最多被访问常数次。

**时间复杂度**：O(n)，虽然有嵌套循环，但每个元素最多被访问两次。

**空间复杂度**：O(n)，需要哈希集合存储所有元素。

## 代码实现

```cpp
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        // 将所有数字放入哈希集合
        unordered_set<int> numSet(nums.begin(), nums.end());
        int maxLength = 0;
        
        // 遍历每个数字
        for (int num : numSet) {
            // 只从序列的起点开始计算
            // 如果 num-1 存在，说明 num 不是起点，跳过
            if (numSet.find(num - 1) == numSet.end()) {
                int currentNum = num;
                int currentLength = 1;
                
                // 向后查找连续的数字
                while (numSet.find(currentNum + 1) != numSet.end()) {
                    currentNum++;
                    currentLength++;
                }
                
                // 更新最大长度
                maxLength = max(maxLength, currentLength);
            }
        }
        
        return maxLength;
    }
};
```

**代码说明：**
1. 使用 `unordered_set` 存储所有数字，便于 O(1) 查找
2. 遍历集合中的每个数字 `num`：
   - 检查 `num - 1` 是否存在，如果存在说明 `num` 不是序列起点，跳过
   - 如果 `num` 是起点，开始向后查找 `num + 1, num + 2, ...`
   - 记录当前序列的长度
3. 维护并返回最大长度

**复杂度分析：**
- 外层循环遍历 n 个元素
- 内层 while 循环看似是 O(n)，但由于只在序列起点执行，所有序列加起来总共只有 n 个元素
- 每个元素最多被访问两次：一次在外层循环，一次在内层 while 循环
- 因此总时间复杂度是 O(n) + O(n) = O(n)

**易错点：**
- 不要忘记去重（使用 set 自动去重）
- 注意整数溢出问题（本题数据范围在 int 内）
- 理解为什么是 O(n)：关键在于只从起点开始遍历


---

## 相关笔记
<!-- 自动生成 -->

暂无相关笔记

