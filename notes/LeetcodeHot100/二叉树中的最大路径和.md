---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/二叉树中的最大路径和.md
related_outlines: []
---
# 二叉树中的最大路径和

## 题目描述

**路径**被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中**至多出现一次**。该路径**至少包含一个**节点，且不一定经过根节点。

**路径和**是路径中各节点值的总和。

给你一个二叉树的根节点 `root`，返回其**最大路径和**。

**示例 1：**
```
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
```

**示例 2：**
```
输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
```

**提示：**
- 树中节点数目范围是 [1, 3 * 10^4]
- -1000 <= Node.val <= 1000

## 思路讲解

这是一道困难题，综合考查了递归、路径问题和边界处理。

### 核心思想

路径可以分为两种情况：
1. **单边路径**：从节点向下延伸的路径（可以向上返回给父节点）
2. **双边路径**：经过当前节点，连接左右子树的路径（不能继续向上）

### 关键观察

对于每个节点，经过它的最大路径和 = 左子树的最大贡献 + 右子树的最大贡献 + 节点值

但是，向父节点返回时，只能选择左右子树的一条路径（单边）。

### 递归设计

递归函数 `maxGain(node)` 返回：
- 以 `node` 为根的子树，向上能提供的最大路径和（单边路径）
- 同时，在递归过程中更新全局最大路径和（可能是双边路径）

### 处理负数

- 如果子树的贡献是负数，不如不选择该子树（贡献设为 0）
- 使用 `max(0, maxGain(child))` 来处理负数情况

### 关键点

- **双重作用**：递归函数既要返回单边路径和，又要更新全局最大路径和
- **负数处理**：子树贡献为负时，不选择该子树
- **全局变量**：使用全局变量或引用参数记录最大路径和
- **后序遍历**：需要先知道子树信息，才能计算当前节点

## 面试时的快速口述讲解

这道题要求计算二叉树中的最大路径和，路径可以从任意节点开始和结束。

**数据结构**：使用递归（后序遍历），需要一个全局变量记录最大路径和。

**实现方式**：
1. 递归计算每个节点能向父节点提供的最大路径和（单边路径）
2. 在递归过程中，计算经过当前节点的最大路径和（双边路径：左子树贡献 + 节点值 + 右子树贡献）
3. 用全局变量维护所有路径中的最大值
4. 对于负数贡献的子树，直接舍弃（贡献设为 0）
5. 递归返回时，只能选择左右子树中贡献较大的一边（因为路径不能分叉）

**时间复杂度**：O(n)，每个节点访问一次。

**空间复杂度**：O(h)，h 是树的高度，递归调用栈的深度。

## 代码实现

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxPathSum(TreeNode* root) {
        int maxSum = INT_MIN;  // 全局最大路径和
        maxGain(root, maxSum);
        return maxSum;
    }
    
private:
    // 返回以 node 为根节点，向上能提供的最大路径和
    int maxGain(TreeNode* node, int& maxSum) {
        // 空节点的贡献为 0
        if (node == nullptr) {
            return 0;
        }
        
        // 递归计算左右子树的最大贡献
        // 如果贡献为负数，不如不选（设为0）
        int leftGain = max(0, maxGain(node->left, maxSum));
        int rightGain = max(0, maxGain(node->right, maxSum));
        
        // 计算经过当前节点的最大路径和（双边路径）
        int currentPathSum = node->val + leftGain + rightGain;
        
        // 更新全局最大路径和
        maxSum = max(maxSum, currentPathSum);
        
        // 返回当前节点向上能提供的最大路径和（单边路径）
        // 只能选择左右子树中贡献较大的一边
        return node->val + max(leftGain, rightGain);
    }
};
```

**代码说明：**

1. **主函数 `maxPathSum`**：
   - 初始化全局最大路径和 `maxSum` 为 `INT_MIN`
   - 调用递归函数 `maxGain`
   - 返回最终的最大路径和

2. **递归函数 `maxGain`**：
   - **参数**：当前节点 `node`，全局最大路径和的引用 `maxSum`
   - **返回值**：以当前节点为根，向上能提供的最大路径和（单边）
   
   - **递归终止条件**：空节点返回 0
   
   - **递归逻辑**：
     - 递归计算左右子树的最大贡献
     - 使用 `max(0, maxGain(child))` 处理负数情况
     - 计算经过当前节点的最大路径和（双边）：`node->val + leftGain + rightGain`
     - 更新全局最大值
     - 返回单边路径和：`node->val + max(leftGain, rightGain)`

3. **关键点**：
   - **leftGain 和 rightGain**：左右子树向当前节点提供的最大贡献
   - **负数处理**：`max(0, ...)` 确保不选择负贡献的子树
   - **currentPathSum**：经过当前节点的双边路径和（用于更新全局最大值）
   - **返回值**：单边路径和（只能选择一边，用于向父节点提供贡献）

**执行过程示例**（以 [-10,9,20,null,null,15,7] 为例）：

```
树的结构：
     -10
     /  \
    9   20
       /  \
      15   7

递归过程（后序遍历）：

1. 节点 9（叶子）：
   leftGain = 0, rightGain = 0
   currentPathSum = 9 + 0 + 0 = 9
   maxSum = 9
   返回 9

2. 节点 15（叶子）：
   leftGain = 0, rightGain = 0
   currentPathSum = 15
   maxSum = 15
   返回 15

3. 节点 7（叶子）：
   leftGain = 0, rightGain = 0
   currentPathSum = 7
   maxSum = 15（不变）
   返回 7

4. 节点 20：
   leftGain = max(0, 15) = 15
   rightGain = max(0, 7) = 7
   currentPathSum = 20 + 15 + 7 = 42
   maxSum = 42
   返回 20 + max(15, 7) = 35（选择左边）

5. 节点 -10（根）：
   leftGain = max(0, 9) = 9
   rightGain = max(0, 35) = 35
   currentPathSum = -10 + 9 + 35 = 34
   maxSum = 42（不变）
   返回 -10 + max(9, 35) = 25

最终答案：42（路径 15 -> 20 -> 7）
```

**为什么要返回单边路径？**

考虑这个例子：
```
    A
   / \
  B   C
```

当处理节点 A 时：
- 经过 A 的最大路径是 B -> A -> C（双边）
- 但是，A 的父节点只能使用 A 的一条路径（A -> B 或 A -> C）
- 所以返回值是单边的：A + max(B的贡献, C的贡献)

**常见错误：**

1. **忘记处理负数**：
   - 错误：直接使用子树的返回值
   - 正确：使用 `max(0, maxGain(child))`

2. **返回值错误**：
   - 错误：返回 `node->val + leftGain + rightGain`（双边）
   - 正确：返回 `node->val + max(leftGain, rightGain)`（单边）

3. **初始值错误**：
   - 错误：初始化 `maxSum = 0`
   - 正确：初始化 `maxSum = INT_MIN`（因为可能所有节点都是负数）

**这道题的难点：**
- 理解单边路径和双边路径的区别
- 递归函数的双重作用（更新全局 + 返回局部）
- 正确处理负数节点
- 理解为什么返回单边而更新双边

这是一道综合性很强的题目，考查了对树的递归、路径问题和边界处理的深刻理解。


---

## 相关笔记
<!-- 自动生成 -->

暂无相关笔记

