---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/排序链表.md
related_outlines: []
---
# 排序链表

## 题目描述

给你链表的头结点 `head`，请将其按**升序**排列并返回**排序后的链表**。

**示例 1：**
```
输入：head = [4,2,1,3]
输出：[1,2,3,4]
```

**示例 2：**
```
输入：head = [-1,5,3,4,0]
输出：[-1,0,3,4,5]
```

**示例 3：**
```
输入：head = []
输出：[]
```

**提示：**
- 链表中节点的数目在范围 [0, 5 * 10^4] 内
- -10^5 <= Node.val <= 10^5

**进阶：** 你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？

## 思路讲解

这道题要求对链表进行排序，关键是选择合适的排序算法。

### 常见排序算法对比

**数组排序常用算法：**
- 快速排序：平均 O(n log n)，但需要随机访问
- 归并排序：O(n log n)，适合链表
- 堆排序：O(n log n)，需要随机访问

**链表特点：**
- 不支持随机访问，访问第 i 个元素需要 O(i) 时间
- 插入和删除操作方便（只需修改指针）
- **归并排序最适合链表**

### 方法一：自顶向下归并排序（递归）

**核心思路：**
使用归并排序，这是最适合链表的排序算法。

**归并排序步骤：**
1. **分割**：找到链表中点，将链表分成两半
2. **递归**：递归地对两个子链表排序
3. **合并**：合并两个有序链表

**关键技巧：**
- 使用快慢指针找到链表中点
- 合并两个有序链表（可以复用"合并两个有序链表"的代码）

**复杂度：**
- 时间复杂度：O(n log n)
- 空间复杂度：O(log n)（递归调用栈）

### 方法二：自底向上归并排序（迭代）

满足进阶要求的解法，空间复杂度为 O(1)。

**核心思路：**
不使用递归，而是迭代地进行归并。

**步骤：**
1. 从长度为 1 的子链表开始归并
2. 每次将归并长度翻倍：1 -> 2 -> 4 -> 8 -> ...
3. 直到归并长度超过链表长度

**优势：**
- 空间复杂度 O(1)
- 不需要递归栈

## 面试时的快速口述讲解

这道题要求对链表进行排序，归并排序是最适合链表的排序算法。

**数据结构**：使用归并排序，需要快慢指针找中点，以及合并两个有序链表。

**实现方式（自顶向下归并排序）**：
1. 递归终止条件：链表为空或只有一个节点，直接返回
2. 使用快慢指针找到链表中点
3. 将链表从中点断开，分成两个子链表
4. 递归地对两个子链表进行排序
5. 合并两个排序后的有序链表
6. 返回合并后的链表头节点

**时间复杂度**：O(n log n)，归并排序的标准复杂度，分割 log n 层，每层合并 O(n)。

**空间复杂度**：O(log n)，递归调用栈的深度。如果使用自底向上的迭代归并排序，可以达到 O(1)。

## 代码实现

### 方法一：自顶向下归并排序（递归，推荐）

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        // 递归终止条件：空链表或只有一个节点
        if (head == nullptr || head->next == nullptr) {
            return head;
        }
        
        // 使用快慢指针找到链表中点
        ListNode* mid = findMiddle(head);
        
        // 保存后半部分的头节点
        ListNode* rightHead = mid->next;
        // 断开链表
        mid->next = nullptr;
        
        // 递归排序两个子链表
        ListNode* left = sortList(head);
        ListNode* right = sortList(rightHead);
        
        // 合并两个有序链表
        return mergeTwoLists(left, right);
    }
    
private:
    // 找到链表中点（使用快慢指针）
    ListNode* findMiddle(ListNode* head) {
        ListNode* slow = head;
        ListNode* fast = head;
        
        // 注意：这里的条件是为了让 slow 停在中间偏左的位置
        // 例如 [1,2,3,4]，slow 会停在 2
        while (fast->next != nullptr && fast->next->next != nullptr) {
            slow = slow->next;
            fast = fast->next->next;
        }
        
        return slow;
    }
    
    // 合并两个有序链表
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* dummy = new ListNode(0);
        ListNode* curr = dummy;
        
        while (l1 != nullptr && l2 != nullptr) {
            if (l1->val <= l2->val) {
                curr->next = l1;
                l1 = l1->next;
            } else {
                curr->next = l2;
                l2 = l2->next;
            }
            curr = curr->next;
        }
        
        // 连接剩余部分
        curr->next = (l1 != nullptr) ? l1 : l2;
        
        return dummy->next;
    }
};
```

**代码说明：**

**找中点的技巧：**
```
为什么循环条件是 fast->next != nullptr && fast->next->next != nullptr？

示例 [1,2,3,4]：
初始：slow=1, fast=1
步骤1：slow=2, fast=3
步骤2：fast->next->next == nullptr，停止
结果：slow=2（中间偏左）

这样可以保证分割后左右两部分长度相近
左部分：[1,2]，右部分：[3,4]
```

**归并排序过程图解（[4,2,1,3]）：**
```
原链表：4 -> 2 -> 1 -> 3

第1层分割：
  [4,2,1,3]
  找中点：2
  分割成：[4,2] 和 [1,3]

第2层分割：
  [4,2]              [1,3]
  找中点：4          找中点：1
  分割成：[4] [2]    分割成：[1] [3]

第3层（递归终止）：
  [4] [2] [1] [3]  (都是单个节点，已有序)

开始合并：
  第1次合并：
    merge([4], [2]) = [2,4]
    merge([1], [3]) = [1,3]
  
  第2次合并：
    merge([2,4], [1,3]) = [1,2,3,4]

最终结果：1 -> 2 -> 3 -> 4
```

**递归调用树：**
```
sortList([4,2,1,3])
├─ sortList([4,2])
│  ├─ sortList([4]) -> [4]
│  ├─ sortList([2]) -> [2]
│  └─ merge([4],[2]) -> [2,4]
├─ sortList([1,3])
│  ├─ sortList([1]) -> [1]
│  ├─ sortList([3]) -> [3]
│  └─ merge([1],[3]) -> [1,3]
└─ merge([2,4],[1,3]) -> [1,2,3,4]
```

### 方法二：自底向上归并排序（迭代，O(1) 空间）

```cpp
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if (head == nullptr || head->next == nullptr) {
            return head;
        }
        
        // 1. 计算链表长度
        int length = 0;
        ListNode* curr = head;
        while (curr != nullptr) {
            length++;
            curr = curr->next;
        }
        
        // 创建虚拟头节点
        ListNode* dummy = new ListNode(0, head);
        
        // 2. 从长度1开始，每次翻倍
        for (int subLen = 1; subLen < length; subLen *= 2) {
            ListNode* prev = dummy;
            curr = dummy->next;
            
            // 3. 对每对长度为 subLen 的子链表进行合并
            while (curr != nullptr) {
                // 获取第一个子链表
                ListNode* head1 = curr;
                for (int i = 1; i < subLen && curr->next != nullptr; i++) {
                    curr = curr->next;
                }
                
                // 获取第二个子链表
                ListNode* head2 = curr->next;
                curr->next = nullptr;  // 断开第一个子链表
                curr = head2;
                
                for (int i = 1; i < subLen && curr != nullptr && curr->next != nullptr; i++) {
                    curr = curr->next;
                }
                
                // 保存下一对的起始位置
                ListNode* next = nullptr;
                if (curr != nullptr) {
                    next = curr->next;
                    curr->next = nullptr;  // 断开第二个子链表
                }
                
                // 合并两个子链表
                ListNode* merged = mergeTwoLists(head1, head2);
                prev->next = merged;
                
                // 移动 prev 到合并后链表的末尾
                while (prev->next != nullptr) {
                    prev = prev->next;
                }
                
                curr = next;
            }
        }
        
        return dummy->next;
    }
    
private:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* dummy = new ListNode(0);
        ListNode* curr = dummy;
        
        while (l1 != nullptr && l2 != nullptr) {
            if (l1->val <= l2->val) {
                curr->next = l1;
                l1 = l1->next;
            } else {
                curr->next = l2;
                l2 = l2->next;
            }
            curr = curr->next;
        }
        
        curr->next = (l1 != nullptr) ? l1 : l2;
        return dummy->next;
    }
};
```

**自底向上归并过程图解（[4,2,1,3]）：**
```
原链表：4 -> 2 -> 1 -> 3

subLen = 1：每次合并两个长度为1的子链表
  merge([4], [2]) = [2,4]
  merge([1], [3]) = [1,3]
  结果：2 -> 4 -> 1 -> 3

subLen = 2：每次合并两个长度为2的子链表
  merge([2,4], [1,3]) = [1,2,3,4]
  结果：1 -> 2 -> 3 -> 4

subLen = 4 >= length，结束
```

**复杂度对比：**
- 方法一（递归）：时间 O(n log n)，空间 O(log n)，代码清晰，推荐
- 方法二（迭代）：时间 O(n log n)，空间 O(1)，满足进阶要求

**面试技巧：**
- 优先使用递归归并排序，代码更清晰
- 说明为什么归并排序适合链表（不需要随机访问）
- 强调快慢指针找中点的技巧
- 如果面试官追问空间优化，再说迭代版本
- 可以对比其他排序算法（快排、堆排）为什么不适合链表


---

## 相关笔记
<!-- 自动生成 -->

- [两两交换链表中的节点](notes/LeetcodeHot100/两两交换链表中的节点.md) - 相似度: 31% | 标签: LeetcodeHot100, LeetcodeHot100/两两交换链表中的节点.md

