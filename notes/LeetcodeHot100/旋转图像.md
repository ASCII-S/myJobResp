---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/旋转图像.md
related_outlines: []
---
# 旋转图像

## 题目描述

给定一个 `n × n` 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在**原地**旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要**使用另一个矩阵来旋转图像。

**示例 1：**
```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]
```

**示例 2：**
```
输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
```

**提示：**
- n == matrix.length == matrix[i].length
- 1 <= n <= 20
- -1000 <= matrix[i][j] <= 1000

## 思路讲解

顺时针旋转 90 度有两种巧妙的方法。

### 方法一：先转置，再水平翻转

**核心思想：**
顺时针旋转 90° = 转置 + 水平翻转（每行反转）

**数学原理：**
```
原矩阵位置 [i][j] 旋转后到 [j][n-1-i]

分解为两步：
1. 转置：[i][j] → [j][i]
2. 水平翻转：[j][i] → [j][n-1-i]
```

**示例演示：**
```
原矩阵：
1  2  3
4  5  6
7  8  9

步骤1：转置（沿主对角线翻转）
1  4  7
2  5  8
3  6  9

步骤2：水平翻转（每行反转）
7  4  1
8  5  2
9  6  3

完成！
```

**算法步骤：**
1. 转置矩阵：交换 `matrix[i][j]` 和 `matrix[j][i]`
2. 水平翻转：反转每一行

### 方法二：一次遍历（按层旋转）

**核心思想：**
从外到内一层层处理，每层进行四元素循环交换。

**四元素交换：**
```
temp = 上
上 = 左
左 = 下
下 = 右
右 = temp
```

这种方法更复杂但只需一次遍历。

## 面试时的快速口述讲解

这道题要将矩阵顺时针旋转 90 度，要求原地操作。

**数据结构**：原地操作，不需要额外空间。

**实现方式（先转置再翻转）**：
1. 先对矩阵进行转置：沿主对角线交换元素
2. 然后对每一行进行水平翻转

**关键点**：
- 转置时只需遍历上三角（或下三角），避免重复交换
- 水平翻转用双指针交换

**为什么可行？**
- 顺时针旋转 90° 等价于先转置再每行反转
- 这个性质可以通过坐标变换推导出来

**时间复杂度**：O(n²)，需要访问每个元素。

**空间复杂度**：O(1)，原地操作。

## 代码实现

### 方法一：转置 + 翻转（推荐）

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        
        // 步骤1：转置矩阵（沿主对角线翻转）
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }
        
        // 步骤2：水平翻转（反转每一行）
        for (int i = 0; i < n; i++) {
            reverse(matrix[i].begin(), matrix[i].end());
        }
    }
};
```

**代码说明：**
1. **转置**：遍历上三角（`j` 从 `i+1` 开始），交换 `[i][j]` 和 `[j][i]`
2. **翻转**：反转每一行

**手动实现 reverse：**
```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        
        // 步骤1：转置
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }
        
        // 步骤2：每行翻转
        for (int i = 0; i < n; i++) {
            int left = 0, right = n - 1;
            while (left < right) {
                swap(matrix[i][left], matrix[i][right]);
                left++;
                right--;
            }
        }
    }
};
```

### 方法二：按层旋转（一次遍历）

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        
        // 按层处理，每层进行四元素循环交换
        for (int layer = 0; layer < n / 2; layer++) {
            int first = layer;
            int last = n - 1 - layer;
            
            for (int i = first; i < last; i++) {
                int offset = i - first;
                
                // 保存上边
                int top = matrix[first][i];
                
                // 左 → 上
                matrix[first][i] = matrix[last - offset][first];
                
                // 下 → 左
                matrix[last - offset][first] = matrix[last][last - offset];
                
                // 右 → 下
                matrix[last][last - offset] = matrix[i][last];
                
                // 上 → 右
                matrix[i][last] = top;
            }
        }
    }
};
```

**按层旋转说明：**
- 外层循环：从外到内遍历每一层
- 内层循环：处理当前层的每个位置
- 四元素循环交换：top → right → bottom → left → top

### 方法三：坐标变换（更直观）

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        
        // 创建临时矩阵存储结果
        vector<vector<int>> temp = matrix;
        
        // 坐标变换：[i][j] → [j][n-1-i]
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                temp[j][n - 1 - i] = matrix[i][j];
            }
        }
        
        matrix = temp;
    }
};
```

这个方法需要 O(n²) 额外空间，不符合题目要求，但容易理解。

**复杂度分析：**

| 方法           | 时间复杂度 | 空间复杂度 | 难度 |
| -------------- | ---------- | ---------- | ---- |
| 转置+翻转      | O(n²)      | O(1)       | 简单 |
| 按层旋转       | O(n²)      | O(1)       | 中等 |
| 坐标变换(额外) | O(n²)      | O(n²)      | 简单 |

**易错点：**
1. **转置时的遍历范围**：
   - 正确：`j` 从 `i+1` 开始（上三角）
   - 错误：`j` 从 0 开始（会交换两次，恢复原状）
2. 理解转置的含义：沿主对角线翻转
3. 区分水平翻转和垂直翻转

**推导过程：**
```
顺时针旋转90°：[i][j] → [j][n-1-i]

分解步骤：
1. 转置：[i][j] → [j][i]
2. 水平翻转：[j][i] → [j][n-1-i]

验证：
原坐标 [0][1] → 目标 [1][2]（假设 n=3）
转置：[0][1] → [1][0]
翻转：[1][0] → [1][2] ✓
```

**其他旋转方式：**

**逆时针旋转 90°：先转置，再垂直翻转**
```cpp
void rotateCounterClockwise(vector<vector<int>>& matrix) {
    int n = matrix.size();
    
    // 转置
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            swap(matrix[i][j], matrix[j][i]);
        }
    }
    
    // 垂直翻转（上下翻转）
    for (int i = 0; i < n / 2; i++) {
        swap(matrix[i], matrix[n - 1 - i]);
    }
}
```

**旋转 180°：水平翻转 + 垂直翻转**
```cpp
void rotate180(vector<vector<int>>& matrix) {
    int n = matrix.size();
    
    // 水平翻转
    for (int i = 0; i < n; i++) {
        reverse(matrix[i].begin(), matrix[i].end());
    }
    
    // 垂直翻转
    for (int i = 0; i < n / 2; i++) {
        swap(matrix[i], matrix[n - 1 - i]);
    }
}
```


---

## 相关笔记
<!-- 自动生成 -->

暂无相关笔记

