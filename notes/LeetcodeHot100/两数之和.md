# 两数之和

## 题目描述

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出和为目标值 `target` 的那两个整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**示例 1：**
```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9，返回 [0, 1]。
```

**示例 2：**
```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**
```
输入：nums = [3,3], target = 6
输出：[0,1]
```

**提示：**
- 2 <= nums.length <= 10^4
- -10^9 <= nums[i] <= 10^9
- -10^9 <= target <= 10^9
- 只会存在一个有效答案

## 思路讲解

这道题是经典的哈希表应用问题。

### 暴力解法
最直观的想法是使用两层循环，遍历所有可能的两个数的组合，时间复杂度为 O(n²)。

### 哈希表优化
我们可以使用哈希表来优化这个过程：
1. 遍历数组，对于每个元素 `nums[i]`
2. 计算 `complement = target - nums[i]`
3. 查找哈希表中是否存在 `complement`
4. 如果存在，说明找到了答案，返回当前索引和哈希表中存储的索引
5. 如果不存在，将当前元素及其索引存入哈希表

**为什么这样可行？**
- 当我们遍历到元素 `nums[i]` 时，如果它的配对元素在前面出现过，那么这个配对元素已经在哈希表中了
- 我们只需要一次遍历，因为如果 `a + b = target`，那么当遍历到 `b` 时，`a` 已经在哈希表中了

**关键点：**
- 使用哈希表存储 `值 -> 索引` 的映射
- 边遍历边查找，避免同一元素被使用两次
- 时间复杂度：O(n)，空间复杂度：O(n)

## 面试时的快速口述讲解

这道题要求在数组中找两个数的和等于目标值，并返回它们的索引。

**数据结构**：使用哈希表（unordered_map）存储值到索引的映射。

**实现方式**：
1. 遍历数组，对每个元素计算它需要的配对值（target - 当前值）
2. 在哈希表中查找这个配对值是否存在
3. 如果存在，返回两个索引；如果不存在，将当前元素存入哈希表继续遍历

**时间复杂度**：O(n)，只需要遍历一次数组，哈希表的查找和插入都是 O(1)。

**空间复杂度**：O(n)，最坏情况下需要存储所有元素到哈希表中。

## 代码实现

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        // 哈希表存储：值 -> 索引
        unordered_map<int, int> hashMap;
        
        for (int i = 0; i < nums.size(); i++) {
            // 计算需要的配对值
            int complement = target - nums[i];
            
            // 如果配对值在哈希表中，说明找到了答案
            if (hashMap.find(complement) != hashMap.end()) {
                return {hashMap[complement], i};
            }
            
            // 将当前元素存入哈希表
            hashMap[nums[i]] = i;
        }
        
        // 题目保证有解，这里不会执行到
        return {};
    }
};
```

**代码说明：**
1. 创建哈希表 `hashMap`，用于存储遍历过的元素值和对应的索引
2. 遍历数组，对于每个元素 `nums[i]`：
   - 计算配对值 `complement = target - nums[i]`
   - 在哈希表中查找是否存在这个配对值
   - 如果存在，返回配对值的索引和当前索引
   - 如果不存在，将当前值和索引存入哈希表
3. 由于题目保证有解，循环结束前一定会返回答案

