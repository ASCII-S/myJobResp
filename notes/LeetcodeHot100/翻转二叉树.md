# 翻转二叉树

## 题目描述

给你一棵二叉树的根节点 `root`，翻转这棵二叉树，并返回其根节点。

**示例 1：**
```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

**示例 2：**
```
输入：root = [2,1,3]
输出：[2,3,1]
```

**示例 3：**
```
输入：root = []
输出：[]
```

**提示：**
- 树中节点数目范围在 [0, 100] 内
- -100 <= Node.val <= 100

## 思路讲解

翻转二叉树，即将每个节点的左右子树交换位置。这是一道经典的二叉树递归问题。

### 方法一：递归法

递归思路非常直观：
1. 如果节点为空，直接返回
2. 交换当前节点的左右子树
3. 递归翻转左子树
4. 递归翻转右子树

**关键点：**
- 可以先交换再递归，也可以先递归再交换
- 递归的本质是深度优先搜索（DFS）
- 每个节点只需要关心交换自己的左右子树，子树的翻转交给递归处理

### 方法二：迭代法（层序遍历）

使用队列进行层序遍历：
1. 将根节点加入队列
2. 每次从队列取出一个节点
3. 交换该节点的左右子树
4. 将左右子节点（如果存在）加入队列
5. 重复直到队列为空

**关键点：**
- 使用 BFS 遍历所有节点
- 对每个节点执行左右子树交换操作
- 队列用于存储待处理的节点

## 面试时的快速口述讲解

这道题要求翻转二叉树，即对每个节点交换其左右子树。

**数据结构**：
- 递归法：使用递归调用栈（DFS）
- 迭代法：使用队列（BFS）

**实现方式**：
- **递归法**：对于每个节点，交换其左右子节点，然后递归地翻转左右子树。这是一个自顶向下的过程
- **迭代法**：使用队列层序遍历树，对遍历到的每个节点交换其左右子节点

**时间复杂度**：O(n)，每个节点访问一次。

**空间复杂度**：
- 递归法：O(h)，h 是树的高度，递归调用栈的深度
- 迭代法：O(w)，w 是树的最大宽度，队列中最多存储一层的节点

## 代码实现

### 方法一：递归法

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        // 递归终止条件：空节点直接返回
        if (root == nullptr) {
            return nullptr;
        }
        
        // 交换左右子树
        TreeNode* temp = root->left;
        root->left = root->right;
        root->right = temp;
        
        // 递归翻转左右子树
        invertTree(root->left);
        invertTree(root->right);
        
        return root;
    }
};
```

### 方法二：迭代法（层序遍历）

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == nullptr) {
            return nullptr;
        }
        
        queue<TreeNode*> q;
        q.push(root);
        
        while (!q.empty()) {
            // 取出队首节点
            TreeNode* node = q.front();
            q.pop();
            
            // 交换当前节点的左右子树
            TreeNode* temp = node->left;
            node->left = node->right;
            node->right = temp;
            
            // 将左右子节点加入队列
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        
        return root;
    }
};
```

**代码说明：**

**递归法：**
1. 递归终止条件：如果节点为空，直接返回 nullptr
2. 交换当前节点的左右子节点（使用临时变量）
3. 递归翻转左子树
4. 递归翻转右子树
5. 返回根节点

这个递归过程会自顶向下遍历整棵树，对每个节点执行左右子树交换操作。

**迭代法：**
1. 特殊情况处理：如果根节点为空，直接返回
2. 创建队列，将根节点入队
3. 循环处理队列中的节点：
   - 取出队首节点
   - 交换该节点的左右子节点
   - 将左右子节点（如果存在）加入队列
4. 队列为空时，所有节点都处理完毕，返回根节点

这道题是 Homebrew 作者 Max Howell 在 Google 面试时被问到的题目，后来成为了一道经典面试题。

