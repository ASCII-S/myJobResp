# 对称二叉树

## 题目描述

给你一个二叉树的根节点 `root`，检查它是否轴对称。

**示例 1：**
```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

**示例 2：**
```
输入：root = [1,2,2,null,3,null,3]
输出：false
```

**提示：**
- 树中节点数目在范围 [1, 1000] 内
- -100 <= Node.val <= 100

**进阶：** 你可以运用递归和迭代两种方法解决这个问题吗？

## 思路讲解

判断二叉树是否对称，关键在于判断左右子树是否互为镜像。

### 核心思想

一棵树对称，当且仅当：
1. 左子树的左孩子 = 右子树的右孩子
2. 左子树的右孩子 = 右子树的左孩子
3. 左右子树的根节点值相等

换句话说，需要比较的是两个子树的"镜像"关系。

### 方法一：递归法

创建辅助函数 `isMirror(left, right)` 判断两棵树是否互为镜像：
1. 如果两个节点都为空，返回 true
2. 如果只有一个为空，返回 false
3. 如果两个节点的值不相等，返回 false
4. 递归判断：
   - left 的左子树和 right 的右子树是否镜像
   - left 的右子树和 right 的左子树是否镜像

**关键点：**
- 将问题转化为"判断两棵树是否互为镜像"
- 递归时注意比较的是"外侧"和"外侧"，"内侧"和"内侧"
- 四个递归终止条件要考虑清楚

### 方法二：迭代法（使用队列）

使用队列模拟递归过程：
1. 初始时将根节点的左右子树入队
2. 每次从队列取出两个节点进行比较
3. 如果值相等，将它们的子节点按照"镜像"顺序入队：
   - left 的左孩子和 right 的右孩子
   - left 的右孩子和 right 的左孩子
4. 重复直到队列为空

**关键点：**
- 每次取出一对节点进行比较
- 入队时注意顺序，保证成对比较的是镜像位置的节点
- 队列中节点数量总是偶数

## 面试时的快速口述讲解

这道题要求判断二叉树是否轴对称，即左子树和右子树是否互为镜像。

**数据结构**：
- 递归法：使用递归调用栈
- 迭代法：使用队列（或栈）

**实现方式**：
- **递归法**：创建辅助函数判断两棵树是否镜像。递归比较左子树的左孩子和右子树的右孩子，左子树的右孩子和右子树的左孩子
- **迭代法**：使用队列，每次取出两个节点比较，然后将它们的子节点按镜像顺序入队

**时间复杂度**：O(n)，需要遍历所有节点。

**空间复杂度**：
- 递归法：O(h)，h 是树的高度，递归调用栈深度
- 迭代法：O(w)，w 是树的最大宽度，队列中最多存储一层的节点

## 代码实现

### 方法一：递归法

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        // 空树是对称的
        if (root == nullptr) {
            return true;
        }
        // 判断左右子树是否镜像
        return isMirror(root->left, root->right);
    }
    
private:
    // 判断两棵树是否互为镜像
    bool isMirror(TreeNode* left, TreeNode* right) {
        // 都为空，镜像
        if (left == nullptr && right == nullptr) {
            return true;
        }
        // 只有一个为空，不镜像
        if (left == nullptr || right == nullptr) {
            return false;
        }
        // 值不相等，不镜像
        if (left->val != right->val) {
            return false;
        }
        
        // 递归判断：
        // 1. 左子树的左孩子 和 右子树的右孩子 是否镜像
        // 2. 左子树的右孩子 和 右子树的左孩子 是否镜像
        return isMirror(left->left, right->right) && 
               isMirror(left->right, right->left);
    }
};
```

### 方法二：迭代法（使用队列）

```cpp
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == nullptr) {
            return true;
        }
        
        queue<TreeNode*> q;
        // 初始时将左右子树入队
        q.push(root->left);
        q.push(root->right);
        
        while (!q.empty()) {
            // 每次取出两个节点进行比较
            TreeNode* left = q.front(); q.pop();
            TreeNode* right = q.front(); q.pop();
            
            // 都为空，继续比较下一对
            if (left == nullptr && right == nullptr) {
                continue;
            }
            // 只有一个为空，不对称
            if (left == nullptr || right == nullptr) {
                return false;
            }
            // 值不相等，不对称
            if (left->val != right->val) {
                return false;
            }
            
            // 按照镜像顺序将子节点入队
            // 左子树的左孩子 vs 右子树的右孩子
            q.push(left->left);
            q.push(right->right);
            // 左子树的右孩子 vs 右子树的左孩子
            q.push(left->right);
            q.push(right->left);
        }
        
        return true;
    }
};
```

**代码说明：**

**递归法：**
1. 主函数判断根节点是否为空，然后调用辅助函数 `isMirror` 判断左右子树是否镜像
2. `isMirror` 函数：
   - 如果两个节点都为空，返回 true（镜像）
   - 如果只有一个为空，返回 false（不镜像）
   - 如果值不相等，返回 false
   - 递归判断"外侧"和"内侧"节点是否镜像

**迭代法：**
1. 使用队列存储成对的待比较节点
2. 初始时将根节点的左右子树入队
3. 循环处理：
   - 每次取出两个节点 left 和 right
   - 判断它们是否满足镜像条件
   - 如果满足，将它们的子节点按镜像顺序入队：
     - left.left 和 right.right 成对
     - left.right 和 right.left 成对
4. 如果所有节点对都满足镜像条件，返回 true

**注意事项：**
- 递归法代码更简洁，但需要理解递归的思路
- 迭代法用队列模拟递归，逻辑更直观
- 关键是理解"镜像"的含义：左的左对应右的右，左的右对应右的左

