---
created: '2025-10-19'
last_reviewed: '2025-10-19'
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/相交链表.md
related_outlines: []
---

# 相交链表

## 题目描述

给你两个单链表的头节点 `headA` 和 `headB`，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null`。

图示两个链表在节点 `c1` 开始相交：

题目数据保证整个链式结构中不存在环。

注意，函数返回结果后，链表必须保持其原始结构。

**示例 1：**
```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```

**示例 2：**
```
输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```

**示例 3：**
```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。
```

**提示：**
- listA 中节点数目为 m
- listB 中节点数目为 n
- 1 <= m, n <= 3 * 10^4
- 1 <= Node.val <= 10^5
- 0 <= skipA <= m
- 0 <= skipB <= n
- 如果 listA 和 listB 没有交点，intersectVal 为 0
- 如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]

## 思路讲解

这是一道非常经典的链表问题，核心在于如何处理两个链表长度不同的情况。

### 方法一：哈希表

最直观的方法是使用哈希表：
1. 遍历链表 A，将所有节点存入哈希表
2. 遍历链表 B，检查每个节点是否在哈希表中
3. 第一个在哈希表中的节点就是相交节点

时间复杂度：O(m + n)，空间复杂度：O(m)

### 方法二：双指针（最优解）

这是一个非常巧妙的解法，利用了"消除长度差"的思想：

**核心思路：**
- 让两个指针分别从两个链表头开始遍历
- 当指针到达链表末尾时，跳转到另一个链表的头部继续遍历
- 这样两个指针走过的路径长度相同，会在相交节点相遇

**为什么这样可行？**
- 假设链表 A 的长度为 a，链表 B 的长度为 b
- 相交部分的长度为 c
- 那么链表 A 的非相交部分为 a - c，链表 B 的非相交部分为 b - c
- 指针 pA 走过的路径：a + (b - c) = a + b - c
- 指针 pB 走过的路径：b + (a - c) = a + b - c
- 两个指针走过相同的距离后会在相交节点相遇
- 如果不相交，两个指针会同时到达 null

**关键点：**
- 两个指针同步移动，到达末尾后跳转到另一个链表
- 不需要计算链表长度，自动消除长度差
- 时间复杂度：O(m + n)，空间复杂度：O(1)

## 面试时的快速口述讲解

这道题要求找到两个链表的相交节点，关键是处理两个链表长度不同的情况。

**数据结构**：使用两个指针分别指向两个链表。

**实现方式**：
1. 两个指针 pA 和 pB 分别从 headA 和 headB 开始遍历
2. 当指针到达链表末尾时，跳转到另一个链表的头部
3. pA 的路径：A链表 -> B链表，pB 的路径：B链表 -> A链表
4. 由于两个指针走过的总长度相同，它们会在相交节点相遇
5. 如果不相交，两个指针会同时到达 null

**时间复杂度**：O(m + n)，每个指针最多遍历两个链表。

**空间复杂度**：O(1)，只使用了两个指针。

## 代码实现

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        // 边界情况：如果任一链表为空，不可能相交
        if (headA == nullptr || headB == nullptr) {
            return nullptr;
        }
        
        // 两个指针分别从两个链表头开始
        ListNode* pA = headA;
        ListNode* pB = headB;
        
        // 同步移动两个指针
        // 当指针到达末尾时，跳转到另一个链表的头部
        while (pA != pB) {
            // pA 到达末尾后跳转到 headB，否则继续前进
            pA = (pA == nullptr) ? headB : pA->next;
            // pB 到达末尾后跳转到 headA，否则继续前进
            pB = (pB == nullptr) ? headA : pB->next;
        }
        
        // 返回相交节点（如果不相交，pA 和 pB 都为 nullptr）
        return pA;
    }
};
```

**代码说明：**
1. 首先处理边界情况：任一链表为空则不可能相交
2. 初始化两个指针 pA 和 pB 分别指向两个链表头
3. 循环条件是 `pA != pB`：
   - 如果 pA 到达末尾（nullptr），跳转到 headB
   - 否则 pA 继续前进到下一个节点
   - pB 同理
4. 循环结束时，pA 和 pB 要么指向相交节点，要么都为 nullptr
5. 时间复杂度分析：
   - 最坏情况下，pA 走完 A 链表和 B 链表，pB 走完 B 链表和 A 链表
   - 总共遍历 m + n 个节点

**另一种写法（哈希表方法）：**

```cpp
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        unordered_set<ListNode*> visited;
        
        // 遍历链表 A，将所有节点存入哈希表
        ListNode* cur = headA;
        while (cur != nullptr) {
            visited.insert(cur);
            cur = cur->next;
        }
        
        // 遍历链表 B，检查是否有节点在哈希表中
        cur = headB;
        while (cur != nullptr) {
            if (visited.count(cur)) {
                return cur;  // 找到相交节点
            }
            cur = cur->next;
        }
        
        return nullptr;  // 没有相交节点
    }
};
```

