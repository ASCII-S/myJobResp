---
created: '2025-10-19'
last_reviewed: '2025-10-19'
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/二叉树的最大深度.md
related_outlines: []
---

# 二叉树的最大深度

## 题目描述

给定一个二叉树的根节点 `root`，返回它的**最大深度**。

二叉树的**最大深度**是指从根节点到最远叶子节点的最长路径上的节点数。

**示例 1：**
```
输入：root = [3,9,20,null,null,15,7]
输出：3
```

**示例 2：**
```
输入：root = [1,null,2]
输出：2
```

**提示：**
- 树中节点的数量在 [0, 10^4] 范围内
- -100 <= Node.val <= 100

## 思路讲解

这是一道经典的树的深度问题，有多种解法。

### 方法一：递归法（深度优先搜索 DFS）

最直观的思路是使用递归：
1. 如果节点为空，深度为 0
2. 否则，深度 = max(左子树深度, 右子树深度) + 1

**递归思想：**
- 树的深度 = 左右子树中较大深度 + 1（当前层）
- 自底向上返回深度信息
- 递归的本质是深度优先搜索（DFS）

### 方法二：层序遍历（广度优先搜索 BFS）

使用队列进行层序遍历：
1. 使用队列存储每一层的节点
2. 每处理完一层，深度加 1
3. 直到队列为空，返回深度

**关键点：**
- BFS 逐层遍历，层数即为深度
- 需要记录每一层的节点数量，以便区分层次
- 队列用于存储待访问的节点

## 面试时的快速口述讲解

这道题要求计算二叉树的最大深度，即从根节点到最远叶子节点的路径长度。

**数据结构**：
- 递归法：使用递归调用栈（DFS）
- 迭代法：使用队列（BFS）

**实现方式**：
- **递归法**：采用深度优先搜索，递归计算左右子树的最大深度，取较大值加 1。公式为：depth = max(leftDepth, rightDepth) + 1
- **迭代法**：采用广度优先搜索（层序遍历），使用队列逐层遍历，统计层数即为深度

**时间复杂度**：O(n)，每个节点访问一次。

**空间复杂度**：
- 递归法：O(h)，h 是树的高度，最坏情况 O(n)
- 迭代法：O(w)，w 是树的最大宽度，最坏情况 O(n)

## 代码实现

### 方法一：递归法（DFS）

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        // 递归终止条件：空节点深度为 0
        if (root == nullptr) {
            return 0;
        }
        
        // 递归计算左右子树的最大深度
        int leftDepth = maxDepth(root->left);
        int rightDepth = maxDepth(root->right);
        
        // 当前树的深度 = 左右子树的最大深度 + 1
        return max(leftDepth, rightDepth) + 1;
    }
};
```

### 方法二：层序遍历（BFS）

```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        
        queue<TreeNode*> q;
        q.push(root);
        int depth = 0;
        
        // 层序遍历
        while (!q.empty()) {
            int levelSize = q.size();  // 当前层的节点数
            
            // 处理当前层的所有节点
            for (int i = 0; i < levelSize; i++) {
                TreeNode* node = q.front();
                q.pop();
                
                // 将下一层的节点加入队列
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
            
            depth++;  // 处理完一层，深度加 1
        }
        
        return depth;
    }
};
```

**代码说明：**

**递归法：**
1. 递归终止条件：如果节点为空，返回深度 0
2. 递归计算左子树和右子树的最大深度
3. 返回左右子树深度的较大值加 1（当前节点的深度）
4. 这是一个自底向上的过程，从叶子节点开始返回深度信息

**迭代法（层序遍历）：**
1. 使用队列进行 BFS，初始时将根节点入队
2. 外层循环处理每一层：
   - 记录当前层的节点数 `levelSize`
   - 内层循环处理当前层的所有节点
   - 将当前节点的子节点加入队列（为下一层做准备）
3. 每处理完一层，深度加 1
4. 队列为空时，所有层都处理完毕，返回深度

两种方法都是正确的，递归法代码更简洁，迭代法更直观地体现了"深度"的概念。


---

## 相关笔记
<!-- 自动生成 -->

- [二叉树的右视图](notes/LeetcodeHot100/二叉树的右视图.md) - 相似度: 36% | 标签: LeetcodeHot100, LeetcodeHot100/二叉树的右视图.md
- [二叉树的中序遍历](notes/LeetcodeHot100/二叉树的中序遍历.md) - 相似度: 33% | 标签: LeetcodeHot100, LeetcodeHot100/二叉树的中序遍历.md
- [翻转二叉树](notes/LeetcodeHot100/翻转二叉树.md) - 相似度: 33% | 标签: LeetcodeHot100, LeetcodeHot100/翻转二叉树.md
- [二叉树的层序遍历](notes/LeetcodeHot100/二叉树的层序遍历.md) - 相似度: 31% | 标签: LeetcodeHot100, LeetcodeHot100/二叉树的层序遍历.md

