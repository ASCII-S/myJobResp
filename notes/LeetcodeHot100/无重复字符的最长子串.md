# 无重复字符的最长子串

## 题目描述

给定一个字符串 `s`，请你找出其中不含有重复字符的**最长子串**的长度。

**示例 1：**
```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2：**
```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3：**
```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

**提示：**
- 0 <= s.length <= 5 × 10^4
- s 由英文字母、数字、符号和空格组成

## 思路讲解

这是一道经典的滑动窗口问题。

### 滑动窗口解法

**核心思想：**
使用滑动窗口维护一个不含重复字符的子串，用哈希表记录字符最后出现的位置。

**算法步骤：**
1. 使用两个指针 `left` 和 `right` 表示窗口的左右边界
2. 使用哈希表记录每个字符最后出现的位置
3. 右指针 `right` 向右移动，扩大窗口：
   - 如果 `s[right]` 之前出现过，且在当前窗口内
   - 将左指针移动到重复字符的下一个位置
4. 更新字符的最后出现位置
5. 更新最大长度

**为什么这样可行？**
- 当遇到重复字符时，当前窗口 `[left, right)` 中一定包含重复字符
- 我们需要将 `left` 移动到重复字符的下一个位置，这样新窗口就不包含重复字符了
- 通过哈希表可以快速找到重复字符的位置

**示例演示：**
```
s = "abcabcbb"

right=0, s[0]='a', window="a", left=0, maxLen=1
right=1, s[1]='b', window="ab", left=0, maxLen=2
right=2, s[2]='c', window="abc", left=0, maxLen=3
right=3, s[3]='a', 重复！'a'在索引0，left移到1, window="bca", maxLen=3
right=4, s[4]='b', 重复！'b'在索引1，left移到2, window="cab", maxLen=3
right=5, s[5]='c', 重复！'c'在索引2，left移到3, window="abc", maxLen=3
right=6, s[6]='b', 重复！'b'在索引4，left移到5, window="cb", maxLen=3
right=7, s[7]='b', 重复！'b'在索引6，left移到7, window="b", maxLen=3

最大长度: 3
```

**关键点：**
- 使用哈希表存储字符的索引，便于判断是否重复
- 左指针的更新：`left = max(left, map[s[right]] + 1)`，需要 max 是因为左指针只能向右移动
- 窗口长度：`right - left + 1`

## 面试时的快速口述讲解

这道题要找不含重复字符的最长子串长度。

**数据结构**：滑动窗口 + 哈希表（unordered_map）记录字符最后出现的位置。

**实现方式**：
1. 使用左右指针维护一个滑动窗口
2. 右指针向右扩展窗口，遇到新字符就加入窗口
3. 如果遇到重复字符，将左指针移动到重复字符上次出现位置的下一个位置
4. 每次更新窗口后，计算当前窗口大小，更新最大值

**关键点**：哈希表记录每个字符最后出现的索引，遇到重复字符时快速调整窗口左边界。

**时间复杂度**：O(n)，每个字符最多被访问两次（左右指针各一次）。

**空间复杂度**：O(min(n, m))，其中 m 是字符集大小，哈希表最多存储字符集中的所有字符。

## 代码实现

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        // 哈希表记录字符最后出现的位置
        unordered_map<char, int> charIndex;
        int maxLen = 0;
        int left = 0;  // 窗口左边界
        
        // 右指针遍历字符串
        for (int right = 0; right < s.length(); right++) {
            char c = s[right];
            
            // 如果字符出现过，且在当前窗口内
            if (charIndex.find(c) != charIndex.end() && charIndex[c] >= left) {
                // 移动左指针到重复字符的下一个位置
                left = charIndex[c] + 1;
            }
            
            // 更新字符的最后出现位置
            charIndex[c] = right;
            
            // 更新最大长度
            maxLen = max(maxLen, right - left + 1);
        }
        
        return maxLen;
    }
};
```

**代码说明：**
1. 使用 `unordered_map` 存储字符到索引的映射
2. `left` 指针标记窗口左边界，`right` 指针遍历字符串
3. 对于每个字符：
   - 如果字符在窗口内出现过（`charIndex[c] >= left`），更新 `left`
   - 更新字符的最后出现位置
   - 计算当前窗口长度并更新最大值
4. 返回最大长度

**简化版本（使用数组代替哈希表）：**
```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        // 使用数组代替哈希表，假设ASCII字符集
        vector<int> charIndex(128, -1);  // 初始化为-1
        int maxLen = 0;
        int left = 0;
        
        for (int right = 0; right < s.length(); right++) {
            // 如果字符在窗口内出现过
            if (charIndex[s[right]] >= left) {
                left = charIndex[s[right]] + 1;
            }
            
            charIndex[s[right]] = right;
            maxLen = max(maxLen, right - left + 1);
        }
        
        return maxLen;
    }
};
```

这个版本使用数组代替哈希表，对于 ASCII 字符集更高效。

**复杂度分析：**
- 时间复杂度：O(n)，`right` 指针遍历整个字符串一次
- 空间复杂度：
  - 哈希表版本：O(min(n, m))，m 是字符集大小
  - 数组版本：O(m)，m = 128（ASCII）或 256（扩展ASCII）

**易错点：**
1. 左指针更新时要判断 `charIndex[c] >= left`，否则左指针可能回退
2. 窗口长度是 `right - left + 1`，不是 `right - left`
3. 注意字符串为空的情况

