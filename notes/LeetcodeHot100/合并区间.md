---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/合并区间.md
related_outlines: []
---
# 合并区间

## 题目描述

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]`。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

**示例 1：**
```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠，将它们合并为 [1,6]。
```

**示例 2：**
```
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

**提示：**
- 1 <= intervals.length <= 10^4
- intervals[i].length == 2
- 0 <= starti <= endi <= 10^4

## 思路讲解

这道题的关键是**先排序，再合并**。

### 排序 + 贪心合并

**核心思想：**
1. 先按区间起始位置排序
2. 遍历排序后的区间，尝试合并相邻区间

**为什么要排序？**
- 排序后，可能重叠的区间一定是相邻的
- 这样只需要一次遍历就能找到所有重叠区间

**如何判断两个区间是否重叠？**
假设区间 A = [a1, a2]，区间 B = [b1, b2]，且 a1 <= b1（排序后）：
- 如果 b1 <= a2，则重叠，合并为 [a1, max(a2, b2)]
- 如果 b1 > a2，则不重叠，B 是新的独立区间

**算法步骤：**
1. 按区间起始位置排序
2. 初始化结果数组，将第一个区间加入
3. 遍历剩余区间：
   - 如果当前区间与结果中最后一个区间重叠，合并它们
   - 否则，将当前区间加入结果
4. 返回结果

**示例演示：**
```
intervals = [[1,3],[2,6],[8,10],[15,18]]

排序后（已经有序）：[[1,3],[2,6],[8,10],[15,18]]

result = [[1,3]]

处理 [2,6]：2 <= 3，重叠！合并为 [1,6]
result = [[1,6]]

处理 [8,10]：8 > 6，不重叠
result = [[1,6],[8,10]]

处理 [15,18]：15 > 10，不重叠
result = [[1,6],[8,10],[15,18]]

最终结果：[[1,6],[8,10],[15,18]]
```

## 面试时的快速口述讲解

这道题要合并所有重叠的区间。

**数据结构**：数组排序 + 结果数组。

**实现方式**：
1. 先按区间起始位置排序
2. 遍历排序后的区间：
   - 如果当前区间的起始位置 <= 结果中最后一个区间的结束位置，说明重叠
   - 合并：更新最后一个区间的结束位置为两者的较大值
   - 否则，将当前区间加入结果
3. 返回合并后的区间数组

**关键点**：
- 排序保证了可能重叠的区间相邻
- 判断重叠：当前区间起始 <= 上一个区间结束
- 合并时取结束位置的最大值

**时间复杂度**：O(n log n)，主要是排序的开销。

**空间复杂度**：O(log n)，排序的递归栈空间（不计结果数组）。

## 代码实现

```cpp
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        if (intervals.empty()) return {};
        
        // 按起始位置排序
        sort(intervals.begin(), intervals.end());
        
        vector<vector<int>> result;
        result.push_back(intervals[0]);  // 加入第一个区间
        
        for (int i = 1; i < intervals.size(); i++) {
            // 如果当前区间与最后一个区间重叠
            if (intervals[i][0] <= result.back()[1]) {
                // 合并：更新结束位置为较大值
                result.back()[1] = max(result.back()[1], intervals[i][1]);
            } else {
                // 不重叠，加入新区间
                result.push_back(intervals[i]);
            }
        }
        
        return result;
    }
};
```

**代码说明：**
1. 先按区间起始位置排序（`sort` 默认按第一个元素排序）
2. 将第一个区间加入结果
3. 遍历剩余区间：
   - `intervals[i][0]` 是当前区间起始位置
   - `result.back()[1]` 是结果中最后一个区间的结束位置
   - 如果 `intervals[i][0] <= result.back()[1]`，说明重叠
   - 合并：`result.back()[1] = max(result.back()[1], intervals[i][1])`
   - 否则加入新区间
4. 返回结果

**为什么合并时要取 max？**
考虑这种情况：
```
区间1: [1, 5]
区间2: [2, 3]

区间2完全包含在区间1中
合并后应该是 [1, 5]，而不是 [1, 3]
所以要取 max(5, 3) = 5
```

**简化版本（使用引用）：**
```cpp
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        if (intervals.empty()) return {};
        
        sort(intervals.begin(), intervals.end());
        vector<vector<int>> result;
        
        for (auto& interval : intervals) {
            if (result.empty() || result.back()[1] < interval[0]) {
                // 不重叠，加入新区间
                result.push_back(interval);
            } else {
                // 重叠，合并
                result.back()[1] = max(result.back()[1], interval[1]);
            }
        }
        
        return result;
    }
};
```

这个版本将第一个区间的处理也放在循环中，代码更简洁。

**复杂度分析：**
- 时间复杂度：O(n log n)
  - 排序：O(n log n)
  - 遍历：O(n)
- 空间复杂度：O(log n)
  - 排序的递归栈空间
  - 结果数组不计入空间复杂度

**易错点：**
1. 不要忘记排序
2. 判断重叠的条件：`intervals[i][0] <= result.back()[1]`（注意等号）
3. 合并时要用 `max`，不能直接赋值
4. 注意边界情况：空数组、单个区间

**扩展：如果区间是 [start, end) 左闭右开？**
判断重叠的条件改为：`intervals[i][0] < result.back()[1]`（去掉等号）

**相关问题：**
- 插入区间
- 区间列表的交集
- 无重叠区间（贪心）


---

## 相关笔记
<!-- 自动生成 -->

暂无相关笔记

