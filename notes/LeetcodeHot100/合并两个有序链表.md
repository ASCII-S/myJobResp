---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/合并两个有序链表.md
related_outlines: []
---
# 合并两个有序链表

## 题目描述

将两个升序链表合并为一个新的**升序**链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例 1：**
```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**示例 2：**
```
输入：l1 = [], l2 = []
输出：[]
```

**示例 3：**
```
输入：l1 = [], l2 = [0]
输出：[0]
```

**提示：**
- 两个链表的节点数目范围是 [0, 50]
- -100 <= Node.val <= 100
- l1 和 l2 均按**非递减顺序**排列

## 思路讲解

合并两个有序链表是归并排序中合并操作的链表版本，是非常基础但重要的链表操作。

### 方法一：迭代（推荐）

**核心思路：**
使用双指针，每次选择两个链表中较小的节点添加到结果链表中。

**关键技巧：使用虚拟头节点（dummy node）**
- 虚拟头节点可以简化边界情况的处理
- 不需要特殊处理第一个节点
- 最后返回 dummy->next 即为真正的头节点

**步骤：**
1. 创建虚拟头节点 dummy 和指针 curr
2. 比较两个链表的当前节点，选择较小的加入结果链表
3. 移动对应链表的指针
4. 处理剩余节点（一个链表遍历完后，直接连接另一个链表的剩余部分）
5. 返回 dummy->next

### 方法二：递归

**核心思路：**
递归地选择较小的节点，将问题规模缩小。

**递归定义：**
- 如果 l1 为空，返回 l2
- 如果 l2 为空，返回 l1
- 如果 l1->val < l2->val，则 l1->next = merge(l1->next, l2)，返回 l1
- 否则 l2->next = merge(l1, l2->next)，返回 l2

**递归终止条件：**
其中一个链表为空。

## 面试时的快速口述讲解

这道题要求合并两个升序链表，保持结果链表也是升序的。

**数据结构**：使用虚拟头节点和双指针进行迭代合并。

**实现方式（迭代法）**：
1. 创建虚拟头节点 dummy，用指针 curr 指向当前位置
2. 使用两个指针分别遍历两个链表
3. 每次比较两个指针指向的节点值，选择较小的节点连接到结果链表
4. 移动被选择节点所在链表的指针
5. 当一个链表遍历完后，直接将另一个链表的剩余部分连接到结果链表
6. 返回 dummy->next 作为新链表的头节点

**时间复杂度**：O(m + n)，其中 m 和 n 分别是两个链表的长度，需要遍历所有节点。

**空间复杂度**：O(1)，只使用了几个指针变量。递归方法的空间复杂度为 O(m + n)，因为递归调用栈的深度。

## 代码实现

### 方法一：迭代（推荐）

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        // 创建虚拟头节点，简化边界情况处理
        ListNode* dummy = new ListNode(0);
        ListNode* curr = dummy;
        
        // 当两个链表都不为空时，比较并选择较小的节点
        while (l1 != nullptr && l2 != nullptr) {
            if (l1->val <= l2->val) {
                curr->next = l1;  // 选择 l1 的节点
                l1 = l1->next;    // l1 指针后移
            } else {
                curr->next = l2;  // 选择 l2 的节点
                l2 = l2->next;    // l2 指针后移
            }
            curr = curr->next;    // curr 指针后移
        }
        
        // 处理剩余节点
        // 如果 l1 还有剩余，直接连接；否则连接 l2 的剩余部分
        curr->next = (l1 != nullptr) ? l1 : l2;
        
        // 返回真正的头节点（跳过虚拟头节点）
        ListNode* result = dummy->next;
        delete dummy;  // 释放虚拟头节点内存
        return result;
    }
};
```

**代码说明：**
1. **虚拟头节点**：
   - 创建 `dummy` 节点，值任意（通常为 0）
   - `curr` 指针用于构建结果链表
   - 避免了特殊处理第一个节点的情况

2. **合并过程**：
   - 比较两个链表当前节点的值
   - 选择较小的节点连接到结果链表
   - 移动对应链表的指针和 curr 指针

3. **处理剩余节点**：
   - 循环结束后，至少有一个链表已遍历完
   - 直接将未遍历完的链表连接到结果链表末尾
   - 因为原链表已有序，剩余部分可以直接使用

4. **返回结果**：
   - 返回 `dummy->next`，跳过虚拟头节点
   - 可以选择释放 dummy 节点的内存

**图解过程：**
```
l1: 1 -> 2 -> 4
l2: 1 -> 3 -> 4

初始：
dummy -> null
curr

步骤1：比较 1 和 1，选择 l1 的 1
dummy -> 1
         ↑
        curr
l1: 2 -> 4

步骤2：比较 2 和 1，选择 l2 的 1
dummy -> 1 -> 1
              ↑
            curr
l2: 3 -> 4

步骤3：比较 2 和 3，选择 l1 的 2
dummy -> 1 -> 1 -> 2
                   ↑
                 curr
l1: 4

步骤4：比较 4 和 3，选择 l2 的 3
dummy -> 1 -> 1 -> 2 -> 3
                        ↑
                      curr
l2: 4

步骤5：比较 4 和 4，选择 l1 的 4
dummy -> 1 -> 1 -> 2 -> 3 -> 4
                             ↑
                           curr
l1: null

步骤6：l1 为空，直接连接 l2 的剩余部分
dummy -> 1 -> 1 -> 2 -> 3 -> 4 -> 4

返回 dummy->next
```

### 方法二：递归

```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        // 递归终止条件：如果一个链表为空，返回另一个链表
        if (l1 == nullptr) {
            return l2;
        }
        if (l2 == nullptr) {
            return l1;
        }
        
        // 选择较小的节点，递归合并剩余部分
        if (l1->val <= l2->val) {
            l1->next = mergeTwoLists(l1->next, l2);
            return l1;
        } else {
            l2->next = mergeTwoLists(l1, l2->next);
            return l2;
        }
    }
};
```

**递归过程图解（l1 = [1,2,4], l2 = [1,3,4]）：**
```
mergeTwoLists([1,2,4], [1,3,4])
  ├─ 1 <= 1，选择 l1 的 1
  └─ 1->next = mergeTwoLists([2,4], [1,3,4])
       ├─ 2 > 1，选择 l2 的 1
       └─ 1->next = mergeTwoLists([2,4], [3,4])
            ├─ 2 < 3，选择 l1 的 2
            └─ 2->next = mergeTwoLists([4], [3,4])
                 ├─ 4 > 3，选择 l2 的 3
                 └─ 3->next = mergeTwoLists([4], [4])
                      ├─ 4 <= 4，选择 l1 的 4
                      └─ 4->next = mergeTwoLists([], [4])
                           └─ 返回 [4]

最终结果：1 -> 1 -> 2 -> 3 -> 4 -> 4
```

**复杂度对比：**
- 方法一（迭代）：时间 O(m+n)，空间 O(1)，推荐
- 方法二（递归）：时间 O(m+n)，空间 O(m+n)，代码简洁

**面试技巧：**
- 优先使用迭代法，强调虚拟头节点的作用
- 递归法代码更简洁，但空间复杂度较高
- 注意边界情况：空链表的处理


---

## 相关笔记
<!-- 自动生成 -->

- [删除链表的倒数第N个结点](notes/LeetcodeHot100/删除链表的倒数第N个结点.md) - 相似度: 36% | 标签: LeetcodeHot100, LeetcodeHot100/删除链表的倒数第N个结点.md
- [两两交换链表中的节点](notes/LeetcodeHot100/两两交换链表中的节点.md) - 相似度: 36% | 标签: LeetcodeHot100, LeetcodeHot100/两两交换链表中的节点.md
- [反转链表](notes/LeetcodeHot100/反转链表.md) - 相似度: 33% | 标签: LeetcodeHot100, LeetcodeHot100/反转链表.md
- [两数相加](notes/LeetcodeHot100/两数相加.md) - 相似度: 31% | 标签: LeetcodeHot100, LeetcodeHot100/两数相加.md

