---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/两数相加.md
related_outlines: []
---
# 两数相加

## 题目描述

给你两个**非空**的链表，表示两个非负的整数。它们每位数字都是按照**逆序**的方式存储的，并且每个节点只能存储**一位**数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例 1：**
```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807
```

**示例 2：**
```
输入：l1 = [0], l2 = [0]
输出：[0]
```

**示例 3：**
```
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
解释：9999999 + 9999 = 10009998
```

**提示：**
- 每个链表中的节点数在范围 [1, 100] 内
- 0 <= Node.val <= 9
- 题目数据保证列表表示的数字不含前导零

## 思路讲解

这道题模拟了两个大整数的加法运算，使用链表来表示数字。

### 核心思路

**关键理解：**
- 链表是逆序存储的，即个位在链表头部，这正好符合加法运算的顺序（从低位到高位）
- 需要处理进位（carry）
- 两个链表长度可能不同
- 最后可能需要额外的进位节点

**算法步骤：**
1. 创建虚拟头节点，用于简化操作
2. 同时遍历两个链表，逐位相加
3. 每次相加需要考虑：l1 当前位、l2 当前位、进位 carry
4. 计算和：sum = l1->val + l2->val + carry
5. 创建新节点：val = sum % 10
6. 更新进位：carry = sum / 10
7. 处理链表长度不同的情况
8. 最后如果还有进位，需要创建额外节点

**关键点：**
- 使用虚拟头节点简化边界处理
- 用 carry 变量记录进位
- 循环条件要考虑三种情况：l1 不空、l2 不空、有进位
- 注意最后的进位处理

## 面试时的快速口述讲解

这道题要求将两个用链表表示的数字相加，链表是逆序存储的，即个位在前。

**数据结构**：使用虚拟头节点构建结果链表，用一个变量记录进位。

**实现方式**：
1. 创建虚拟头节点和当前指针 curr
2. 初始化进位 carry = 0
3. 同时遍历两个链表，直到两个链表都遍历完且没有进位：
   - 获取两个链表当前位的值（如果已遍历完则为0）
   - 计算和：sum = val1 + val2 + carry
   - 创建新节点，值为 sum % 10
   - 更新进位：carry = sum / 10
   - 移动指针
4. 返回 dummy->next

**时间复杂度**：O(max(m, n))，其中 m 和 n 是两个链表的长度，需要遍历较长的链表。

**空间复杂度**：O(max(m, n))，结果链表的长度最多为 max(m, n) + 1。

## 代码实现

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        // 创建虚拟头节点
        ListNode* dummy = new ListNode(0);
        ListNode* curr = dummy;
        
        // 进位初始化为0
        int carry = 0;
        
        // 当l1、l2或carry任一不为空/0时，继续循环
        while (l1 != nullptr || l2 != nullptr || carry != 0) {
            // 获取当前位的值（如果链表已遍历完，则为0）
            int val1 = (l1 != nullptr) ? l1->val : 0;
            int val2 = (l2 != nullptr) ? l2->val : 0;
            
            // 计算当前位的和
            int sum = val1 + val2 + carry;
            
            // 创建新节点，值为sum的个位
            curr->next = new ListNode(sum % 10);
            curr = curr->next;
            
            // 更新进位
            carry = sum / 10;
            
            // 移动链表指针
            if (l1 != nullptr) l1 = l1->next;
            if (l2 != nullptr) l2 = l2->next;
        }
        
        // 返回结果链表（跳过虚拟头节点）
        return dummy->next;
    }
};
```

**代码说明：**

1. **虚拟头节点**：
   - 简化边界情况，不需要特殊处理第一个节点
   - 最后返回 `dummy->next`

2. **循环条件**：`l1 != nullptr || l2 != nullptr || carry != 0`
   - l1 或 l2 还有数字未处理
   - 或者还有进位需要处理

3. **获取当前位的值**：
   - 如果链表已遍历完（nullptr），则当前位为 0
   - 使用三元运算符简化代码

4. **计算和**：
   - `sum = val1 + val2 + carry`
   - 包含三部分：l1当前位、l2当前位、上一位的进位

5. **创建新节点**：
   - 节点值为 `sum % 10`（sum 的个位）
   - `sum / 10` 作为新的进位

6. **移动指针**：
   - 在移动前要检查指针是否为空
   - 避免空指针异常

**图解过程（示例：342 + 465 = 807）：**
```
l1: 2 -> 4 -> 3
l2: 5 -> 6 -> 4

步骤1：carry=0
2 + 5 + 0 = 7
创建节点：7
carry = 0

步骤2：carry=0
4 + 6 + 0 = 10
创建节点：0
carry = 1

步骤3：carry=1
3 + 4 + 1 = 8
创建节点：8
carry = 0

结果：7 -> 0 -> 8
```

**边界情况处理：**

```cpp
// 示例：9999999 + 9999 = 10009998
// l1: [9,9,9,9,9,9,9]
// l2: [9,9,9,9]

// 前4位：9+9=18，创建8，进位1
// 第5-7位（l2已完）：9+0+1=10，创建0，进位1
// 第8位（l1也完了，但carry=1）：0+0+1=1，创建1

// 结果：[8,9,9,9,0,0,0,1]
```

**优化写法（更简洁）：**

```cpp
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* dummy = new ListNode(0);
        ListNode* curr = dummy;
        int carry = 0;
        
        while (l1 || l2 || carry) {
            int sum = carry;
            if (l1) {
                sum += l1->val;
                l1 = l1->next;
            }
            if (l2) {
                sum += l2->val;
                l2 = l2->next;
            }
            
            curr->next = new ListNode(sum % 10);
            curr = curr->next;
            carry = sum / 10;
        }
        
        return dummy->next;
    }
};
```

**面试技巧：**
- 强调链表逆序存储的优势（符合加法运算顺序）
- 重点说明进位的处理
- 注意循环条件要包含三种情况
- 可以提到这是大数加法的链表实现


---

## 相关笔记
<!-- 自动生成 -->

- [合并两个有序链表](notes/LeetcodeHot100/合并两个有序链表.md) - 相似度: 31% | 标签: LeetcodeHot100, LeetcodeHot100/合并两个有序链表.md

