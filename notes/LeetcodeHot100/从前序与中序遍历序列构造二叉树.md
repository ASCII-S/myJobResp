---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/从前序与中序遍历序列构造二叉树.md
related_outlines: []
---
# 从前序与中序遍历序列构造二叉树

## 题目描述

给定两个整数数组 `preorder` 和 `inorder`，其中 `preorder` 是二叉树的**前序遍历**，`inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

**示例 1：**
```
输入：preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出：[3,9,20,null,null,15,7]
```

**示例 2：**
```
输入：preorder = [-1], inorder = [-1]
输出：[-1]
```

**提示：**
- 1 <= preorder.length <= 3000
- inorder.length == preorder.length
- -3000 <= preorder[i], inorder[i] <= 3000
- `preorder` 和 `inorder` 均**无重复**元素
- `inorder` 均出现在 `preorder`
- `preorder` **保证**为二叉树的前序遍历序列
- `inorder` **保证**为二叉树的中序遍历序列

## 思路讲解

这是一道经典的树的重建问题，需要理解前序和中序遍历的特点。

### 遍历顺序回顾

- **前序遍历**：根 -> 左 -> 右
- **中序遍历**：左 -> 根 -> 右

### 核心思想

1. **前序遍历的第一个元素**是根节点
2. **在中序遍历中找到根节点**，它左边的都是左子树，右边的都是右子树
3. **递归构建**：
   - 根据左子树的大小，在前序遍历中划分出左右子树的范围
   - 递归构建左子树和右子树

### 解题步骤

1. 从前序遍历中取出根节点（第一个元素）
2. 在中序遍历中找到根节点的位置
3. 根据根节点在中序遍历中的位置，划分左右子树：
   - 中序遍历：`[左子树] 根 [右子树]`
   - 前序遍历：`根 [左子树] [右子树]`
4. 递归构建左右子树

### 关键点

- **索引计算**：根据中序遍历中根节点的位置，计算左子树的大小
- **哈希表优化**：使用哈希表存储中序遍历中每个值的索引，快速定位根节点
- **递归边界**：注意左右边界的计算，避免越界

## 面试时的快速口述讲解

这道题要求根据前序和中序遍历序列重建二叉树。

**数据结构**：
- 哈希表：存储中序遍历中每个值的索引
- 递归：构建树

**实现方式**：
1. 前序遍历的第一个元素是根节点
2. 在中序遍历中找到根节点的位置，将序列分为左右两部分
3. 根据左子树的大小，在前序遍历中也划分出左右子树
4. 递归地对左右子树执行相同操作
5. 使用哈希表优化中序遍历中根节点位置的查找

**时间复杂度**：O(n)，每个节点访问一次，使用哈希表查找位置为 O(1)。

**空间复杂度**：O(n)，哈希表存储 n 个元素，递归调用栈深度为 O(h)。

## 代码实现

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        // 构建哈希表：中序遍历值 -> 索引
        unordered_map<int, int> inorderMap;
        for (int i = 0; i < inorder.size(); i++) {
            inorderMap[inorder[i]] = i;
        }
        
        return build(preorder, 0, preorder.size() - 1,
                     inorder, 0, inorder.size() - 1,
                     inorderMap);
    }
    
private:
    TreeNode* build(vector<int>& preorder, int preStart, int preEnd,
                    vector<int>& inorder, int inStart, int inEnd,
                    unordered_map<int, int>& inorderMap) {
        // 递归终止条件：区间为空
        if (preStart > preEnd || inStart > inEnd) {
            return nullptr;
        }
        
        // 前序遍历的第一个元素是根节点
        int rootVal = preorder[preStart];
        TreeNode* root = new TreeNode(rootVal);
        
        // 在中序遍历中找到根节点的位置
        int rootIndexInInorder = inorderMap[rootVal];
        
        // 计算左子树的大小
        int leftSubtreeSize = rootIndexInInorder - inStart;
        
        // 递归构建左子树
        // 前序：[preStart+1, preStart+leftSubtreeSize]
        // 中序：[inStart, rootIndexInInorder-1]
        root->left = build(preorder, preStart + 1, preStart + leftSubtreeSize,
                          inorder, inStart, rootIndexInInorder - 1,
                          inorderMap);
        
        // 递归构建右子树
        // 前序：[preStart+leftSubtreeSize+1, preEnd]
        // 中序：[rootIndexInInorder+1, inEnd]
        root->right = build(preorder, preStart + leftSubtreeSize + 1, preEnd,
                           inorder, rootIndexInInorder + 1, inEnd,
                           inorderMap);
        
        return root;
    }
};
```

**代码说明：**

1. **主函数 `buildTree`**：
   - 构建哈希表 `inorderMap`，存储中序遍历中每个值的索引
   - 调用递归函数 `build`，初始范围为整个数组

2. **递归函数 `build`**：
   - **参数**：
     - 前序遍历数组及当前范围 `[preStart, preEnd]`
     - 中序遍历数组及当前范围 `[inStart, inEnd]`
     - 哈希表 `inorderMap`
   
   - **递归终止条件**：区间为空（`preStart > preEnd` 或 `inStart > inEnd`）
   
   - **递归逻辑**：
     - 取前序遍历的第一个元素作为根节点
     - 在中序遍历中找到根节点的位置（使用哈希表，O(1) 时间）
     - 计算左子树的大小：`leftSubtreeSize = rootIndexInInorder - inStart`
     - 递归构建左子树和右子树

3. **索引计算**：
   - **左子树在前序遍历中的范围**：`[preStart+1, preStart+leftSubtreeSize]`
     - 跳过根节点（preStart），取接下来 leftSubtreeSize 个元素
   - **左子树在中序遍历中的范围**：`[inStart, rootIndexInInorder-1]`
     - 根节点左边的所有元素
   - **右子树在前序遍历中的范围**：`[preStart+leftSubtreeSize+1, preEnd]`
     - 跳过根节点和左子树的所有元素
   - **右子树在中序遍历中的范围**：`[rootIndexInInorder+1, inEnd]`
     - 根节点右边的所有元素

**执行过程示例**（以 preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] 为例）：

```
步骤1：构建根节点
  preorder[0] = 3 是根节点
  在 inorder 中找到 3 的位置：index = 1
  左子树大小 = 1 - 0 = 1
  左子树：preorder[1,1]=[9], inorder[0,0]=[9]
  右子树：preorder[2,4]=[20,15,7], inorder[2,4]=[15,20,7]

步骤2：构建左子树（节点9）
  preorder[1] = 9 是根节点
  在 inorder 中找到 9 的位置：index = 0
  左子树大小 = 0
  没有左右子树，返回节点9

步骤3：构建右子树（根节点20）
  preorder[2] = 20 是根节点
  在 inorder 中找到 20 的位置：index = 3
  左子树大小 = 3 - 2 = 1
  左子树：preorder[3,3]=[15], inorder[2,2]=[15]
  右子树：preorder[4,4]=[7], inorder[4,4]=[7]

步骤4：构建节点15和节点7
  类似地构建叶子节点

最终树：
    3
   / \
  9  20
     / \
    15  7
```

**为什么需要哈希表？**
- 每次需要在中序遍历中查找根节点的位置
- 如果使用线性查找，时间复杂度为 O(n)，总体复杂度为 O(n²)
- 使用哈希表预处理，查找时间为 O(1)，总体复杂度为 O(n)

**注意事项：**
- 题目保证数组无重复元素，可以安全使用哈希表
- 索引计算是关键，需要仔细推导
- 前序和中序遍历的组合可以唯一确定一棵二叉树
- 后序和中序遍历的组合也可以，但前序和后序遍历不能唯一确定（缺少根节点的位置信息）

**相关问题：**
- 从中序与后序遍历序列构造二叉树（类似思路）
- 从前序与后序遍历序列构造二叉树（需要额外条件）


---

## 相关笔记
<!-- 自动生成 -->

- [将有序数组转换为二叉搜索树](notes/LeetcodeHot100/将有序数组转换为二叉搜索树.md) - 相似度: 33% | 标签: LeetcodeHot100, LeetcodeHot100/将有序数组转换为二叉搜索树.md

