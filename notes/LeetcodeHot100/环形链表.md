---
created: '2025-10-19'
last_reviewed: '2025-10-19'
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/环形链表.md
related_outlines: []
---

# 环形链表

## 题目描述

给你一个链表的头节点 `head`，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递**。仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回 `true`。否则，返回 `false`。

**示例 1：**
```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**
```
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**
```
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```

**提示：**
- 链表中节点的数目范围是 [0, 10^4]
- -10^5 <= Node.val <= 10^5
- pos 为 -1 或者链表中的一个有效索引

**进阶：** 你能用 O(1)（即常量）内存解决此问题吗？

## 思路讲解

判断链表是否有环是一道经典的快慢指针问题，也被称为"Floyd 判圈算法"或"龟兔赛跑算法"。

### 方法一：哈希表

**核心思路：**
遍历链表，用哈希表记录访问过的节点。如果遇到已访问过的节点，说明有环。

**步骤：**
1. 遍历链表，将每个节点指针存入哈希表
2. 如果当前节点已在哈希表中，说明有环
3. 如果遍历到 nullptr，说明无环

**复杂度：**
- 时间复杂度：O(n)
- 空间复杂度：O(n)

### 方法二：快慢指针（Floyd 判圈算法，最优解）

这是最经典的解法，使用两个速度不同的指针。

**核心思路：**
使用快慢两个指针，快指针每次走两步，慢指针每次走一步。如果链表有环，快指针最终会追上慢指针；如果无环，快指针会先到达末尾。

**为什么快慢指针一定会相遇？**
- 可以想象在一个环形跑道上，快的人总会追上慢的人
- 数学证明：假设慢指针进入环时，快指针在环中某位置
- 每次移动，快指针与慢指针的距离减少1
- 最终距离会减少到0，即相遇

**关键点：**
- 快指针每次走2步，慢指针每次走1步
- 如果有环，快指针会在环内追上慢指针
- 如果无环，快指针会先到达 nullptr
- 时间复杂度：O(n)，空间复杂度：O(1)

**为什么快指针走2步而不是3步、4步？**
- 走2步是最优的，可以保证一定相遇
- 走更多步可能会跳过慢指针，导致需要多圈才能相遇
- 走2步每次缩小距离1，效率最高

## 面试时的快速口述讲解

这道题要求判断链表是否有环，使用快慢指针是最优解。

**数据结构**：使用两个指针，一个快指针，一个慢指针。

**实现方式（Floyd 判圈算法）**：
1. 初始化快慢指针都指向头节点
2. 慢指针每次走一步，快指针每次走两步
3. 如果链表有环，快指针最终会在环内追上慢指针，两指针相遇
4. 如果链表无环，快指针会先到达链表末尾（nullptr）
5. 判断条件：快慢指针相遇则有环，快指针到达 nullptr 则无环

**时间复杂度**：O(n)，最多遍历链表一次。如果有环，快指针在环内最多走一圈就能追上慢指针。

**空间复杂度**：O(1)，只使用了两个指针变量。

## 代码实现

### 方法一：快慢指针（Floyd 判圈算法，推荐）

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        // 边界情况：空链表或只有一个节点
        if (head == nullptr || head->next == nullptr) {
            return false;
        }
        
        // 初始化快慢指针
        ListNode* slow = head;
        ListNode* fast = head;
        
        // 快指针每次走两步，慢指针每次走一步
        while (fast != nullptr && fast->next != nullptr) {
            slow = slow->next;       // 慢指针走一步
            fast = fast->next->next; // 快指针走两步
            
            // 如果快慢指针相遇，说明有环
            if (slow == fast) {
                return true;
            }
        }
        
        // 快指针到达末尾，说明无环
        return false;
    }
};
```

**代码说明：**
1. **边界处理**：空链表或单节点链表不可能有环
2. **初始化**：快慢指针都从头节点开始
3. **循环条件**：`fast != nullptr && fast->next != nullptr`
   - 需要同时检查 fast 和 fast->next，因为 fast 每次走两步
   - 如果 fast->next 是 nullptr，fast->next->next 会出错
4. **移动指针**：
   - slow 每次移动一步
   - fast 每次移动两步
5. **判断相遇**：
   - 如果 slow == fast，说明相遇，有环
   - 如果循环结束（fast 到达 nullptr），说明无环

**图解过程：**
```
有环的情况：
初始：  1 -> 2 -> 3 -> 4
             ↑         ↓
             6 <- 5 <--

步骤：
第1步：slow=2, fast=3
第2步：slow=3, fast=5
第3步：slow=4, fast=2
第4步：slow=5, fast=4
第5步：slow=6, fast=6  相遇！返回 true

无环的情况：
1 -> 2 -> 3 -> 4 -> null

步骤：
第1步：slow=2, fast=3
第2步：slow=3, fast=null  fast到达末尾，返回 false
```

### 方法二：哈希表

```cpp
class Solution {
public:
    bool hasCycle(ListNode *head) {
        unordered_set<ListNode*> visited;
        ListNode* curr = head;
        
        while (curr != nullptr) {
            // 如果当前节点已访问过，说明有环
            if (visited.count(curr)) {
                return true;
            }
            // 记录当前节点
            visited.insert(curr);
            curr = curr->next;
        }
        
        // 遍历结束，说明无环
        return false;
    }
};
```

**代码说明：**
1. 使用哈希表存储访问过的节点指针（不是节点值！）
2. 遍历链表，检查当前节点是否已访问
3. 如果已访问，说明形成了环
4. 如果遍历到 nullptr，说明无环

**复杂度对比：**
- 方法一（快慢指针）：时间 O(n)，空间 O(1)，最优解
- 方法二（哈希表）：时间 O(n)，空间 O(n)，直观简单

**面试技巧：**
- 优先说快慢指针解法，体现算法能力
- 可以补充哈希表解法作为对比
- 强调空间复杂度的差异


---

## 相关笔记
<!-- 自动生成 -->

- [环形链表II](notes/LeetcodeHot100/环形链表II.md) - 相似度: 42% | 标签: LeetcodeHot100, LeetcodeHot100/环形链表II.md
- [相交链表](notes/LeetcodeHot100/相交链表.md) - 相似度: 31% | 标签: LeetcodeHot100, LeetcodeHot100/相交链表.md
- [删除链表的倒数第N个结点](notes/LeetcodeHot100/删除链表的倒数第N个结点.md) - 相似度: 31% | 标签: LeetcodeHot100, LeetcodeHot100/删除链表的倒数第N个结点.md

