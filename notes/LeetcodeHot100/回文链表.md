---
created: '2025-10-19'
last_reviewed: '2025-10-19'
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- LeetcodeHot100
- LeetcodeHot100/回文链表.md
related_outlines: []
---

# 回文链表

## 题目描述

给你一个单链表的头节点 `head`，请你判断该链表是否为回文链表。如果是，返回 `true`；否则，返回 `false`。

**示例 1：**
```
输入：head = [1,2,2,1]
输出：true
```

**示例 2：**
```
输入：head = [1,2]
输出：false
```

**提示：**
- 链表中节点数目在范围 [1, 10^5] 内
- 0 <= Node.val <= 9

**进阶：** 你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？

## 思路讲解

判断链表是否为回文是一道经典的链表操作综合题，需要结合多种技巧。

### 方法一：数组辅助（简单直观）

**核心思路：**
将链表值复制到数组中，然后使用双指针判断数组是否回文。

**步骤：**
1. 遍历链表，将所有节点值存入数组
2. 使用双指针从数组两端向中间比较

**复杂度：**
- 时间复杂度：O(n)
- 空间复杂度：O(n)

### 方法二：快慢指针 + 反转链表（最优解）

这是满足进阶要求的解法，空间复杂度为 O(1)。

**核心思路：**
1. 使用快慢指针找到链表中点
2. 反转后半部分链表
3. 比较前半部分和反转后的后半部分
4. （可选）恢复链表原始结构

**关键点：**
- 快指针每次走两步，慢指针每次走一步
- 当快指针到达末尾时，慢指针正好在中点
- 奇数长度：慢指针在正中间；偶数长度：慢指针在中间偏右
- 反转后半部分，然后从两端向中间比较

**步骤详解：**
```
原链表：1 -> 2 -> 3 -> 2 -> 1

第1步：找中点
slow = 3, fast = null

第2步：反转后半部分
前半部分：1 -> 2 -> 3
后半部分：1 -> 2 (反转后)

第3步：比较
p1: 1 -> 2 -> 3
p2: 1 -> 2
比较结果：1==1, 2==2，是回文
```

## 面试时的快速口述讲解

这道题要求判断单链表是否为回文结构，即从前往后和从后往前读是一样的。

**数据结构**：使用快慢指针找中点，然后反转后半部分链表进行比较。

**实现方式（O(1) 空间）**：
1. 使用快慢指针找到链表中点，慢指针最终停在中点或中间偏右的位置
2. 反转慢指针之后的链表（后半部分）
3. 用两个指针分别从头和反转后的后半部分开始，逐一比较节点值
4. 如果所有值都相等，则是回文链表
5. （可选）恢复链表结构

**时间复杂度**：O(n)，需要遍历链表找中点、反转后半部分、比较，每个操作都是 O(n)。

**空间复杂度**：O(1)，只使用了几个指针变量。如果使用数组辅助，空间复杂度为 O(n)。

## 代码实现

### 方法一：快慢指针 + 反转链表（O(1) 空间，推荐）

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if (head == nullptr || head->next == nullptr) {
            return true;
        }
        
        // 第1步：使用快慢指针找到链表中点
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast->next != nullptr && fast->next->next != nullptr) {
            slow = slow->next;
            fast = fast->next->next;
        }
        
        // slow 现在指向中点（奇数）或中间偏左（偶数）
        // 反转 slow 之后的链表
        ListNode* secondHalf = reverseList(slow->next);
        
        // 第2步：比较前半部分和反转后的后半部分
        ListNode* p1 = head;
        ListNode* p2 = secondHalf;
        bool result = true;
        
        while (p2 != nullptr) {  // 后半部分较短或相等，所以用 p2 判断
            if (p1->val != p2->val) {
                result = false;
                break;
            }
            p1 = p1->next;
            p2 = p2->next;
        }
        
        // 第3步（可选）：恢复链表原始结构
        slow->next = reverseList(secondHalf);
        
        return result;
    }
    
private:
    // 反转链表的辅助函数
    ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr;
        ListNode* curr = head;
        
        while (curr != nullptr) {
            ListNode* next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
        }
        
        return prev;
    }
};
```

**代码说明：**
1. **找中点**：
   - 快指针走两步，慢指针走一步
   - 循环条件是 `fast->next != nullptr && fast->next->next != nullptr`
   - 循环结束后，slow 指向中点或中间偏左位置

2. **反转后半部分**：
   - 反转 `slow->next` 开始的链表
   - 返回反转后的新头节点

3. **比较**：
   - p1 从头开始，p2 从反转后的后半部分开始
   - 逐一比较节点值
   - 只需比较到后半部分结束（p2 == nullptr）

4. **恢复链表**（可选）：
   - 再次反转后半部分，恢复原始结构

### 方法二：数组辅助（简单直观）

```cpp
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        // 将链表值复制到数组
        vector<int> vals;
        ListNode* curr = head;
        while (curr != nullptr) {
            vals.push_back(curr->val);
            curr = curr->next;
        }
        
        // 双指针判断数组是否回文
        int left = 0;
        int right = vals.size() - 1;
        
        while (left < right) {
            if (vals[left] != vals[right]) {
                return false;
            }
            left++;
            right--;
        }
        
        return true;
    }
};
```

**代码说明：**
1. 第一次遍历：将所有节点值存入数组
2. 使用双指针从数组两端向中间比较
3. 如果发现不相等的元素，返回 false
4. 所有元素都相等，返回 true

**复杂度对比：**
- 方法一：时间 O(n)，空间 O(1)，代码复杂，面试亮点
- 方法二：时间 O(n)，空间 O(n)，代码简单，容易实现

**图解过程（以 1->2->3->2->1 为例）：**
```
原链表：1 -> 2 -> 3 -> 2 -> 1

找中点后：
slow 指向 3

反转后半部分：
前半部分：1 -> 2 -> 3
后半部分：1 -> 2 (原来是 2 -> 1，反转后是 1 -> 2)

比较：
p1: 1 -> 2 -> 3
p2: 1 -> 2
    ↓    ↓
   1==1 2==2
   
结果：true
```

