# 二叉树的右视图

## 题目描述

给定一个二叉树的**根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

**示例 1：**
```
输入：root = [1,2,3,null,5,null,4]
输出：[1,3,4]
```

**示例 2：**
```
输入：root = [1,null,3]
输出：[1,3]
```

**示例 3：**
```
输入：root = []
输出：[]
```

**提示：**
- 二叉树的节点个数的范围是 [0, 100]
- -100 <= Node.val <= 100

## 思路讲解

"右视图"即从右边看树，每层只能看到最右边的节点。

### 核心思想

每一层最右边的节点就是右视图中的节点。

### 方法一：层序遍历（BFS）

最直观的方法：
1. 使用队列进行层序遍历
2. 对于每一层，记录最后一个节点（最右边的节点）
3. 将这些节点的值加入结果

### 方法二：深度优先搜索（DFS）

另一种巧妙的方法：
1. 按照"根-右-左"的顺序遍历（先访问右子树）
2. 使用一个变量记录当前的深度
3. 对于每个深度，第一次访问到的节点就是该层最右边的节点
4. 如果 `depth == result.size()`，说明是该层第一次被访问，加入结果

### 关键点

- **BFS 方法**：直接模拟"从右边看"的过程，每层取最右节点
- **DFS 方法**：利用"根-右-左"的遍历顺序，每层第一个访问的就是最右节点
- **深度的概念**：用于判断是否进入了新的一层

## 面试时的快速口述讲解

这道题要求返回二叉树的右视图，即从右边看树时每层能看到的最右边的节点。

**数据结构**：
- BFS：使用队列进行层序遍历
- DFS：使用递归调用栈

**实现方式**：
- **方法一（BFS）**：层序遍历树，对于每一层，记录最后一个节点的值（最右边的节点）
- **方法二（DFS）**：按照"根-右-左"的顺序遍历，维护当前深度，每个深度第一次访问的节点就是该层最右边的节点

**时间复杂度**：O(n)，需要访问所有节点。

**空间复杂度**：
- BFS：O(w)，w 是树的最大宽度（队列中的节点数）
- DFS：O(h)，h 是树的高度（递归调用栈深度）

## 代码实现

### 方法一：层序遍历（BFS）

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> result;
        
        if (root == nullptr) {
            return result;
        }
        
        queue<TreeNode*> q;
        q.push(root);
        
        while (!q.empty()) {
            int levelSize = q.size();
            
            // 遍历当前层的所有节点
            for (int i = 0; i < levelSize; i++) {
                TreeNode* node = q.front();
                q.pop();
                
                // 如果是当前层的最后一个节点，加入结果
                if (i == levelSize - 1) {
                    result.push_back(node->val);
                }
                
                // 将子节点加入队列
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
        }
        
        return result;
    }
};
```

### 方法二：深度优先搜索（DFS）

```cpp
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> result;
        dfs(root, 0, result);
        return result;
    }
    
private:
    void dfs(TreeNode* node, int depth, vector<int>& result) {
        if (node == nullptr) {
            return;
        }
        
        // 如果当前深度等于结果数组的大小，说明这是该层第一次被访问
        // 由于我们先访问右子树，所以第一次访问的就是最右边的节点
        if (depth == result.size()) {
            result.push_back(node->val);
        }
        
        // 先右后左的顺序遍历（重要！）
        dfs(node->right, depth + 1, result);
        dfs(node->left, depth + 1, result);
    }
};
```

**代码说明：**

**方法一（BFS）：**
1. 使用队列进行层序遍历
2. 对于每一层：
   - 记录当前层的节点数 `levelSize`
   - 遍历当前层的所有节点
   - 当 `i == levelSize - 1` 时，说明是该层最后一个节点（最右边），加入结果
3. 将子节点按从左到右的顺序加入队列

**方法二（DFS）：**
1. 使用 DFS，同时记录当前节点的深度
2. **关键判断**：`if (depth == result.size())`
   - `result.size()` 表示已经记录了几层的结果
   - 当 `depth == result.size()` 时，说明这是新的一层，第一次被访问
3. **遍历顺序**：先右后左（重要！）
   - 先递归右子树：`dfs(node->right, depth + 1, result)`
   - 再递归左子树：`dfs(node->left, depth + 1, result)`
4. 由于先访问右子树，所以对于每一层，第一个被访问的节点就是最右边的节点

**执行过程示例**（以 [1,2,3,null,5,null,4] 为例）：

```
树的结构：
    1
   / \
  2   3
   \   \
    5   4

BFS 方法：
第 1 层：[1]，最右边是 1
第 2 层：[2, 3]，最右边是 3
第 3 层：[5, 4]，最右边是 4
结果：[1, 3, 4]

DFS 方法（先右后左）：
depth=0: 访问 1，result.size()=0，加入 1，result=[1]
depth=1: 访问 3，result.size()=1，加入 3，result=[1,3]
depth=2: 访问 4，result.size()=2，加入 4，result=[1,3,4]
depth=2: 访问 5，result.size()=3，不加入（该层已有元素）
depth=1: 访问 2，result.size()=3，不加入（该层已有元素）
结果：[1, 3, 4]
```

**为什么 DFS 要先右后左？**
- 如果先左后右，每层第一个访问的就是最左边的节点
- 先右后左，每层第一个访问的就是最右边的节点
- 通过 `depth == result.size()` 判断是否是该层第一次访问

**两种方法的对比：**
- **BFS**：更直观，清晰地按层处理
- **DFS**：更巧妙，利用遍历顺序和深度判断

**变体：左视图**
如果要求左视图（从左边看），只需要将 DFS 的遍历顺序改为"先左后右"即可：
```cpp
dfs(node->left, depth + 1, result);
dfs(node->right, depth + 1, result);
```

