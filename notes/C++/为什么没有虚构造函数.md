# 为什么没有虚构造函数

### 面试时的简洁总结

“C++ 没有虚构造函数，因为虚机制依赖对象里的 vptr，而 vptr 在构造函数运行过程中才会被设置。
在对象还没完成构造之前，动态分派根本无从谈起。如果需要根据类型动态创建对象，通常用工厂函数或静态接口来实现。”

---

### 1. 构造流程的真实顺序

1. **分配内存**：`new` 表达式第一步就是 `operator new`，它先分配一块足够容纳对象的内存。
2. **调用构造函数**：然后才在这块内存上调用构造函数，初始化对象。
3. **初始化 vptr**：如果类有虚函数，编译器在进入构造函数时会写入合适的 vptr（指向当前类的 vtable）。

所以严格来说：

* 内存是在调用构造函数之前就分配了。
* 但是 vptr 的初始化是在构造函数执行期间才完成。

---

### 2. 为什么构造函数不能是虚函数

* 虚函数的分派依赖 vptr（对象里的一根指针）。
* 可在进入构造函数之前，对象的动态类型还没建立，vptr 也没有指向有效的 vtable。
* 这意味着：**你根本无法在“调用构造函数”这个时机利用虚机制做动态分派**。

因此，所谓“虚构造函数”是自相矛盾的：
要用虚表分派，得先有对象；
要有对象，得先构造完成；
而构造函数正是建立这个对象的过程。

---

### 3. 替代方案

如果你需要“根据运行时类型决定构造哪个对象”，C++ 的解决办法是 **工厂模式** 或 **静态创建函数**，而不是虚构造函数。

---