---
created: '2025-10-19'
last_reviewed: '2025-10-19'
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- C++
- C++/动态多态和静态多态的区别.md
related_outlines: []
---

# 动态多态和静态多态的区别
---

### 面试标准回答

“动态多态依赖虚函数表，在运行时通过基类指针或引用调用派生类的实现，适合需要运行时确定行为的场景。
静态多态通常通过模板或函数重载实现，在编译期就确定具体调用哪个实现，没有运行时开销，适合对性能要求高、但类型在编译期就能确定的场景。
前者常见于面向对象接口设计，后者常见于泛型编程和高性能库，比如 STL。”

---

### 1. 动态多态（运行时多态）

* **实现方式**：依赖 **虚函数**，通过 vptr + vtable 在运行时做函数分派。
* **调用绑定时机**：运行时绑定（runtime binding）。
* **开销**：多了一次间接寻址（查 vtable），以及对象里存放 vptr 的额外空间。
* **场景**：

  * 面向对象设计中常见：比如 `Shape* s = new Circle(); s->draw();`
  * 框架/库里提供统一接口，派生类按需重写。
  * 需要在运行时才能确定调用哪个实现。

---

### 2. 静态多态（编译期多态）

* **实现方式**：依赖 **模板** 和 **函数重载**，在编译期由编译器确定调用哪个实现。
* **调用绑定时机**：编译期绑定（compile-time binding）。
* **开销**：没有 vtable 查找，调用开销可优化为内联（性能高）。
* **场景**：

  * 模板编程：`std::sort` 可以对任意可比较的类型排序，具体调用哪个比较函数在编译期就决定了。
  * CRTP（Curiously Recurring Template Pattern）：通过模板实现类似“接口”的约束，但在编译期展开，避免虚函数开销。

示例：

```cpp
// 动态多态
struct Base { virtual void f() = 0; };
struct Derived : Base { void f() override { ... } };
Base* p = new Derived(); p->f(); // 运行时决定

// 静态多态
template<typename T>
void f(T t) { t(); }  // 编译期展开调用具体类型的 operator()
```

---

### 3. 对比总结

* **动态多态**：运行时灵活、扩展性好，但有运行时开销，需对象存储 vptr。
* **静态多态**：性能高，编译期展开，但类型在编译期就必须确定，灵活性差些。

---

## 相关笔记
<!-- 自动生成 -->

暂无相关笔记

