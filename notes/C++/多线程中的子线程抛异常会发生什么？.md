---
created: '2025-10-19'
last_reviewed: '2025-10-19'
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- C++
- C++/多线程中的子线程抛异常会发生什么？.md
related_outlines: []
---

# 多线程中的子线程抛异常会发生什么？

### 面试标准表述（精炼版）

在 C++ 中，如果子线程里有异常没有被捕获，线程函数返回栈外后会直接调用 std::terminate，整个进程都会崩溃。
因此必须在线程函数内部捕获异常，并通过机制传回主线程，比如：

用 std::promise/std::future 传递异常对象；

或者使用 std::async，它会自动把异常保存到 future 里，主线程在 get() 时重新抛出。

一句话：子线程异常必须自己捕获，否则全进程崩溃，推荐用 future 系列安全传递。

---

### 1. 子线程抛异常但没捕获

* 在 C++ 里，如果一个异常**穿过了子线程的最外层函数**，标准规定直接调用 **`std::terminate()`**。
* 也就是说，整个进程会崩掉，不是只有子线程死掉。

---

### 2. 正确的做法

* 在子线程函数内部必须用 `try-catch` 把异常抓住。
* 想把错误传回主线程，可以：

  1. 用 **共享状态**（比如 `std::promise` + `std::future`）：子线程捕获异常后用 `promise.set_exception()`，主线程用 `future.get()` 时重新抛出。
  2. 或者用 **任务包装器**（`std::packaged_task` / `std::async`），这些会自动把异常封装进 future。
  3. 还有更朴素的办法：用一个线程安全队列，把错误信息写进去，主线程读取。

---

### 3. 示例

```cpp
#include <iostream>
#include <thread>
#include <future>
#include <stdexcept>

void worker(std::promise<int> p) {
    try {
        throw std::runtime_error("boom!");
    } catch (...) {
        p.set_exception(std::current_exception()); // 捕获并传回
    }
}

int main() {
    std::promise<int> p;
    std::future<int> f = p.get_future();

    std::thread t(worker, std::move(p));
    t.join();

    try {
        int val = f.get();   // 这里会重新抛出子线程的异常
    } catch (const std::exception& e) {
        std::cout << "Caught exception: " << e.what() << "\n";
    }
}
```

---

### 一句话总结

在子线程里异常如果不处理，程序会直接 `terminate`。正确做法是**在线程内捕获异常，并通过 `future` 或其他通信机制传递到主线程**。
