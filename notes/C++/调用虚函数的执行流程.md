---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- C++
- C++/调用虚函数的执行流程.md
related_outlines: []
---
**1. 背景设定**

```cpp
struct B {
    virtual void foo();
};

struct D : B {
    void foo() override;
};
```

* `B` 有一个虚函数 `foo()`，所以对象里会有一个 **vptr**，指向 `B` 的 vtable。
* `D` 继承自 `B`，并且重写了 `foo()`，所以 `D` 会有自己的 vtable，其中 `foo` 的槽位被替换为 `D::foo`。

---

**2. 运行时调用流程**
假设我们有：

```cpp
B* p = new D();
p->foo();   // 动态多态
```

执行过程是这样的：

1. **创建对象**：`new D()` 时，编译器生成的构造函数会把 `D` 对象的 **vptr** 指向 `D` 的 vtable。
2. **通过基类指针调用**：`p` 是 `B*`，所以编译器只知道要调 `B::foo()` 的槽位，但它不会直接写死 `B::foo` 的地址。
3. **间接访问 vtable**：

   * 程序先访问 `p` 对象里的 `vptr`；
   * 找到它指向的 vtable（这里是 `D` 的 vtable）；
   * 再根据虚函数在类定义中的“顺序”找到正确的函数指针（foo 对应的槽位）；
4. **执行函数**：调用该槽里的函数指针 → 实际就是 `D::foo()`。

---

**3. 图示（简化版）**

```
[B* p] → [对象D]
           vptr ─────────────┐
                             ↓
                        vtable_D
                        [0] = &D::foo
                        [1] = …  (其他虚函数)

调用 p->foo():
   load p->vptr
   lookup vptr[0]
   call *(vptr[0])   // 实际就是 D::foo
```

---

**4. 总结面试式回答**
“动态多态是通过 vptr 和 vtable 实现的。对象里有一个 vptr，指向所属类的 vtable。调用虚函数时，程序不会直接跳转到基类函数地址，而是先取对象里的 vptr，找到 vtable，再根据虚函数在类里声明的顺序索引到正确的函数指针，最后间接调用它。如果子类重写了这个函数，对应槽位就会被替换成子类实现，从而实现动态绑定。”

---

## 相关笔记
<!-- 自动生成 -->

- [虚函数的实现机制（虚函数表）](notes/C++/虚函数的实现机制（虚函数表）.md) - 相似度: 33% | 标签: C++, C++/虚函数的实现机制（虚函数表）.md

