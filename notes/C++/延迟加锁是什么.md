# 延迟加锁是什么

### 面试标准表述（精炼版）

延迟加锁是 std::unique_lock 的一个特性。通过在构造函数里传入 std::defer_lock 标记，可以让锁对象在初始化时不自动加锁，而是处于未加锁状态。等到真正需要进入临界区时，再手动调用 lock()。

这种方式常用于：

在加锁前先做准备工作，缩短持锁时间。

配合 std::lock 一次性获取多个锁，避免死锁。

---

### 定义

延迟加锁指的是：**在构造 `unique_lock` 对象的时候，不立刻获取互斥锁，而是等到需要时再手动调用 `lock()`**。
这样一来，你可以更灵活地控制锁的获取时机。

---

### 使用方式

通过传入 `std::defer_lock` 标记来启用：

```cpp
std::mutex m;

void work() {
    std::unique_lock<std::mutex> ul(m, std::defer_lock); // 构造时不加锁
    // 做一些不需要锁的操作
    ul.lock();   // 这里才真正加锁
    // 临界区
    ul.unlock(); // 手动解锁
}
```

---

### 应用场景

1. **需要在获取锁之前做一些准备工作**

   * 比如函数一开始要先做输入校验或分配资源，避免锁住太久。
2. **一次性申请多个锁时**

   * 配合 `std::lock`：

     ```cpp
     std::unique_lock<std::mutex> l1(m1, std::defer_lock);
     std::unique_lock<std::mutex> l2(m2, std::defer_lock);
     std::lock(l1, l2); // 一次性加两个锁，避免死锁
     ```
3. **条件变量**

   * `std::condition_variable` 的 `wait()` 会在内部解锁并重新加锁，这就需要 `unique_lock` 的灵活性。

---

### 一句话总结

延迟加锁就是 **创建锁对象时先不锁，等需要的时候再手动上锁**。它主要用在需要灵活控制加锁时机或一次性加多个锁的场景。