# new[]和delete[]的使用注意事项

### 面试标准回答

“在 C++ 里，`new[]` 和 `delete[]` 必须配套使用。`new[]` 会在堆上分配一组对象并逐个调用构造函数，同时编译器通常会在内存块里额外存储数组大小信息。`delete[]` 根据这些信息逐个调用析构函数并释放内存。如果用 `delete` 去释放 `new[]` 分配的数组，只会析构第一个元素，导致资源泄漏。即便是内置类型数组，虽然表现上可能没问题，但标准规定这也是未定义行为，所以必须严格配对使用。”

---

### 1. `new[]` 与 `delete[]` 的配套使用

* **`new[]`**：用于在堆上分配一组对象，并依次调用每个对象的构造函数。
* **`delete[]`**：用于释放由 `new[]` 分配的对象数组，并依次调用每个对象的析构函数。

```cpp
Foo* arr = new Foo[10];   // 调用 10 次 Foo::Foo()
delete[] arr;             // 调用 10 次 Foo::~Foo()
```

⚠️ 如果你写成 `delete arr;`，只会调用第一个对象的析构函数，造成内存泄漏和逻辑错误。

---

### 2. 为什么 `delete[]` 必须和 `new[]` 搭配

* 编译器在用 `new[]` 分配数组时，通常会在分配的内存块里**额外保存数组大小信息**（比如在头部存一个计数）。
* 这样 `delete[]` 才能知道要调用多少次析构函数。
* 如果误用 `delete`，编译器只会调用一次析构，并释放整块内存，导致剩余元素没有被析构。

---

### 3. 特殊注意点

* **基本类型**（如 `int* p = new int[10];`）：因为没有构造/析构，所以 `delete p;` 和 `delete[] p;` 在表面上看似没区别，但这是**未定义行为**，必须严格用 `delete[]`。
* **自定义类型**：区别就很明显了，因为必须依次调用析构函数。
* **混用 malloc/free 和 new/delete**：不允许！`malloc/free` 只分配释放原始内存，不调用构造析构；`new/delete` 必须配套。
