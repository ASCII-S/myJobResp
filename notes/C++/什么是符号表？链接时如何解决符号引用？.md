## 什么是符号表？

符号表（Symbol Table）是目标文件或可执行文件里的一张表，用来记录程序里定义和引用的符号。这里的"符号"可以是函数名、全局变量名、静态变量，甚至编译器生成的一些中间名字。

符号表里通常包含：
- 符号的名字
- 所在的段（代码段/数据段）
- 地址偏移
- 符号类型（函数/变量）
- 符号作用域（本地/全局）等信息

## 编译阶段的符号分类

在编译阶段，每个源文件单独编译成目标文件，目标文件里的符号分为：

**已定义符号（Definition）：** 比如 `int g;` `void foo(){}`，它们在本文件中有实体。

**未定义符号（Undefined/External）：** 比如调用了 `printf`，但是当前文件里没有定义。

## 链接时如何解决符号引用？

链接时解决符号引用的过程：

1. **收集符号表**
   链接器会扫描所有目标文件和库文件，收集它们的符号表。

2. **符号解析（Symbol Resolution）**
   遇到"未定义符号"时，就在其他目标文件或库里寻找匹配的"已定义符号"。一旦找到，就把引用和定义建立对应关系。

3. **重定位（Relocation）**
   然后链接器会修改目标文件里的重定位表，把函数调用或变量访问的"占位地址"改成实际的地址。

### 举个例子：

- 文件 `a.o` 里有 `extern void foo();` 并且调用了 `foo`
- 文件 `b.o` 里真正实现了 `void foo(){...}`

链接器看到 `a.o` 的未定义符号 `foo`，就在 `b.o` 的符号表里找到 `foo` 的定义，然后把 `a.o` 中调用 `foo` 的那条指令对应的地址修正为 `b.o` 中 `foo` 的地址。

## 动态库的特殊情况

如果符号来自动态库，可执行文件在静态链接阶段不会直接得到具体地址，只会在符号表里留下一个"需要运行时解析"的记录，最终由动态链接器在程序启动时把符号地址填进 GOT 表。