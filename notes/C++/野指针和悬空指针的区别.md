# 野指针和悬空指针的区别

你把核心点说得挺清楚了：野指针是“天生不干净”，悬空指针是“后来断了线”。我来帮你梳理得更系统一点，方便面试时直接拿来用。

### 4. 面试标准回答

“野指针是指针变量未初始化就被使用，里面保存的是垃圾地址；悬空指针是指针原来指向的对象已经销毁或内存已释放，但指针没有被置空。两者的危害都是未定义行为，可能造成段错误或数据破坏。预防措施是：定义时初始化指针、释放内存后及时置空、避免返回局部变量地址，并在现代 C++ 中用智能指针管理资源。”

---

### 1. 野指针（Wild Pointer）

**定义**：指针变量没有初始化，里面存的值是**随机垃圾地址**。

* 例如：

  ```cpp
  int* p;   // 没初始化，p 里是随机值
  *p = 10;  // 未定义行为，可能直接段错误
  ```

**特点**：生下来就“不干净”，因为未初始化。
**防范措施**：

* 定义时就初始化（`int* p = nullptr;`）。
* 避免使用未赋值的指针。
* 在 C++11 之后，推荐 `nullptr` 而不是 `NULL`。

---

### 2. 悬空指针（Dangling Pointer）

**定义**：指针原来指向一块合法内存，但这块内存被释放/超出作用域后，指针没有被重置，仍然指向“无效地址”。

* 例如：

  ```cpp
  int* p = new int(5);
  delete p;   // 内存释放
  *p = 10;    // 悬空指针：指向已经被释放的区域
  ```
* 另一种情况：

  ```cpp
  int* foo() {
      int x = 42;
      return &x;   // 返回局部变量地址 → 悬空指针
  }
  ```

**特点**：一开始是合法的，后来“失效”了。
**防范措施**：

* 释放内存后立刻置空（`p = nullptr;`）。
* 避免返回局部变量的地址。
* 用智能指针 (`std::unique_ptr` / `std::shared_ptr`) 管理资源，避免手动 `delete`。

---

### 3. 危害

* 读写未定义内存，轻则段错误，重则写坏别的对象数据，引入难以排查的 bug。
* 比“程序崩溃”更可怕的是“程序不崩溃，但数据被默默改坏”。

---
