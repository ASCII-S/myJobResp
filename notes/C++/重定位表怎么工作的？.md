---
created: '2025-10-19'
last_reviewed: '2025-10-19'
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- C++
- C++/重定位表怎么工作的？.md
related_outlines: []
---



**重定位表（Relocation Table）** 是目标文件中的一个数据结构，记录了哪些位置的指令或数据在链接之后需要修改地址。因为在编译单个源文件时，编译器并不知道函数或变量的最终内存地址，只能先填一个占位符，等到链接阶段再来修正。

每一条重定位记录通常包含：

* 需要修正的位置（偏移地址）；
* 关联的符号名（比如函数 `foo` 或变量 `g`）；
* 修正的类型（是绝对地址还是相对偏移）；
* 额外的偏移量。

---

**工作流程**：

1. 编译阶段：

   * 编译器遇到函数调用或全局变量访问时，会在指令里先填一个临时值（通常是 0），并在重定位表里加一条记录，标记“这里引用了某个符号，稍后要修正”。

2. 链接阶段：

   * 链接器首先做符号解析，找到这个符号的真实地址。
   * 然后扫描重定位表，把对应位置的临时值替换成符号的最终地址（或相对偏移）。
   * 这样，函数调用指令就能真正跳转到正确的目标，变量访问也能访问正确的内存。

---

举个具体例子：

* 在 `a.o` 里写了 `extern int g; printf("%d\n", g);`
* 编译时，访问 `g` 的那条指令地址未知，所以在重定位表里加一条记录：

  > “偏移 0x14 的地方引用了符号 g，类型是绝对地址”。
* 链接时，链接器发现 `g` 在 `b.o` 里定义，地址是 `0x600a20`，于是就把 `a.o` 里 0x14 偏移处的占位符改成 0x600a20。

---

**动态链接的区别**：

* 静态链接时，链接器直接修改目标文件的代码和数据段，把地址写死。
* 动态链接时，链接器只把引用指向 GOT 表，真正的地址由运行时动态链接器去填充。

---

所以一句话总结：
**重定位表是链接器的“待办清单”，它告诉链接器哪些位置需要把符号引用改成实际地址。**
