---
created: '2025-10-19'
last_reviewed: '2025-10-19'
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- C++
- C++/什么是竞态条件？如何避免？.md
related_outlines: []
---

# 什么是竞态条件？如何避免？


### 什么是竞态条件（Race Condition）

竞态条件指的是：**多个线程在没有正确同步的情况下，同时访问和修改共享数据，导致结果依赖于线程的执行时序，从而产生不可预期的错误。**

简单说：线程 A 和线程 B 谁先执行都行，但如果同时读写一个变量，没有同步，就会“打架”，结果随机。

---

### 示例

```cpp
#include <iostream>
#include <thread>

int counter = 0;

void work() {
    for (int i = 0; i < 100000; i++) {
        counter++;   // 没有同步，产生竞态条件
    }
}

int main() {
    std::thread t1(work);
    std::thread t2(work);
    t1.join();
    t2.join();

    std::cout << "counter = " << counter << "\n";
}
```

理论上结果应该是 200000，但实际上可能更小，因为两个线程可能同时读到相同的值，然后各自 +1，再写回，导致丢失更新。

---

### 如何避免竞态条件

1. **互斥锁（`std::mutex`）**

   * 给共享资源加锁，确保同一时间只有一个线程能修改。

   ```cpp
   std::mutex m;
   void work() {
       for (int i = 0; i < 100000; i++) {
           std::lock_guard<std::mutex> lg(m);
           counter++;
       }
   }
   ```

2. **原子操作（`std::atomic`）**

   * 把变量声明为原子类型，让加减操作在硬件层面保证不被打断。

   ```cpp
   std::atomic<int> counter{0};
   ```

3. **更高层的并发容器/算法**

   * 比如 `concurrent_queue`（TBB）、`std::atomic` 配合 lock-free 数据结构。

---

### 一句话总结

竞态条件就是多个线程同时操作共享资源而没有同步，结果取决于执行时序。
避免的方法是：**用锁保护，或者用原子操作替代。**