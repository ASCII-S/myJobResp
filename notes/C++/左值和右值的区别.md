---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- C++
- C++/左值和右值的区别.md
related_outlines: []
---
# 左值和右值的区别

## 面试标准答案（可背诵）

**左值（lvalue）** 是指有明确内存地址、可以取地址的表达式，通常可以出现在赋值语句的左边；**右值（rvalue）** 是指临时的、即将销毁的对象或字面量，没有持久的内存地址，只能出现在赋值语句的右边。

简单判断方法：**能对表达式取地址的是左值，不能取地址的是右值**。

C++11引入了**左值引用**（`&`）和**右值引用**（`&&`）来分别绑定左值和右值，这是移动语义的基础。

---

## 详细讲解

### 1. 基本概念

#### 1.1 左值（lvalue）

左值代表一个占据内存空间的对象，具有以下特征：
- 有明确的内存地址
- 可以使用 `&` 取地址运算符
- 生命周期超出单个表达式
- 可以出现在赋值语句的左边或右边

**典型的左值：**
```cpp
int x = 10;        // x 是左值
int* p = &x;       // 可以取地址
x = 20;            // 可以被赋值

int arr[5];        // arr 是左值
arr[0] = 1;        // arr[0] 是左值

std::string str;   // str 是左值
```

#### 1.2 右值（rvalue）

右值代表临时对象或字面量，具有以下特征：
- 没有持久的内存地址（或地址不可访问）
- 不能使用 `&` 取地址
- 通常是临时的、即将销毁的
- 只能出现在赋值语句的右边

**典型的右值：**
```cpp
int x = 42;        // 42 是右值（字面量）
int y = x + 1;     // x + 1 是右值（临时计算结果）

std::string s = std::string("hello");  // std::string("hello") 是右值（临时对象）

int func() { return 5; }
int z = func();    // func() 返回的是右值
```

### 2. C++11 的分类细化

C++11 将值类别进一步细化为：

```
        表达式
       /      \
    glvalue   rvalue
    /    \    /    \
 lvalue  xvalue  prvalue
```

- **lvalue（左值）**：传统意义的左值
- **prvalue（纯右值）**：传统意义的右值，如字面量、临时对象
- **xvalue（将亡值）**：即将被移动的对象，如 `std::move(x)` 的结果
- **glvalue（泛左值）**：lvalue + xvalue
- **rvalue（右值）**：prvalue + xvalue

### 3. 实际示例对比

```cpp
int a = 10;           // a 是左值
int b = 20;           // b 是左值
int c = a + b;        // a + b 是右值（临时计算结果）

int* p1 = &a;         // ✅ 正确：a 是左值，可以取地址
// int* p2 = &(a + b);  // ❌ 错误：a + b 是右值，不能取地址

std::string s1 = "hello";                    // "hello" 字面量是右值，s1 是左值
std::string s2 = s1;                         // s1 是左值
std::string s3 = s1 + " world";              // s1 + " world" 是右值
std::string s4 = std::string("temp");        // std::string("temp") 是右值

// 函数返回值
std::string getString() { return "test"; }
std::string s5 = getString();                // getString() 返回右值
// std::string& ref = getString();           // ❌ 错误：不能用左值引用绑定右值
const std::string& cref = getString();       // ✅ 正确：const 左值引用可以绑定右值
std::string&& rref = getString();            // ✅ 正确：右值引用绑定右值
```

### 4. 引用类型绑定规则

| 引用类型                | 可以绑定   | 示例                 |
| ----------------------- | ---------- | -------------------- |
| `T&` 左值引用           | 左值       | `int& r = x;`        |
| `const T&` 常量左值引用 | 左值、右值 | `const int& r = 42;` |
| `T&&` 右值引用          | 右值       | `int&& r = 42;`      |

```cpp
int x = 10;
int& lr = x;              // ✅ 左值引用绑定左值
// int& lr2 = 42;         // ❌ 左值引用不能绑定右值

const int& clr = x;       // ✅ const 左值引用绑定左值
const int& clr2 = 42;     // ✅ const 左值引用可以绑定右值（延长生命周期）

// int&& rr = x;          // ❌ 右值引用不能绑定左值
int&& rr = 42;            // ✅ 右值引用绑定右值
int&& rr2 = x + 1;        // ✅ 右值引用绑定右值
```

### 5. 常见误区

#### 误区1：右值引用变量本身是左值
```cpp
void process(int&& x) {
    // x 虽然类型是右值引用，但 x 本身是左值（有名字、有地址）
    int* p = &x;          // ✅ 可以取地址
    int&& r = x;          // ❌ 错误：不能用右值引用绑定左值
    int&& r = std::move(x);  // ✅ 需要 std::move 转换
}
```

#### 误区2：const 左值引用的特殊性
```cpp
// const 左值引用是 C++11 之前唯一可以绑定右值的引用类型
const std::string& ref = std::string("temp");  // 右值的生命周期被延长
```

### 6. 为什么需要区分左值和右值？

1. **性能优化**：右值是临时对象，可以"偷取"其资源而非复制
2. **移动语义**：右值引用使得移动构造和移动赋值成为可能
3. **完美转发**：模板编程中正确转发参数类型
4. **资源管理**：避免不必要的深拷贝，提高效率

### 7. 实际应用

```cpp
class Buffer {
    char* data;
    size_t size;
public:
    // 拷贝构造：接受左值
    Buffer(const Buffer& other) {
        size = other.size;
        data = new char[size];
        std::copy(other.data, other.data + size, data);
        std::cout << "拷贝构造（深拷贝）\n";
    }
    
    // 移动构造：接受右值
    Buffer(Buffer&& other) noexcept {
        data = other.data;      // 直接"偷取"资源
        size = other.size;
        other.data = nullptr;   // 源对象置空
        other.size = 0;
        std::cout << "移动构造（资源转移）\n";
    }
};

Buffer createBuffer() { return Buffer(1024); }

Buffer b1(1024);
Buffer b2 = b1;              // 调用拷贝构造（b1 是左值）
Buffer b3 = createBuffer();  // 调用移动构造（createBuffer() 返回右值）
Buffer b4 = std::move(b1);   // 调用移动构造（std::move 将左值转为右值）
```

---

## 总结

- **左值**：有地址、持久存在的对象
- **右值**：临时的、即将销毁的值
- **区分意义**：编译器可以对右值进行移动优化，避免不必要的拷贝
- **判断方法**：能取地址的是左值，不能取地址的是右值


---

## 相关笔记
<!-- 自动生成 -->

暂无相关笔记

