---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- C++
- C++/右值引用.md
related_outlines: []
---
# 右值引用

## 面试标准答案（可背诵）

**右值引用**是 C++11 引入的新特性，使用 `T&&` 语法，专门用来绑定右值（临时对象）。它的主要作用是：
1. **实现移动语义**：允许"窃取"临时对象的资源，避免深拷贝
2. **支持完美转发**：在模板中保持参数的值类别属性

右值引用变量本身是左值，需要通过 `std::move` 或 `std::forward` 来转换。

---

## 详细讲解

### 1. 什么是右值引用

右值引用是 C++11 引入的新引用类型，语法为 `T&&`，用于绑定右值。

```cpp
int&& rref = 42;           // 右值引用绑定字面量
int&& rref2 = 10 + 20;     // 右值引用绑定临时计算结果

std::string&& s = std::string("hello");  // 右值引用绑定临时对象

int x = 5;
// int&& rref3 = x;        // ❌ 错误：右值引用不能直接绑定左值
int&& rref4 = std::move(x); // ✅ 使用 std::move 将左值转换为右值
```

### 2. 右值引用 vs 左值引用

| 特性       | 左值引用 `T&`               | 右值引用 `T&&`       |
| ---------- | --------------------------- | -------------------- |
| 绑定对象   | 左值                        | 右值                 |
| 主要用途   | 避免拷贝、修改原对象        | 移动语义、资源转移   |
| const 版本 | `const T&` 可绑定左值和右值 | `const T&&` 较少使用 |
| 引入版本   | C++98                       | C++11                |

```cpp
int x = 10;

int& lref = x;             // ✅ 左值引用绑定左值
// int& lref2 = 42;        // ❌ 左值引用不能绑定右值
const int& clref = 42;     // ✅ const 左值引用可以绑定右值

// int&& rref = x;         // ❌ 右值引用不能绑定左值
int&& rref = 42;           // ✅ 右值引用绑定右值
int&& rref2 = std::move(x);// ✅ std::move 转换后可绑定
```

### 3. 核心特性：右值引用变量本身是左值

这是一个极其重要但容易混淆的概念：

```cpp
void process(int&& x) {
    // x 的类型是 int&&（右值引用）
    // 但 x 本身是左值（因为它有名字、有地址）
    
    int* p = &x;              // ✅ 可以取地址，说明 x 是左值
    
    int&& r1 = x;             // ❌ 错误：不能用右值引用绑定左值
    int& r2 = x;              // ✅ 正确：用左值引用绑定左值
    int&& r3 = std::move(x);  // ✅ 正确：需要显式转换
}

int a = 10;
process(std::move(a));        // 传入右值
```

**理解要点**：
- **类型是右值引用** ≠ **表达式是右值**
- 有名字的右值引用变量是左值
- 这样设计是为了防止意外的资源转移

### 4. 右值引用的主要用途

#### 4.1 实现移动语义

移动语义允许从临时对象"窃取"资源，而非深拷贝：

```cpp
class String {
    char* data;
    size_t len;
    
public:
    // 拷贝构造函数（接受左值）
    String(const String& other) {
        len = other.len;
        data = new char[len + 1];
        std::strcpy(data, other.data);
        std::cout << "拷贝构造\n";
    }
    
    // 移动构造函数（接受右值）
    String(String&& other) noexcept {
        data = other.data;      // 直接接管资源
        len = other.len;
        
        other.data = nullptr;   // 源对象置空
        other.len = 0;
        std::cout << "移动构造\n";
    }
    
    ~String() {
        delete[] data;
    }
};

String createString() {
    return String("hello");
}

String s1("world");
String s2 = s1;              // 拷贝构造（s1 是左值）
String s3 = createString();  // 移动构造（返回值是右值）
String s4 = std::move(s1);   // 移动构造（显式转换为右值）
```

#### 4.2 支持完美转发

在模板中保持参数的值类别：

```cpp
template<typename T>
void wrapper(T&& arg) {
    // 如果传入左值，T 推导为 T&，arg 类型折叠为 T&
    // 如果传入右值，T 推导为 T，arg 类型为 T&&
    
    process(std::forward<T>(arg));  // 完美转发，保持原始值类别
}

int x = 10;
wrapper(x);           // 转发左值
wrapper(42);          // 转发右值
```

### 5. 引用折叠规则

当右值引用与模板或 `typedef` 结合时，会发生引用折叠：

| 原始类型 | 模板推导/typedef | 最终类型 |
| -------- | ---------------- | -------- |
| `T&`     | `& &`            | `T&`     |
| `T&`     | `& &&`           | `T&`     |
| `T&&`    | `&& &`           | `T&`     |
| `T&&`    | `&& &&`          | `T&&`    |

**规则**：只有 `&& &&` 才折叠为 `&&`，其他都折叠为 `&`。

```cpp
template<typename T>
void func(T&& param);

int x = 10;
func(x);           // T 推导为 int&, param 类型为 int& && → int&
func(10);          // T 推导为 int, param 类型为 int&&
```

### 6. 常见使用场景

#### 场景1：容器的 emplace 操作
```cpp
std::vector<std::string> vec;

vec.push_back(std::string("hello"));     // 创建临时对象，然后移动
vec.emplace_back("world");               // 直接在容器中构造，更高效

// emplace_back 的简化实现
template<typename... Args>
void emplace_back(Args&&... args) {
    // 使用完美转发构造对象
    allocator.construct(ptr, std::forward<Args>(args)...);
}
```

#### 场景2：工厂函数返回值
```cpp
std::unique_ptr<Widget> createWidget() {
    return std::make_unique<Widget>(params);  // 返回右值，自动移动
}

auto widget = createWidget();  // 移动语义，无拷贝
```

#### 场景3：交换操作优化
```cpp
template<typename T>
void swap(T& a, T& b) {
    T temp = std::move(a);    // 移动而非拷贝
    a = std::move(b);
    b = std::move(temp);
}
```

### 7. 注意事项

#### 7.1 移动后对象的状态

移动后的对象处于**有效但未指定**的状态：

```cpp
std::string s1 = "hello";
std::string s2 = std::move(s1);

// s1 仍然是有效对象，但内容未指定
// 可以安全地：
s1 = "new value";     // ✅ 重新赋值
s1.clear();           // ✅ 调用成员函数

// 但不应该：
// std::cout << s1;   // ⚠️ 内容未指定，不推荐
```

#### 7.2 不要返回局部变量的右值引用

```cpp
int&& dangling() {
    int x = 10;
    return std::move(x);  // ❌ 危险：返回局部变量的引用
}  // x 被销毁，返回的引用悬空
```

#### 7.3 noexcept 的重要性

移动操作应尽量标记为 `noexcept`，这样容器才能安全使用：

```cpp
class Widget {
public:
    Widget(Widget&& other) noexcept {  // 标记为 noexcept
        // 移动实现
    }
};

// std::vector 在重新分配时，只有 noexcept 的移动构造才会被使用
// 否则为了异常安全，会退化为拷贝
```

### 8. 与智能指针的配合

```cpp
void process(std::unique_ptr<Widget> ptr) {
    // ptr 接管所有权
}

std::unique_ptr<Widget> p = std::make_unique<Widget>();

// process(p);              // ❌ 错误：unique_ptr 不可拷贝
process(std::move(p));      // ✅ 正确：转移所有权

// 此后 p 为空指针
```

### 9. 判断是否应该使用右值引用的准则

**应该使用右值引用的场景：**
- 实现移动构造函数和移动赋值运算符
- 实现完美转发的通用引用（Universal Reference）
- 接受并转移资源所有权

**不应该使用的场景：**
- 仅为了接受参数而不转移资源（用 `const T&`）
- 返回局部变量（编译器会自动优化）

---

## 总结

1. **右值引用** (`T&&`) 专门用于绑定右值，是移动语义的基础
2. **关键特性**：右值引用变量本身是左值
3. **主要用途**：
   - 实现高效的移动语义
   - 支持完美转发
   - 避免不必要的深拷贝
4. **配合使用**：`std::move` 和 `std::forward`
5. **最佳实践**：移动操作应标记为 `noexcept`


---

## 相关笔记
<!-- 自动生成 -->

- [右值引用与移动语义](notes/C++/右值引用与移动语义.md) - 相似度: 36% | 标签: C++, C++/右值引用与移动语义.md
- [移动语义和std::move](notes/C++/移动语义和std::move.md) - 相似度: 33% | 标签: C++, C++/移动语义和std::move.md

