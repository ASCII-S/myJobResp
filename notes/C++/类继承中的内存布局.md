---
created: '2025-10-19'
last_reviewed: null
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- C++
- C++/类继承中的内存布局.md
related_outlines: []
---
# 类继承中的内存布局

**1. 空类**

* 标准规定空类必须占有非零大小，以保证不同对象有唯一地址。通常是 **1 字节**。
* 如果空类被继承，那么编译器可以用 **空基类优化（EBO, Empty Base Optimization）**，使得派生类里这个空基类不再单独占字节。
* 所以「空类继承空类」时，结果大小通常还是 1 字节。

---

**2. 普通单继承**

* 内存布局确实是「基类的子对象」+「派生类自己的成员」。
* 顺序一般就是基类成员在前，派生类新增的跟在后。

---

**3. 多重继承**

* 编译器会把每个基类的子对象，按照声明顺序排进内存。
* 每个子对象的内存布局保持独立。
* 这时候如果存在同名成员，访问时会有二义性，需要作用域限定。

---

**4. 虚函数（多态机制）**

* 一旦类里有虚函数，编译器一般会在对象里插入一个 **vptr（虚函数表指针）**。
* 这个指针指向一张 **vtable（虚函数表）**，里面存的是函数指针数组。
* 不同对象的 `vptr` 可能指向不同的表，从而实现动态绑定。
* vptr 的位置不由标准规定，但常见实现是放在对象头部。

注意：**虚函数 ≠ 虚继承**，这是两个完全不同的概念。

---

**5. 虚继承**

* 用来解决菱形继承里重复基类的问题。
* 编译器会让虚基类子对象只保留一份，派生类里不直接存放虚基类，而是通过一个 **vbptr（虚基类指针）** 找到虚基类子对象的真正位置。
* 所以对象里会多出一个额外的指针字段（vbptr），它指向一张虚基类表（vbtbl），表里记录了如何偏移到虚基类。
* 虚继承和虚函数可以同时存在，此时对象既可能有 vptr，也可能有 vbptr。

---


---

## 相关笔记
<!-- 自动生成 -->

- [虚函数的实现机制（虚函数表）](notes/C++/虚函数的实现机制（虚函数表）.md) - 相似度: 31% | 标签: C++, C++/虚函数的实现机制（虚函数表）.md

