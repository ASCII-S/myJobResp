# 内存池和对象池的设计思想

## 1. 内存池（Memory Pool）

### 设计思想
- **预分配策略**：在程序启动时预先分配一大块连续内存，避免频繁的系统调用
- **减少碎片化**：统一管理内存分配，减少内存碎片
- **提高性能**：避免频繁的malloc/free操作，减少系统开销

### 核心原理
```cpp
class MemoryPool {
private:
    char* pool;           // 内存池起始地址
    size_t pool_size;     // 内存池总大小
    size_t block_size;    // 每个块的大小
    void* free_list;      // 空闲块链表头
    
public:
    void* allocate();     // 分配内存
    void deallocate(void* ptr);  // 释放内存
};
```

### 优势
- **性能提升**：O(1)时间复杂度的分配和释放
- **内存局部性**：连续分配提高缓存命中率
- **避免碎片**：固定大小块分配
- **减少系统调用**：批量向系统申请内存

### 适用场景
- 频繁的小对象分配/释放
- 对性能要求极高的场景
- 嵌入式系统或实时系统
- 游戏引擎、数据库系统

## 2. 对象池（Object Pool）

### 设计思想
- **对象复用**：预创建对象实例，避免重复构造/析构
- **生命周期管理**：统一管理对象的创建、使用、回收
- **资源控制**：限制同时存在的对象数量

### 核心原理
```cpp
template<typename T>
class ObjectPool {
private:
    std::queue<std::unique_ptr<T>> available;  // 可用对象队列
    std::vector<std::unique_ptr<T>> pool;      // 对象池
    size_t max_size;                           // 最大对象数
    
public:
    T* acquire();        // 获取对象
    void release(T* obj); // 归还对象
    void expand();       // 扩展池大小
};
```

### 实现要点
```cpp
// 获取对象
T* acquire() {
    if (available.empty()) {
        if (pool.size() < max_size) {
            expand();
        } else {
            return nullptr; // 池已满
        }
    }
    
    auto obj = std::move(available.front());
    available.pop();
    T* ptr = obj.release();
    return ptr;
}

// 归还对象
void release(T* obj) {
    obj->reset(); // 重置对象状态
    available.push(std::unique_ptr<T>(obj));
}
```

### 优势
- **避免频繁构造/析构**：特别是重量级对象
- **内存使用可控**：限制最大对象数量
- **初始化开销分摊**：预先创建对象
- **减少GC压力**：在支持GC的语言中减少垃圾回收

### 适用场景
- 创建成本高的对象（如数据库连接）
- 频繁创建销毁的对象
- 需要控制资源使用量的场景
- 网络连接池、线程池

## 3. 设计模式对比

| 特性     | 内存池       | 对象池           |
| -------- | ------------ | ---------------- |
| 管理对象 | 内存块       | 完整对象         |
| 主要优化 | 内存分配效率 | 对象创建效率     |
| 适用对象 | 任意大小数据 | 特定类型对象     |
| 复杂度   | 较低         | 较高             |
| 状态管理 | 无           | 需要重置对象状态 |

## 4. 实际应用案例

### 内存池应用
```cpp
// STL allocator 实现
template<typename T>
class PoolAllocator {
    static MemoryPool pool;
public:
    T* allocate(size_t n) {
        return static_cast<T*>(pool.allocate(n * sizeof(T)));
    }
    
    void deallocate(T* p, size_t n) {
        pool.deallocate(p);
    }
};
```

### 对象池应用
```cpp
// 数据库连接池
class ConnectionPool {
    ObjectPool<DatabaseConnection> pool;
    
public:
    DatabaseConnection* getConnection() {
        return pool.acquire();
    }
    
    void returnConnection(DatabaseConnection* conn) {
        pool.release(conn);
    }
};
```

## 5. 注意事项

### 内存池注意事项
- **内存对齐**：确保分配的内存满足对齐要求
- **线程安全**：多线程环境需要同步机制
- **内存泄漏检测**：需要额外的调试支持
- **大小限制**：固定块大小可能不适合所有场景

### 对象池注意事项
- **状态重置**：归还对象时必须重置状态
- **异常安全**：确保异常情况下对象能正确归还
- **生命周期管理**：避免使用已归还的对象
- **池大小调优**：需要根据实际使用情况调整

## 6. 性能考虑

- **预热成本**：初始化时的内存/对象分配开销
- **内存占用**：预分配可能导致内存浪费
- **缓存友好性**：连续内存访问提高性能
- **并发性能**：需要考虑锁竞争对性能的影响
