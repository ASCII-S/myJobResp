---
created: '2025-10-19'
last_reviewed: '2025-10-19'
next_review: '2025-10-19'
review_count: 0
difficulty: medium
mastery_level: 0.0
tags:
- C++
- C++/循环引用问题及解决方案.md
related_outlines: []
---

# 循环引用问题及解决方案

对，你已经在顺着正确的方向想了，我帮你把这个循环引用里 **计数器变化的全过程** 捋顺一遍。

---

### 1. 初始创建

```cpp
auto a = std::make_shared<A>(); // A 对象 + 控制块A(use_count=1)
auto b = std::make_shared<B>(); // B 对象 + 控制块B(use_count=1)
```

此时：

* A 控制块：use\_count = 1（被 `a` 持有）
* B 控制块：use\_count = 1（被 `b` 持有）

---

### 2. 建立双向关系

```cpp
a->bptr = b;  // A 持有一个 shared_ptr<B>
b->aptr = a;  // B 持有一个 shared_ptr<A>
```

此时：

* A 控制块：use\_count = 2（`a` + `b->aptr`）
* B 控制块：use\_count = 2（`b` + `a->bptr`）

---

### 3. main 结束，局部智能指针销毁

当 main 函数返回时：

* `a` 析构 → A 控制块 use\_count 从 2 → 1
* `b` 析构 → B 控制块 use\_count 从 2 → 1

---

### 4. 问题出现

* 现在 A 里还有个 `bptr`，所以 B 的 use\_count = 1
* B 里还有个 `aptr`，所以 A 的 use\_count = 1
* 两个控制块的 use\_count 都不为 0 ⇒ **析构函数不会被调用 ⇒ 两个对象都泄漏**

这就是循环引用的本质：**两个资源互相用 shared\_ptr 持有对方 ⇒ 谁也放不掉谁**。

---

### 5. 解决办法

只要把其中一个方向换成 `std::weak_ptr`：

```cpp
struct B { std::weak_ptr<A> aptr; };
```

那么：

* B → A 不再增加 use\_count，而只是弱引用。
* main 结束时：

  * A 控制块 use\_count=1（只剩 a），销毁 → A 析构。
  * A 析构时销毁 `bptr`，B use\_count 归零 → B 析构。
* 循环成功打破。

---

### 面试时可以这么说

“循环引用出现的原因是：两个对象互相持有对方的 `shared_ptr`，导致双方的控制块引用计数永远不归零。main 结束时，虽然局部的 `shared_ptr` 析构了，但对象内部的 `shared_ptr` 还在持有对方，使得双方资源都无法释放。解决方法是把一边改为 `weak_ptr`，这样它不会增加引用计数，从而保证引用计数能在恰当时机归零。”

---

要不要我帮你画个 **计数器变化的时间线表**（按步骤列出 A、B 的 use\_count 变化），这样在面试时你可以边讲边画，特别直观？

---

## 相关笔记
<!-- 自动生成 -->

暂无相关笔记

