# 生产者-消费者模式的实现

## 面试标准答案（可背诵）

生产者-消费者模式是多线程协作的经典模型，通过**有界缓冲区**解耦生产者和消费者线程。核心要素包括：共享队列、互斥锁保护队列、条件变量同步（队列满时生产者等待，队列空时消费者等待）。实现方式有三种：**条件变量+互斥锁+队列**（最经典，手动控制同步）、**信号量+互斥锁**（P/V操作控制空位和数据）、**阻塞队列封装**（将同步逻辑封装到队列内部）。关键点在于避免虚假唤醒、防止死锁、正确处理队列满和空的边界条件。条件变量方案是工业界首选，既高效又灵活。

---

## 一、问题分析

### 1.1 什么是生产者-消费者模式

生产者-消费者模式是一种经典的多线程设计模式，包含三个核心组件：

```
┌─────────────┐         ┌─────────────┐         ┌─────────────┐
│  生产者线程  │ ──产品──> │  有界缓冲区  │ ──产品──> │  消费者线程  │
│ (Producer)  │         │   (Buffer)  │         │ (Consumer)  │
└─────────────┘         └─────────────┘         └─────────────┘
     可能多个                固定容量                可能多个
```

**核心思想**：
- 生产者负责生产数据并放入缓冲区
- 消费者从缓冲区取出数据进行处理
- 缓冲区解耦了生产和消费的速度差异

### 1.2 应用场景

1. **任务队列**：线程池的任务分发
2. **日志系统**：异步写入日志文件
3. **消息队列**：如RabbitMQ、Kafka的底层模型
4. **数据处理流水线**：实时数据采集与处理
5. **I/O缓冲**：网络数据接收与处理分离

### 1.3 需要解决的问题

| 问题         | 解决方案                 |
| ------------ | ------------------------ |
| **互斥访问** | 使用互斥锁保护共享队列   |
| **队列满**   | 生产者等待，直到有空位   |
| **队列空**   | 消费者等待，直到有数据   |
| **虚假唤醒** | 使用while循环检查条件    |
| **死锁**     | 正确的加锁顺序和唤醒机制 |

---

## 二、方法一：条件变量 + 互斥锁（推荐）

### 2.1 基础实现

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>
#include <chrono>

template<typename T>
class BoundedBuffer {
private:
    std::queue<T> queue_;
    const size_t capacity_;
    std::mutex mtx_;
    std::condition_variable not_full_;   // 队列未满条件
    std::condition_variable not_empty_;  // 队列非空条件
    bool stop_ = false;  // 停止标志

public:
    explicit BoundedBuffer(size_t capacity) : capacity_(capacity) {}
    
    // 生产者：放入数据
    void produce(const T& item) {
        std::unique_lock<std::mutex> lock(mtx_);
        
        // 等待队列不满
        not_full_.wait(lock, [this]() {
            return queue_.size() < capacity_ || stop_;
        });
        
        if (stop_) return;
        
        queue_.push(item);
        std::cout << "Produced: " << item 
                  << " (size: " << queue_.size() << ")" << std::endl;
        
        // 通知消费者：队列非空
        not_empty_.notify_one();
    }
    
    // 消费者：取出数据
    bool consume(T& item) {
        std::unique_lock<std::mutex> lock(mtx_);
        
        // 等待队列非空
        not_empty_.wait(lock, [this]() {
            return !queue_.empty() || stop_;
        });
        
        if (stop_ && queue_.empty()) {
            return false;  // 停止且队列空，返回false
        }
        
        item = queue_.front();
        queue_.pop();
        std::cout << "Consumed: " << item 
                  << " (size: " << queue_.size() << ")" << std::endl;
        
        // 通知生产者：队列不满
        not_full_.notify_one();
        return true;
    }
    
    // 停止缓冲区
    void stop() {
        std::lock_guard<std::mutex> lock(mtx_);
        stop_ = true;
        not_full_.notify_all();
        not_empty_.notify_all();
    }
};

// 生产者函数
void producer(BoundedBuffer<int>& buffer, int id, int count) {
    for (int i = 0; i < count; ++i) {
        int item = id * 1000 + i;
        buffer.produce(item);
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}

// 消费者函数
void consumer(BoundedBuffer<int>& buffer, int id) {
    int item;
    while (buffer.consume(item)) {
        // 处理数据
        std::this_thread::sleep_for(std::chrono::milliseconds(150));
    }
}

int main() {
    BoundedBuffer<int> buffer(5);  // 容量为5的缓冲区
    
    // 创建2个生产者，3个消费者
    std::thread p1(producer, std::ref(buffer), 1, 10);
    std::thread p2(producer, std::ref(buffer), 2, 10);
    
    std::thread c1(consumer, std::ref(buffer), 1);
    std::thread c2(consumer, std::ref(buffer), 2);
    std::thread c3(consumer, std::ref(buffer), 3);
    
    // 等待生产者完成
    p1.join();
    p2.join();
    
    // 停止缓冲区
    buffer.stop();
    
    // 等待消费者完成
    c1.join();
    c2.join();
    c3.join();
    
    return 0;
}
```

### 2.2 核心机制详解

#### 为什么需要两个条件变量？

```cpp
not_full_:   // 队列未满 → 生产者等待这个条件
not_empty_:  // 队列非空 → 消费者等待这个条件
```

**原因**：
- 如果只用一个条件变量，`notify_one()`可能唤醒错误的线程
- 例如：队列满时，生产者放入数据后唤醒另一个生产者（而不是消费者）→ 死锁

#### 等待条件的正确写法

```cpp
// ❌ 错误：可能虚假唤醒
not_full_.wait(lock);
if (queue_.size() < capacity_) {
    // 可能被虚假唤醒，条件不满足
}

// ✅ 正确：使用lambda谓词
not_full_.wait(lock, [this]() {
    return queue_.size() < capacity_ || stop_;
});
// 等价于：
// while (!(queue_.size() < capacity_ || stop_)) {
//     not_full_.wait(lock);
// }
```

#### 完整的执行流程

```
初始状态：队列空，容量5

时间  生产者P1              消费者C1              队列状态
------------------------------------------------------------------------
T1    produce(1)            consume() 等待         []
T2    获取锁                                       []
T3    检查队列未满✅                               []
T4    queue_.push(1)                              [1]
T5    notify_one()                                [1]
T6    释放锁                                       [1]
T7                          被唤醒，获取锁          [1]
T8                          检查队列非空✅          [1]
T9                          item = queue_.front()  [1]
T10                         queue_.pop()           []
T11                         notify_one()           []
T12                         释放锁                 []
```

### 2.3 优缺点分析

**优点**：
- ✅ **标准方案**：C++11标准库，跨平台
- ✅ **高效**：线程阻塞而非忙等待
- ✅ **灵活**：支持多生产者、多消费者
- ✅ **可控**：可以优雅地停止

**缺点**：
- ❌ 代码相对复杂，需要理解条件变量
- ❌ 需要手动管理同步逻辑

---

## 三、方法二：信号量实现（C++20）

### 3.1 实现代码

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <semaphore>
#include <queue>
#include <chrono>

template<typename T>
class SemaphoreBoundedBuffer {
private:
    std::queue<T> queue_;
    const size_t capacity_;
    std::mutex mtx_;  // 保护队列的互斥锁
    
    std::counting_semaphore<> empty_slots_;  // 空位数量
    std::counting_semaphore<> full_slots_;   // 数据数量

public:
    explicit SemaphoreBoundedBuffer(size_t capacity) 
        : capacity_(capacity),
          empty_slots_(capacity),  // 初始有capacity个空位
          full_slots_(0)           // 初始有0个数据
    {}
    
    void produce(const T& item) {
        // P操作：等待空位
        empty_slots_.acquire();
        
        {
            std::lock_guard<std::mutex> lock(mtx_);
            queue_.push(item);
            std::cout << "Produced: " << item 
                      << " (size: " << queue_.size() << ")" << std::endl;
        }
        
        // V操作：增加数据计数
        full_slots_.release();
    }
    
    T consume() {
        // P操作：等待数据
        full_slots_.acquire();
        
        T item;
        {
            std::lock_guard<std::mutex> lock(mtx_);
            item = queue_.front();
            queue_.pop();
            std::cout << "Consumed: " << item 
                      << " (size: " << queue_.size() << ")" << std::endl;
        }
        
        // V操作：增加空位计数
        empty_slots_.release();
        
        return item;
    }
};

void producer_sem(SemaphoreBoundedBuffer<int>& buffer, int id, int count) {
    for (int i = 0; i < count; ++i) {
        int item = id * 1000 + i;
        buffer.produce(item);
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}

void consumer_sem(SemaphoreBoundedBuffer<int>& buffer, int id, int count) {
    for (int i = 0; i < count; ++i) {
        int item = buffer.consume();
        std::this_thread::sleep_for(std::chrono::milliseconds(150));
    }
}

int main() {
    SemaphoreBoundedBuffer<int> buffer(5);
    
    std::thread p1(producer_sem, std::ref(buffer), 1, 10);
    std::thread p2(producer_sem, std::ref(buffer), 2, 10);
    
    std::thread c1(consumer_sem, std::ref(buffer), 1, 10);
    std::thread c2(consumer_sem, std::ref(buffer), 2, 10);
    
    p1.join();
    p2.join();
    c1.join();
    c2.join();
    
    return 0;
}
```

### 3.2 信号量机制详解

#### 两个信号量的作用

```cpp
empty_slots_:  // 记录空位数量（初始 = capacity）
full_slots_:   // 记录数据数量（初始 = 0）

// 生产者逻辑：
empty_slots_.acquire();  // 等待空位（空位-1）
queue_.push(item);
full_slots_.release();   // 增加数据（数据+1）

// 消费者逻辑：
full_slots_.acquire();   // 等待数据（数据-1）
item = queue_.pop();
empty_slots_.release();  // 增加空位（空位+1）
```

#### 为什么还需要互斥锁？

```cpp
// ❌ 错误：信号量不能保护队列操作
empty_slots_.acquire();
queue_.push(item);  // 多个生产者可能同时执行 → 数据竞争！
full_slots_.release();

// ✅ 正确：用互斥锁保护队列
empty_slots_.acquire();
{
    std::lock_guard<std::mutex> lock(mtx_);
    queue_.push(item);  // 互斥访问
}
full_slots_.release();
```

**原因**：
- 信号量控制**数量**（空位和数据的数量）
- 互斥锁保护**访问**（队列的并发修改）

### 3.3 优缺点分析

**优点**：
- ✅ **语义清晰**：P/V操作直观表达资源管理
- ✅ **经典**：操作系统教科书标准实现
- ✅ **高效**：无忙等待

**缺点**：
- ❌ **C++20**：需要较新编译器
- ❌ 仍需互斥锁配合
- ❌ 停止机制较难实现

---

## 四、方法三：封装阻塞队列（工程实践）

### 4.1 完整实现

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>
#include <optional>
#include <chrono>

template<typename T>
class BlockingQueue {
private:
    std::queue<T> queue_;
    const size_t capacity_;
    mutable std::mutex mtx_;
    std::condition_variable not_full_;
    std::condition_variable not_empty_;
    bool closed_ = false;

public:
    explicit BlockingQueue(size_t capacity) : capacity_(capacity) {}
    
    // 禁止拷贝
    BlockingQueue(const BlockingQueue&) = delete;
    BlockingQueue& operator=(const BlockingQueue&) = delete;
    
    // 阻塞式放入（返回false表示队列已关闭）
    bool push(const T& item) {
        std::unique_lock<std::mutex> lock(mtx_);
        
        not_full_.wait(lock, [this]() {
            return queue_.size() < capacity_ || closed_;
        });
        
        if (closed_) return false;
        
        queue_.push(item);
        not_empty_.notify_one();
        return true;
    }
    
    // 带超时的放入
    template<typename Rep, typename Period>
    bool push_for(const T& item, 
                  const std::chrono::duration<Rep, Period>& timeout) {
        std::unique_lock<std::mutex> lock(mtx_);
        
        if (!not_full_.wait_for(lock, timeout, [this]() {
            return queue_.size() < capacity_ || closed_;
        })) {
            return false;  // 超时
        }
        
        if (closed_) return false;
        
        queue_.push(item);
        not_empty_.notify_one();
        return true;
    }
    
    // 阻塞式取出（返回std::nullopt表示队列已关闭且为空）
    std::optional<T> pop() {
        std::unique_lock<std::mutex> lock(mtx_);
        
        not_empty_.wait(lock, [this]() {
            return !queue_.empty() || closed_;
        });
        
        if (closed_ && queue_.empty()) {
            return std::nullopt;
        }
        
        T item = std::move(queue_.front());
        queue_.pop();
        not_full_.notify_one();
        return item;
    }
    
    // 带超时的取出
    template<typename Rep, typename Period>
    std::optional<T> pop_for(const std::chrono::duration<Rep, Period>& timeout) {
        std::unique_lock<std::mutex> lock(mtx_);
        
        if (!not_empty_.wait_for(lock, timeout, [this]() {
            return !queue_.empty() || closed_;
        })) {
            return std::nullopt;  // 超时
        }
        
        if (closed_ && queue_.empty()) {
            return std::nullopt;
        }
        
        T item = std::move(queue_.front());
        queue_.pop();
        not_full_.notify_one();
        return item;
    }
    
    // 非阻塞式尝试放入
    bool try_push(const T& item) {
        std::lock_guard<std::mutex> lock(mtx_);
        
        if (queue_.size() >= capacity_ || closed_) {
            return false;
        }
        
        queue_.push(item);
        not_empty_.notify_one();
        return true;
    }
    
    // 非阻塞式尝试取出
    std::optional<T> try_pop() {
        std::lock_guard<std::mutex> lock(mtx_);
        
        if (queue_.empty()) {
            return std::nullopt;
        }
        
        T item = std::move(queue_.front());
        queue_.pop();
        not_full_.notify_one();
        return item;
    }
    
    // 关闭队列
    void close() {
        std::lock_guard<std::mutex> lock(mtx_);
        closed_ = true;
        not_full_.notify_all();
        not_empty_.notify_all();
    }
    
    // 查询状态
    bool is_closed() const {
        std::lock_guard<std::mutex> lock(mtx_);
        return closed_;
    }
    
    size_t size() const {
        std::lock_guard<std::mutex> lock(mtx_);
        return queue_.size();
    }
    
    bool empty() const {
        std::lock_guard<std::mutex> lock(mtx_);
        return queue_.empty();
    }
};

// 使用示例
void producer_blocking(BlockingQueue<int>& queue, int id, int count) {
    for (int i = 0; i < count; ++i) {
        int item = id * 1000 + i;
        if (!queue.push(item)) {
            std::cout << "Producer " << id << " stopped" << std::endl;
            break;
        }
        std::cout << "Producer " << id << " pushed: " << item << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}

void consumer_blocking(BlockingQueue<int>& queue, int id) {
    while (true) {
        auto item = queue.pop();
        if (!item.has_value()) {
            std::cout << "Consumer " << id << " stopped" << std::endl;
            break;
        }
        std::cout << "Consumer " << id << " popped: " << item.value() << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(150));
    }
}

int main() {
    BlockingQueue<int> queue(5);
    
    std::thread p1(producer_blocking, std::ref(queue), 1, 10);
    std::thread p2(producer_blocking, std::ref(queue), 2, 10);
    
    std::thread c1(consumer_blocking, std::ref(queue), 1);
    std::thread c2(consumer_blocking, std::ref(queue), 2);
    
    p1.join();
    p2.join();
    
    queue.close();
    
    c1.join();
    c2.join();
    
    return 0;
}
```

### 4.2 高级特性

#### 1. 使用std::optional表示可能的空值

```cpp
std::optional<T> pop() {
    // ...
    if (closed_ && queue_.empty()) {
        return std::nullopt;  // 表示无数据
    }
    return item;  // 表示有数据
}

// 使用
auto item = queue.pop();
if (item.has_value()) {
    process(item.value());
}
```

#### 2. 超时机制

```cpp
// 等待最多1秒
auto item = queue.pop_for(std::chrono::seconds(1));
if (!item.has_value()) {
    // 超时或队列关闭
}
```

#### 3. 非阻塞操作

```cpp
// 尝试放入，不等待
if (queue.try_push(item)) {
    // 成功
} else {
    // 队列满或已关闭
}
```

### 4.3 优缺点分析

**优点**：
- ✅ **封装完善**：隐藏同步细节，接口友好
- ✅ **功能丰富**：支持超时、非阻塞、关闭等
- ✅ **异常安全**：使用RAII和std::optional
- ✅ **工程级**：生产环境可直接使用

**缺点**：
- ❌ 代码量较大
- ❌ 需要C++17（std::optional）

---

## 五、性能优化与高级技巧

### 5.1 减少锁竞争

#### 方法1：分段锁（双队列）

```cpp
template<typename T>
class DoubleBufferQueue {
private:
    std::queue<T> produce_queue_;  // 生产者队列
    std::queue<T> consume_queue_;  // 消费者队列
    std::mutex produce_mtx_;
    std::mutex consume_mtx_;
    std::condition_variable cv_;
    
public:
    void push(const T& item) {
        std::lock_guard<std::mutex> lock(produce_mtx_);
        produce_queue_.push(item);
        cv_.notify_one();
    }
    
    T pop() {
        std::unique_lock<std::mutex> lock(consume_mtx_);
        
        if (consume_queue_.empty()) {
            // 交换队列
            {
                std::lock_guard<std::mutex> produce_lock(produce_mtx_);
                cv_.wait(lock, [this]() { return !produce_queue_.empty(); });
                std::swap(produce_queue_, consume_queue_);
            }
        }
        
        T item = consume_queue_.front();
        consume_queue_.pop();
        return item;
    }
};
```

#### 方法2：使用notify_one而非notify_all

```cpp
// ✅ 推荐：只唤醒一个线程
not_empty_.notify_one();

// ❌ 避免：唤醒所有线程（开销大）
not_empty_.notify_all();  // 仅在关闭时使用
```

### 5.2 批量操作

```cpp
template<typename T>
class BatchBlockingQueue {
public:
    // 批量放入
    bool push_batch(const std::vector<T>& items) {
        std::unique_lock<std::mutex> lock(mtx_);
        
        not_full_.wait(lock, [this, &items]() {
            return queue_.size() + items.size() <= capacity_ || closed_;
        });
        
        if (closed_) return false;
        
        for (const auto& item : items) {
            queue_.push(item);
        }
        
        not_empty_.notify_all();  // 唤醒多个消费者
        return true;
    }
    
    // 批量取出
    std::vector<T> pop_batch(size_t max_count) {
        std::unique_lock<std::mutex> lock(mtx_);
        
        not_empty_.wait(lock, [this]() {
            return !queue_.empty() || closed_;
        });
        
        std::vector<T> result;
        size_t count = std::min(max_count, queue_.size());
        
        for (size_t i = 0; i < count; ++i) {
            result.push_back(std::move(queue_.front()));
            queue_.pop();
        }
        
        not_full_.notify_all();
        return result;
    }
};
```

### 5.3 无锁队列（高级）

```cpp
#include <atomic>

template<typename T>
class LockFreeQueue {
private:
    struct Node {
        T data;
        std::atomic<Node*> next;
        Node(const T& val) : data(val), next(nullptr) {}
    };
    
    std::atomic<Node*> head_;
    std::atomic<Node*> tail_;
    
public:
    LockFreeQueue() {
        Node* dummy = new Node(T{});
        head_.store(dummy);
        tail_.store(dummy);
    }
    
    void push(const T& item) {
        Node* new_node = new Node(item);
        Node* old_tail = tail_.load();
        
        while (!tail_.compare_exchange_weak(old_tail, new_node)) {
            // CAS失败，重试
        }
        
        old_tail->next.store(new_node);
    }
    
    bool pop(T& item) {
        Node* old_head = head_.load();
        Node* next = old_head->next.load();
        
        if (next == nullptr) {
            return false;  // 队列空
        }
        
        item = next->data;
        
        if (head_.compare_exchange_strong(old_head, next)) {
            delete old_head;
            return true;
        }
        
        return false;
    }
};
```

**注意**：无锁队列实现复杂，容易出错，实际应用建议使用成熟库（如Boost.Lockfree）。

---

## 六、常见问题与调试

### 6.1 死锁问题

#### 问题1：只用一个条件变量导致死锁

```cpp
// ❌ 错误：只有一个条件变量
std::condition_variable cv;

// 生产者
cv.wait(lock, [this]() { return queue_.size() < capacity_; });
queue_.push(item);
cv.notify_one();  // 可能唤醒另一个生产者！

// 消费者
cv.wait(lock, [this]() { return !queue_.empty(); });
item = queue_.pop();
cv.notify_one();  // 可能唤醒另一个消费者！

// 结果：队列满时，所有生产者都在等待，notify_one唤醒生产者而非消费者 → 死锁
```

**解决**：使用两个条件变量。

#### 问题2：忘记唤醒导致挂起

```cpp
// ❌ 错误：关闭时未唤醒
void stop() {
    closed_ = true;
    // 忘记notify，其他线程永久等待！
}

// ✅ 正确
void stop() {
    {
        std::lock_guard<std::mutex> lock(mtx_);
        closed_ = true;
    }
    not_full_.notify_all();
    not_empty_.notify_all();
}
```

### 6.2 虚假唤醒

```cpp
// ❌ 错误：未正确处理虚假唤醒
not_empty_.wait(lock);
if (!queue_.empty()) {  // 可能被虚假唤醒，队列仍为空
    item = queue_.pop();
}

// ✅ 正确：使用谓词
not_empty_.wait(lock, [this]() {
    return !queue_.empty() || closed_;
});
```

### 6.3 资源泄漏

```cpp
// 问题：消费者退出时队列中还有数据
void consumer() {
    while (!should_stop) {  // 外部标志
        auto item = queue.pop();
        // ...
    }
    // 队列中可能还有未处理的数据！
}

// 解决：消耗完所有数据
void consumer() {
    while (true) {
        auto item = queue.pop();
        if (!item.has_value()) break;  // 队列关闭且空
        // 处理数据
    }
}
```

### 6.4 调试技巧

```cpp
// 1. 添加日志
void produce(const T& item) {
    std::unique_lock<std::mutex> lock(mtx_);
    
    std::cout << "[PRODUCER] Waiting for space, size=" << queue_.size() << std::endl;
    
    not_full_.wait(lock, [this]() {
        return queue_.size() < capacity_ || stop_;
    });
    
    std::cout << "[PRODUCER] Pushing item, size=" << queue_.size() << std::endl;
    
    queue_.push(item);
    not_empty_.notify_one();
}

// 2. 使用断言
void produce(const T& item) {
    std::unique_lock<std::mutex> lock(mtx_);
    
    not_full_.wait(lock, [this]() {
        return queue_.size() < capacity_ || stop_;
    });
    
    assert(queue_.size() < capacity_ || stop_);  // 验证条件
    
    if (!stop_) {
        queue_.push(item);
        assert(queue_.size() <= capacity_);  // 验证不变量
    }
}

// 3. 统计信息
class BlockingQueueWithStats {
private:
    std::atomic<size_t> total_pushed_{0};
    std::atomic<size_t> total_popped_{0};
    std::atomic<size_t> wait_count_{0};
    
public:
    void print_stats() const {
        std::cout << "Pushed: " << total_pushed_ 
                  << ", Popped: " << total_popped_
                  << ", Waits: " << wait_count_ << std::endl;
    }
};
```

---

## 七、实战场景

### 7.1 线程池任务队列

```cpp
class ThreadPool {
private:
    BlockingQueue<std::function<void()>> task_queue_;
    std::vector<std::thread> workers_;
    
public:
    ThreadPool(size_t num_threads, size_t queue_capacity) 
        : task_queue_(queue_capacity) {
        
        for (size_t i = 0; i < num_threads; ++i) {
            workers_.emplace_back([this]() {
                while (true) {
                    auto task = task_queue_.pop();
                    if (!task.has_value()) break;  // 线程池关闭
                    task.value()();  // 执行任务
                }
            });
        }
    }
    
    template<typename F>
    bool submit(F&& task) {
        return task_queue_.push(std::forward<F>(task));
    }
    
    void shutdown() {
        task_queue_.close();
        for (auto& worker : workers_) {
            worker.join();
        }
    }
};

// 使用
ThreadPool pool(4, 100);  // 4个线程，队列容量100
pool.submit([]() { std::cout << "Task 1" << std::endl; });
pool.submit([]() { std::cout << "Task 2" << std::endl; });
pool.shutdown();
```

### 7.2 日志系统

```cpp
class AsyncLogger {
private:
    BlockingQueue<std::string> log_queue_;
    std::thread writer_thread_;
    std::ofstream log_file_;
    
public:
    AsyncLogger(const std::string& filename, size_t queue_capacity)
        : log_queue_(queue_capacity),
          log_file_(filename, std::ios::app) {
        
        writer_thread_ = std::thread([this]() {
            while (true) {
                auto log = log_queue_.pop();
                if (!log.has_value()) break;
                log_file_ << log.value() << std::flush;
            }
        });
    }
    
    void log(const std::string& message) {
        log_queue_.push(message + "\n");
    }
    
    ~AsyncLogger() {
        log_queue_.close();
        writer_thread_.join();
        log_file_.close();
    }
};

// 使用
AsyncLogger logger("app.log", 1000);
logger.log("Application started");
logger.log("Processing request");
```

### 7.3 数据处理流水线

```cpp
class Pipeline {
private:
    BlockingQueue<RawData> raw_queue_;
    BlockingQueue<ProcessedData> processed_queue_;
    std::vector<std::thread> processors_;
    
public:
    Pipeline(size_t num_processors) 
        : raw_queue_(100), processed_queue_(100) {
        
        // 启动处理线程
        for (size_t i = 0; i < num_processors; ++i) {
            processors_.emplace_back([this]() {
                while (true) {
                    auto raw = raw_queue_.pop();
                    if (!raw.has_value()) break;
                    
                    // 处理数据
                    ProcessedData processed = process(raw.value());
                    processed_queue_.push(processed);
                }
            });
        }
    }
    
    void input(const RawData& data) {
        raw_queue_.push(data);
    }
    
    std::optional<ProcessedData> output() {
        return processed_queue_.pop();
    }
    
    void shutdown() {
        raw_queue_.close();
        for (auto& t : processors_) {
            t.join();
        }
        processed_queue_.close();
    }
};
```

---

## 八、性能对比与选择建议

### 8.1 性能对比

| 实现方式        | 代码复杂度 | 灵活性 | 性能  | 功能丰富度 | 推荐度 |
| --------------- | ---------- | ------ | ----- | ---------- | ------ |
| 条件变量+互斥锁 | ⭐⭐⭐ 中     | ⭐⭐⭐⭐⭐  | ⭐⭐⭐⭐  | ⭐⭐⭐        | ⭐⭐⭐⭐⭐  |
| 信号量+互斥锁   | ⭐⭐ 简单    | ⭐⭐⭐    | ⭐⭐⭐⭐  | ⭐⭐         | ⭐⭐⭐⭐   |
| 封装阻塞队列    | ⭐⭐⭐⭐ 复杂  | ⭐⭐⭐⭐⭐  | ⭐⭐⭐⭐  | ⭐⭐⭐⭐⭐      | ⭐⭐⭐⭐⭐  |
| 无锁队列        | ⭐⭐⭐⭐⭐      | ⭐⭐     | ⭐⭐⭐⭐⭐ | ⭐⭐⭐        | ⭐⭐⭐    |

### 8.2 选择建议

```cpp
// 场景1：面试 → 条件变量+互斥锁
// 理由：经典、标准、易于讲解

// 场景2：C++20项目 → 信号量方案
// 理由：简洁、语义清晰

// 场景3：生产环境 → 封装阻塞队列
// 理由：功能完善、易于使用

// 场景4：超高性能要求 → 无锁队列（慎用）
// 理由：最高性能，但实现复杂易错
```

---

## 九、总结与最佳实践

### 9.1 核心要点

1. **同步机制**：
   - 互斥锁保护队列访问
   - 条件变量实现等待/唤醒
   - 两个条件变量避免死锁

2. **边界条件**：
   - 队列满：生产者等待
   - 队列空：消费者等待
   - 关闭：所有线程优雅退出

3. **虚假唤醒**：
   - 使用lambda谓词
   - 等价于while循环检查条件

4. **资源管理**：
   - 使用RAII（unique_lock、lock_guard）
   - 正确处理异常安全

### 9.2 代码模板（推荐背诵）

```cpp
template<typename T>
class BoundedBuffer {
private:
    std::queue<T> queue_;
    const size_t capacity_;
    std::mutex mtx_;
    std::condition_variable not_full_;
    std::condition_variable not_empty_;
    bool stop_ = false;

public:
    explicit BoundedBuffer(size_t cap) : capacity_(cap) {}
    
    void produce(const T& item) {
        std::unique_lock<std::mutex> lock(mtx_);
        not_full_.wait(lock, [this]() {
            return queue_.size() < capacity_ || stop_;
        });
        if (stop_) return;
        
        queue_.push(item);
        not_empty_.notify_one();
    }
    
    bool consume(T& item) {
        std::unique_lock<std::mutex> lock(mtx_);
        not_empty_.wait(lock, [this]() {
            return !queue_.empty() || stop_;
        });
        if (stop_ && queue_.empty()) return false;
        
        item = queue_.front();
        queue_.pop();
        not_full_.notify_one();
        return true;
    }
    
    void stop() {
        std::lock_guard<std::mutex> lock(mtx_);
        stop_ = true;
        not_full_.notify_all();
        not_empty_.notify_all();
    }
};
```

### 9.3 检查清单

- [ ] 是否使用两个条件变量？
- [ ] 等待条件是否用lambda谓词？
- [ ] 是否正确处理关闭逻辑？
- [ ] 是否在关闭时唤醒所有线程？
- [ ] 队列满/空时是否正确等待？
- [ ] 是否避免了死锁和虚假唤醒？
- [ ] 是否使用RAII管理锁？

### 9.4 面试延伸问题

**Q1: 为什么需要两个条件变量？**
A: 避免唤醒错误的线程导致死锁。`not_full_`确保只唤醒生产者，`not_empty_`确保只唤醒消费者。

**Q2: 如何处理虚假唤醒？**
A: 使用`wait`的谓词形式，内部是while循环检查条件。

**Q3: 信号量方案为什么还需要互斥锁？**
A: 信号量控制资源数量，互斥锁保护队列的并发修改，两者职责不同。

**Q4: 如何优雅地停止？**
A: 设置`stop`标志，唤醒所有等待线程，让它们检查标志后退出。

**Q5: 能否用一个条件变量配合`notify_all`？**
A: 可以，但效率低。每次唤醒所有线程，造成惊群效应。

---

## 参考资源

- C++ Concurrency in Action (2nd Edition) - Anthony Williams
- Operating System Concepts (10th Edition) - Silberschatz
- cppreference.com - Thread support library
- Java并发编程实战（Producer-Consumer模式是跨语言通用的）


