# 专家容量限制如何设置？

## 面试标准答案

专家容量限制防止单个专家过载，设置为：`capacity = (total_tokens / num_experts) × capacity_factor`，其中capacity_factor通常为1.0-1.5。1.0表示完全均匀，1.25允许25%波动，1.5允许50%波动。较小的factor导致更多token溢出被丢弃，但负载更均衡；较大的factor容纳更多波动，但可能导致不均衡。实践中常用1.25，通过监控溢出率动态调整。推理时可设置更大factor以避免丢弃token影响质量。

---

## 详细讲解

### 容量计算

```python
def calculate_expert_capacity(
    num_tokens,
    num_experts,
    capacity_factor=1.25,
    num_selected_experts=2  # Top-K的K
):
    # 平均每个专家期望处理的tokens
    tokens_per_expert = (num_tokens * num_selected_experts) / num_experts
    
    # 加上buffer
    capacity = int(tokens_per_expert * capacity_factor)
    
    return capacity

# 示例
capacity = calculate_expert_capacity(
    num_tokens=1024,
    num_experts=8,
    capacity_factor=1.25,
    num_selected_experts=2
)
# = (1024 * 2 / 8) * 1.25 = 320
```

### 溢出处理

```python
def route_with_capacity_limit(tokens, expert_assignments, capacity):
    routed = defaultdict(list)
    overflow = []
    
    for token, expert_ids in zip(tokens, expert_assignments):
        assigned = False
        for expert_id in expert_ids:  # Top-K顺序尝试
            if len(routed[expert_id]) < capacity:
                routed[expert_id].append(token)
                assigned = True
                break
        
        if not assigned:
            # 所有候选专家都满了
            overflow.append(token)
            # 选项1: 丢弃 (训练)
            # 选项2: 分配给最不满的专家 (推理)
            # 选项3: 使用默认专家
    
    return routed, overflow
```

### Factor选择

```python
# 训练
capacity_factor = 1.0 - 1.25
# 严格限制，鼓励均衡，少量overflow可接受

# 推理
capacity_factor = 1.5 - 2.0
# 宽松限制，避免丢弃影响质量

# 动态调整
if overflow_rate > 0.05:  # 5%溢出
    capacity_factor *= 1.1  # 增加10%
```

### 监控指标

```python
metrics = {
    'expert_utilization': [0.95, 0.87, 1.0, 0.65, ...],  # 每个专家
    'overflow_rate': 0.03,  # 3%溢出
    'load_imbalance': max_load / avg_load = 1.15,
}

# 目标
# - utilization: 所有专家 > 0.7
# - overflow_rate: < 0.05
# - load_imbalance: < 1.3
```

合理的容量设置平衡质量、效率和负载均衡。

