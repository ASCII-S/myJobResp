# 熟悉操作系统原理 面试大纲

## 面试目标
全面考察应届生对操作系统核心原理的理解深度，从基础概念到系统设计，从理论知识到实践应用，确保候选人具备扎实的操作系统理论基础和系统思维能力。

## 面试时长
建议总时长：80-100分钟

## 考核维度权重
- 操作系统基础概念：10%
- 进程与线程管理：18%
- 内存管理：18%
- 文件系统：12%
- I/O系统与设备管理：10%
- 进程间通信与同步：15%
- 死锁问题：8%
- Linux系统实践：5%
- 综合分析能力：4%

---

## 第一部分：操作系统基础概念（10-12分钟）

### 1.1 操作系统概述
**考核要点：**
- 操作系统的定义和作用
- 操作系统的演进历史
- 操作系统的结构设计

**核心问题：**
1. **操作系统的本质**
   - 什么是操作系统？操作系统的主要功能是什么？
   - 操作系统在计算机系统中的位置和作用
   - [内核态和用户态的区别，为什么需要这种划分？](../notes/操作系统/内核态和用户态的区别，为什么需要这种划分？.md)
   - [系统调用的概念和实现机制](../notes/操作系统/系统调用的概念和实现机制.md)
   - 中断和异常的区别，中断处理流程是怎样的？

2. **操作系统的类型和结构**
   - 批处理系统、分时系统、实时系统的特点和区别
   - 单体内核、微内核、混合内核的优缺点对比
   - Linux采用的是什么内核架构？为什么？
   - 操作系统的模块化设计原则
   - 虚拟化技术在现代操作系统中的应用

3. **系统调用机制**
   - 系统调用与普通函数调用的区别
   - 系统调用的实现过程（从用户态到内核态的切换）
   - 系统调用的开销来自哪里？
   - 常见的系统调用有哪些？（如`fork`、`exec`、`read`、`write`）
   - 如何查看一个程序调用了哪些系统调用？（`strace`工具）

### 1.2 操作系统的基本概念
**考核要点：**
- 并发与并行
- 同步与异步
- 临界区和竞态条件

**核心问题：**
1. **并发基础概念**
   - 并发和并行的区别是什么？
   - 什么是原子操作？为什么需要原子操作？
   - 临界区（Critical Section）是什么？
   - 竞态条件（Race Condition）如何产生？举例说明
   - 如何保证临界区的互斥访问？

2. **同步与异步**
   - 同步操作和异步操作的区别
   - 阻塞和非阻塞的概念
   - 同步I/O和异步I/O的区别
   - 为什么异步编程可以提高性能？

---

## 第二部分：进程与线程管理（18-22分钟）

### 2.1 进程基础
**考核要点：**
- 进程的概念和特征
- 进程的状态和转换
- 进程控制块（PCB）

**核心问题：**
1. **进程的本质**
   - 什么是进程？进程和程序的区别是什么？
   - 进程由哪些部分组成？（代码段、数据段、堆、栈等）
   - 进程控制块（PCB）存储哪些信息？
   - 进程的地址空间是如何组织的？
   - 进程的虚拟地址空间和物理地址空间的关系

2. **进程的状态管理**
   - 进程有哪些基本状态？（就绪、运行、阻塞）
   - 进程状态之间如何转换？
   - 什么情况会导致进程从运行态转为阻塞态？
   - 僵尸进程（Zombie Process）和孤儿进程（Orphan Process）是什么？如何避免？
   - 进程的创建和终止过程

3. **进程的创建和执行**
   - `fork()`系统调用的工作原理
   - `fork()`之后父子进程的执行顺序如何确定？
   - `fork()`返回值的意义（父进程返回子进程PID，子进程返回0）
   - 写时复制（Copy-on-Write, COW）技术的原理和优势
   - `exec`系列函数的作用，它们和`fork()`有什么区别？
   - `vfork()`与`fork()`的区别

### 2.2 线程管理
**考核要点：**
- 线程的概念和特点
- 线程与进程的关系
- 线程的实现方式

**核心问题：**
1. **线程的基本概念**
   - 什么是线程？为什么需要线程？
   - 线程和进程的区别和联系
   - 同一进程内的线程共享哪些资源？各自独占哪些资源？
   - 线程的优势是什么？（轻量级、共享资源、切换快）
   - 多线程编程的主要挑战是什么？

2. **线程的实现模型**
   - 用户级线程和内核级线程的区别
   - 多对一、一对一、多对多线程模型的特点
   - Linux中的线程是如何实现的？（轻量级进程LWP）
   - 协程（Coroutine）和线程的区别
   - 线程池的设计思想和优势

3. **线程的上下文切换**
   - 什么是上下文切换？包括哪些内容？
   - 进程切换和线程切换的开销对比
   - 如何减少上下文切换的开销？
   - TLB（Translation Lookaside Buffer）在上下文切换中的作用
   - 上下文切换对缓存的影响

### 2.3 CPU调度
**考核要点：**
- 调度的目标和原则
- 常见的调度算法
- 实时调度和多级反馈队列

**核心问题：**
1. **调度的基本概念**
   - CPU调度的目标是什么？（CPU利用率、吞吐量、响应时间、周转时间、公平性）
   - 抢占式调度和非抢占式调度的区别
   - 什么是时间片？时间片的大小如何影响系统性能？
   - 调度的时机有哪些？
   - I/O密集型进程和CPU密集型进程在调度上有什么不同考虑？

2. **经典调度算法**
   - 先来先服务（FCFS）算法的特点和问题
   - 最短作业优先（SJF）算法的优缺点
   - 优先级调度算法及其可能的问题（饥饿问题）
   - 轮转调度（Round Robin, RR）算法的工作原理
   - 多级反馈队列调度算法的设计思想
   - 如何在不知道进程执行时间的情况下近似实现SJF？

3. **现代操作系统的调度**
   - Linux的CFS（完全公平调度器）的基本原理
   - 实时调度策略（SCHED_FIFO、SCHED_RR）的特点
   - 多核处理器的负载均衡问题
   - CPU亲和性（CPU Affinity）的概念和作用
   - 优先级反转问题及其解决方案

---

## 第三部分：内存管理（18-22分钟）

### 3.1 内存管理基础
**考核要点：**
- 内存管理的目标
- 地址空间的概念
- 内存分配策略

**核心问题：**
1. **地址空间和地址映射**
   - 物理地址、逻辑地址、虚拟地址的区别
   - 为什么需要虚拟内存？虚拟内存有什么优势？
   - 地址重定位的概念和实现方式
   - 内存管理单元（MMU）的作用
   - 基址寄存器和界限寄存器的作用

2. **内存分配方式**
   - 连续内存分配的几种策略（首次适应、最佳适应、最坏适应）
   - 内部碎片和外部碎片的区别
   - 如何解决外部碎片问题？（内存紧缩、分页）
   - 伙伴系统（Buddy System）的原理和优势
   - slab分配器的设计思想

3. **内存保护和共享**
   - 操作系统如何实现内存保护？
   - 共享内存的实现机制
   - 内存映射文件（mmap）的原理和应用
   - 写时复制（COW）技术在内存管理中的应用

### 3.2 分页机制
**考核要点：**
- 分页的基本原理
- 页表的结构和实现
- 地址转换过程

**核心问题：**
1. **分页的基本概念**
   - 分页机制解决了什么问题？
   - 页（Page）和页框（Frame）的概念
   - 典型的页大小是多少？为什么选择这个大小？
   - 分页如何解决外部碎片问题？
   - 分页带来了什么新问题？（内部碎片、页表空间开销）

2. **页表结构**
   - 单级页表的结构和问题（页表太大）
   - 多级页表的设计思想和优势
   - x86-64架构的四级页表结构
   - 页表项（PTE）包含哪些信息？（物理页号、有效位、修改位、访问位、保护位）
   - 快表（TLB）的作用和工作原理
   - TLB命中率对系统性能的影响

3. **地址转换过程**
   - 虚拟地址如何转换为物理地址？
   - 详细描述带TLB的地址转换流程
   - TLB未命中时的处理过程
   - 页故障（Page Fault）的处理流程
   - 大页（Huge Page）技术的优势和应用场景

### 3.3 虚拟内存和页面置换
**考核要点：**
- 虚拟内存的实现
- 页面置换算法
- 工作集和局部性原理

**核心问题：**
1. **虚拟内存机制**
   - 虚拟内存允许程序使用超过物理内存的空间，是如何实现的？
   - 请求分页（Demand Paging）的工作原理
   - 页面置换发生在什么时候？
   - 预先调页和请求调页的区别
   - 交换空间（Swap Space）的作用

2. **页面置换算法**
   - 最优页面置换算法（OPT）的原理（理论最优）
   - 先进先出（FIFO）算法的特点和Belady异常
   - 最近最少使用（LRU）算法的实现和优势
   - 时钟算法（Clock Algorithm）如何近似实现LRU
   - 最不常用（LFU）算法的特点
   - 如何在实际系统中高效实现LRU？（链表+哈希表）

3. **局部性和工作集**
   - 时间局部性和空间局部性的概念
   - 工作集（Working Set）模型的含义
   - 缺页率和常驻集大小的关系
   - 抖动（Thrashing）是什么？如何避免？
   - 内存压缩技术的原理和应用

### 3.4 分段机制
**考核要点：**
- 分段的概念
- 分段与分页的区别
- 段页式内存管理

**核心问题：**
1. **分段机制**
   - 分段是什么？与分页有什么区别？
   - 分段的优势（符合程序的逻辑结构、便于共享和保护）
   - 分段的问题（外部碎片）
   - 段表的结构和作用
   - 段式地址如何转换为物理地址？

2. **段页式管理**
   - 段页式内存管理的设计思想
   - 段页式管理如何结合分段和分页的优势？
   - 段页式地址转换的完整过程
   - x86架构的分段机制
   - Linux为什么几乎不使用分段？

---

## 第四部分：文件系统（12-15分钟）

### 4.1 文件系统基础
**考核要点：**
- 文件和目录的概念
- 文件系统的结构
- 文件的逻辑和物理结构

**核心问题：**
1. **文件的基本概念**
   - 什么是文件？文件的属性有哪些？
   - 文件的类型（普通文件、目录文件、设备文件、链接文件等）
   - 文件描述符（File Descriptor）是什么？
   - 文件的访问方式（顺序访问、直接访问、索引访问）
   - 文件的打开和关闭过程

2. **目录结构**
   - 目录的作用是什么？
   - 单级目录、两级目录、树形目录的演进
   - 绝对路径和相对路径的区别
   - 当前工作目录的概念
   - 硬链接和符号链接（软链接）的区别

3. **文件系统的结构**
   - 文件系统的层次结构（用户接口层、文件组织层、存储管理层、I/O层）
   - 文件控制块（FCB）或inode包含哪些信息？
   - 文件系统的挂载（mount）是什么意思？
   - 虚拟文件系统（VFS）的作用和设计
   - 文件系统的元数据包括哪些？

### 4.2 文件的存储和分配
**考核要点：**
- 磁盘的物理结构
- 文件的空间分配方法
- 空闲空间管理

**核心问题：**
1. **磁盘结构和性能**
   - 磁盘的物理结构（盘片、磁道、扇区、柱面）
   - 磁盘访问时间的组成（寻道时间、旋转延迟、传输时间）
   - 如何优化磁盘访问性能？
   - SSD和HDD的区别，对文件系统设计的影响
   - 磁盘调度算法（FCFS、SSTF、SCAN、C-SCAN）

2. **文件的空间分配**
   - 连续分配的优缺点
   - 链接分配（隐式链接和显式链接FAT）的特点
   - 索引分配的原理（类似分页的多级索引）
   - Unix/Linux的inode和数据块分配策略
   - 多级索引如何支持大文件？（直接块、一级间接块、二级间接块）

3. **空闲空间管理**
   - 位图法管理空闲空间的优缺点
   - 空闲块链表的实现
   - 成组链接法的原理
   - 文件系统的碎片整理
   - 日志文件系统的设计思想

### 4.3 文件系统实例
**考核要点：**
- Linux的ext系列文件系统
- 日志文件系统
- 文件系统的可靠性

**核心问题：**
1. **Linux文件系统**
   - ext2、ext3、ext4的演进和主要改进
   - inode和数据块的关系
   - 如何查看文件的inode号？（`ls -i`命令）
   - 为什么删除大文件后空间没有释放？（文件被进程占用）
   - Linux的一切皆文件思想

2. **文件系统的可靠性**
   - 什么是文件系统的一致性？
   - 日志（Journaling）如何提高文件系统的可靠性？
   - 文件系统检查工具（fsck）的作用
   - 如何保证文件系统在断电后的数据完整性？
   - 写时复制（COW）文件系统的特点（如Btrfs、ZFS）

---

## 第五部分：I/O系统与设备管理（10-12分钟）

### 5.1 I/O系统基础
**考核要点：**
- I/O设备的分类
- I/O控制方式
- I/O软件的层次结构

**核心问题：**
1. **I/O设备和控制**
   - I/O设备的分类（块设备和字符设备）
   - I/O端口和I/O内存映射的区别
   - 什么是DMA？DMA如何减少CPU的参与？
   - 中断驱动的I/O工作原理
   - 轮询（Polling）和中断（Interrupt）方式的对比

2. **I/O软件层次**
   - I/O软件的层次结构（硬件、中断处理程序、设备驱动、设备无关软件、用户层）
   - 设备驱动程序的作用
   - 缓冲和缓存在I/O中的作用
   - 假脱机（Spooling）技术的原理和应用
   - 设备的独占、共享和虚拟化

3. **I/O调度**
   - 为什么需要I/O调度？
   - 电梯算法（SCAN）的工作原理
   - Linux的I/O调度器（CFQ、Deadline、NOOP）
   - SSD的I/O调度策略与HDD有何不同？

### 5.2 I/O模型
**考核要点：**
- 阻塞和非阻塞I/O
- 同步和异步I/O
- I/O多路复用

**核心问题：**
1. **I/O模型对比**
   - 五种I/O模型：阻塞I/O、非阻塞I/O、I/O多路复用、信号驱动I/O、异步I/O
   - 同步I/O和异步I/O的本质区别
   - 阻塞和非阻塞的区别
   - 为什么非阻塞I/O通常需要配合轮询或事件通知？

2. **I/O多路复用**
   - select、poll、epoll的工作原理和区别
   - epoll的ET（边缘触发）和LT（水平触发）模式
   - epoll为什么比select性能更好？
   - 如何使用epoll构建高性能服务器？
   - kqueue、IOCP等其他平台的I/O多路复用机制

3. **异步I/O**
   - Linux的异步I/O（AIO）机制
   - io_uring的新特性和优势
   - 异步I/O与多路复用的区别
   - 回调地狱问题及解决方案（协程）

---

## 第六部分：进程间通信与同步（15-18分钟）

### 6.1 进程间通信（IPC）
**考核要点：**
- IPC的基本方式
- 管道和消息队列
- 共享内存和信号量

**核心问题：**
1. **IPC基础**
   - 为什么需要进程间通信？
   - 进程间通信的主要方式有哪些？
   - 如何选择合适的IPC机制？
   - IPC的性能对比

2. **管道（Pipe）**
   - 匿名管道的工作原理和使用场景
   - 命名管道（FIFO）与匿名管道的区别
   - 管道的容量限制是多少？
   - 管道是半双工还是全双工？
   - Shell中的管道操作符`|`是如何实现的？
   - 管道的读写特性（阻塞行为）

3. **消息队列**
   - 消息队列的工作原理
   - 消息队列与管道的区别
   - System V消息队列和POSIX消息队列
   - 消息队列的优势和局限
   - 消息队列如何保证消息的顺序性？

4. **共享内存**
   - 共享内存是最快的IPC方式，为什么？
   - 共享内存如何创建和使用？
   - 共享内存需要配合哪些同步机制？
   - mmap在IPC中的应用
   - 共享内存的一致性问题

5. **信号（Signal）**
   - 信号的概念和作用
   - 常见的信号类型（SIGINT、SIGTERM、SIGKILL、SIGSEGV等）
   - 信号处理的三种方式（默认、忽略、自定义处理）
   - 信号的可靠性问题
   - SIGKILL和SIGSTOP为什么不能被捕获？

### 6.2 进程同步
**考核要点：**
- 临界区问题
- 互斥锁和信号量
- 经典同步问题

**核心问题：**
1. **同步的基本概念**
   - 为什么需要进程同步？
   - 临界区的访问规则（互斥、进步、有限等待）
   - 忙等待（Busy Waiting）的问题
   - 什么是自旋锁？适用场景是什么？

2. **互斥锁（Mutex）**
   - 互斥锁的实现原理
   - 如何使用硬件指令实现互斥？（Test-and-Set、Compare-and-Swap）
   - Peterson算法的原理
   - 互斥锁与信号量的区别
   - 死锁的产生条件和预防策略

3. **信号量（Semaphore）**
   - 信号量的概念和工作原理
   - P操作（wait）和V操作（signal）的语义
   - 二元信号量和计数信号量的区别
   - 如何用信号量实现互斥和同步？
   - 信号量的应用场景

4. **经典同步问题**
   - 生产者-消费者问题的解决方案
   - 读者-写者问题的多种变体
   - 哲学家就餐问题及其解决策略
   - 理发师问题的分析
   - 这些问题对实际编程的启示

### 6.3 并发控制高级主题
**考核要点：**
- 管程（Monitor）
- 条件变量
- 屏障和读写锁

**核心问题：**
1. **管程机制**
   - 管程是什么？如何简化并发编程？
   - 管程与信号量的区别
   - 管程的实现原理
   - 条件变量在管程中的作用
   - Java的synchronized和C++的std::mutex是管程吗？

2. **条件变量**
   - 条件变量的工作原理
   - wait和signal操作的语义
   - 为什么条件变量需要配合锁使用？
   - 虚假唤醒（Spurious Wakeup）问题
   - 如何避免死锁和优先级反转？

3. **其他同步原语**
   - 读写锁的设计和使用场景
   - 屏障（Barrier）的作用
   - 事件（Event）的使用
   - RCU（Read-Copy-Update）机制的原理

---

## 第七部分：死锁（8-10分钟）

### 7.1 死锁的基本概念
**考核要点：**
- 死锁的定义
- 死锁产生的条件
- 资源分配图

**核心问题：**
1. **死锁的本质**
   - 什么是死锁？
   - 死锁产生的四个必要条件（互斥、占有并等待、不可抢占、循环等待）
   - 资源分配图如何表示死锁？
   - 死锁与饥饿的区别
   - 活锁是什么？

2. **死锁的例子**
   - 举例说明死锁的产生过程
   - 两个线程互相等待资源的典型死锁场景
   - 哲学家就餐问题中的死锁
   - 数据库事务中的死锁

### 7.2 死锁的处理
**考核要点：**
- 死锁预防
- 死锁避免
- 死锁检测和恢复

**核心问题：**
1. **死锁预防**
   - 如何通过破坏死锁的四个必要条件来预防死锁？
   - 资源的有序分配策略
   - 一次性分配所有资源的优缺点
   - 预防死锁的代价是什么？

2. **死锁避免**
   - 安全状态和不安全状态的概念
   - 银行家算法的原理和实现
   - 银行家算法的局限性
   - 死锁避免与死锁预防的区别

3. **死锁检测和恢复**
   - 如何检测死锁的存在？
   - 资源分配图的环检测算法
   - 死锁恢复的几种方法（终止进程、抢占资源）
   - 如何选择被终止的进程？
   - 操作系统是否检测死锁？

### 7.3 死锁的实践
**考核要点：**
- 实际编程中的死锁预防
- 死锁调试工具
- 死锁案例分析

**核心问题：**
1. **避免死锁的编程实践**
   - 如何在多线程程序中避免死锁？
   - 锁的顺序性原则
   - 尝试锁（trylock）的使用
   - 超时机制的作用
   - std::lock如何同时锁多个锁？

2. **死锁的调试**
   - 如何检测程序中的死锁？
   - gdb调试死锁的方法
   - 死锁分析工具的使用
   - 日志和监控在死锁排查中的作用

---

## 第八部分：Linux系统实践（5-8分钟）

### 8.1 Linux基础命令和工具
**考核要点：**
- 进程管理命令
- 内存和性能监控
- 系统调用跟踪

**核心问题：**
1. **进程管理**
   - 如何查看系统中的进程？（ps、top、htop命令）
   - 如何查看进程的详细信息？（/proc文件系统）
   - 如何终止一个进程？（kill命令和信号）
   - 如何查看进程的父子关系？（pstree命令）
   - 后台运行进程的方法（&、nohup、screen、tmux）

2. **性能监控和分析**
   - 如何查看CPU使用率？（top、vmstat、mpstat）
   - 如何查看内存使用情况？（free、vmstat）
   - 如何查看磁盘I/O？（iostat、iotop）
   - 如何分析系统的性能瓶颈？
   - perf工具的使用

3. **系统调用和调试**
   - 如何跟踪系统调用？（strace命令）
   - 如何查看程序的动态链接库？（ldd命令）
   - 如何使用gdb调试多线程程序？
   - core dump文件的生成和分析

### 8.2 Linux内存管理实践
**考核要点：**
- 虚拟内存的查看
- OOM Killer机制
- 内存泄漏检测

**核心问题：**
1. **内存监控**
   - 如何查看进程的内存映射？（/proc/[pid]/maps）
   - VSS、RSS、PSS的区别
   - swap使用情况的查看和影响
   - 内存碎片的查看
   - 大页内存的配置和使用

2. **OOM Killer**
   - OOM（Out of Memory）Killer是什么？
   - OOM Killer如何选择要杀死的进程？
   - 如何避免重要进程被OOM Killer杀死？
   - 如何查看OOM日志？
   - cgroup在内存隔离中的作用

---

## 第九部分：综合分析和实践（5-8分钟）

### 9.1 系统性能分析
**考核要点：**
- 性能瓶颈识别
- 系统优化策略
- 综合问题分析

**核心问题：**
1. **性能问题诊断**
   - 如何分析一个系统运行缓慢的原因？
   - CPU密集型、I/O密集型、内存密集型问题的特征
   - 如何定位性能瓶颈？
   - 缓存命中率对性能的影响
   - NUMA架构对性能的影响

2. **系统优化**
   - 进程优先级和nice值的调整
   - I/O调度器的选择和调优
   - 文件系统的选择和配置
   - 内存管理参数的调优
   - 网络参数的优化

### 9.2 综合问题分析

**场景分析题：**

1. **系统卡顿问题**
   - 场景：Linux服务器运行一段时间后变得非常卡顿，响应缓慢
   - 分析：可能的原因有哪些？（内存不足、swap频繁、CPU负载高、I/O瓶颈）
   - 如何排查和解决？

2. **进程僵死问题**
   - 场景：发现系统中有大量僵尸进程
   - 分析：僵尸进程是如何产生的？
   - 如何清理僵尸进程？如何预防？

3. **内存泄漏问题**
   - 场景：程序运行时间越长，内存占用越多，最终导致OOM
   - 分析：如何诊断是否为内存泄漏？
   - 使用什么工具检测？（valgrind、AddressSanitizer）
   - 如何修复内存泄漏？

4. **多进程/线程性能问题**
   - 场景：多线程程序的性能不如预期，甚至比单线程还慢
   - 分析：可能的原因（锁竞争、上下文切换、缓存失效、伪共享）
   - 如何优化？

5. **文件系统问题**
   - 场景：磁盘空间显示已满，但删除文件后空间没有释放
   - 分析：可能的原因（文件被进程占用、硬链接、inode耗尽）
   - 如何排查和解决？

### 9.3 设计类问题

**系统设计题：**

1. **设计一个简单的进程调度器**
   - 要求：支持多种调度算法，可以动态切换
   - 考虑：数据结构选择、调度时机、优先级管理

2. **设计一个内存分配器**
   - 要求：支持malloc和free操作，减少内存碎片
   - 考虑：分配策略、空闲链表管理、性能优化

3. **设计一个文件缓存系统**
   - 要求：提高文件访问性能，支持LRU淘汰策略
   - 考虑：缓存替换算法、一致性保证、并发访问

---

## 面试评分标准

### 优秀（90-100分）
- 对操作系统的核心概念有深入理解，能够解释底层实现原理
- 熟练掌握进程、线程、内存管理等关键知识点
- 能够分析复杂的并发和同步问题，提出有效的解决方案
- 对Linux系统有实际使用经验，熟悉常用工具和命令
- 具备系统性思维，能够分析和优化系统性能
- 能够将理论知识应用于实际问题解决

### 良好（80-89分）
- 理解操作系统的基本原理和核心概念
- 掌握进程管理、内存管理、文件系统的基础知识
- 了解常见的同步机制和IPC方式
- 能够解释基本的系统调用和I/O模型
- 对Linux系统有一定了解，能够使用基本命令
- 能够分析简单的系统问题

### 合格（70-79分）
- 了解操作系统的基本概念和功能
- 理解进程和线程的区别
- 知道虚拟内存和分页机制的基本原理
- 了解文件系统的基本结构
- 对进程同步和IPC有基本认识
- 能够回答基础的概念性问题

### 不合格（<70分）
- 对操作系统的基本概念理解不清
- 无法解释进程、线程、内存管理等核心知识
- 缺乏系统思维和问题分析能力
- 对Linux系统缺乏基本了解
- 无法应用理论知识解决实际问题

---

## 面试官注意事项

1. **循序渐进**：从基础概念开始，逐步深入到实现细节和应用场景
2. **理论与实践结合**：既考察理论知识，也关注实际系统使用经验
3. **重视理解深度**：不要满足于表面的定义，要深入追问实现原理
4. **关注思维方式**：考察候选人的系统性思维和问题分析能力
5. **适度引导**：给予必要的提示，观察候选人的学习和推理能力
6. **场景化提问**：通过实际场景问题考察综合应用能力
7. **注意难度调节**：根据候选人的表现调整问题难度

## 常见追问方向

- 对于基本概念，追问实现原理和设计原因
- 对于算法和策略，追问性能分析和适用场景
- 结合实际系统（如Linux），询问具体实现和差异
- 追问性能优化的思路和方法
- 询问遇到过的实际问题和解决经验
- 对比不同方案的优缺点
- 考察对新技术和发展趋势的了解（如容器、虚拟化）
- 深入某个感兴趣的领域进行技术讨论

## 参考资源建议

面试官可以参考以下资源准备问题和验证答案：
- 《操作系统概念》（恐龙书）
- 《深入理解计算机系统》（CSAPP）
- 《现代操作系统》
- 《Linux内核设计与实现》
- Linux man pages和内核文档
- 在线课程如MIT 6.828、CMU 15-213

---

## 附录：重点知识速查

### 进程与线程
- 进程是资源分配的基本单位，线程是CPU调度的基本单位
- fork()的写时复制机制
- 上下文切换的内容和开销
- 常见调度算法：FCFS、SJF、RR、多级反馈队列

### 内存管理
- 虚拟内存实现物理内存的扩展和保护
- 页表和TLB的地址转换
- 页面置换算法：FIFO、LRU、Clock
- 分页解决外部碎片，但有页表开销和内部碎片

### 进程间通信
- 管道、消息队列、共享内存、信号、Socket
- 共享内存最快，但需要同步
- 信号量用于同步，互斥锁用于互斥

### 死锁
- 四个必要条件：互斥、占有并等待、不可抢占、循环等待
- 预防、避免（银行家算法）、检测与恢复
- 实践中主要通过有序资源分配预防死锁

### I/O系统
- 五种I/O模型：阻塞、非阻塞、多路复用、信号驱动、异步
- select/poll/epoll的区别和适用场景
- DMA减少CPU参与I/O操作

### 文件系统
- inode存储文件元数据，数据块存储文件内容
- 多级索引支持大文件
- 日志文件系统提高可靠性
- 硬链接共享inode，软链接是路径引用

