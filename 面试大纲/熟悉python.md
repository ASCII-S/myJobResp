# 主题：Python

## 1. Python基础语法与数据类型

### 1.1 基本数据类型

#### 1.1.1 数值类型
**整数与浮点数**
- Python中整数的存储机制是什么？与其他语言有何不同？
- 为什么Python3中没有长整型（long）？
- 浮点数精度问题如何产生？如何解决？
- `Decimal`类型的使用场景是什么？

**布尔类型**
- Python中哪些值被认为是False？
- `bool`类型与整数类型的关系是什么？
- 短路求值在Python中如何体现？

#### 1.1.2 字符串
**字符串特性**
- Python字符串的不可变性有什么意义？
- 字符串驻留机制（string interning）是什么？
- Unicode和编码问题：`encode()`和`decode()`的区别
- Python2和Python3在字符串处理上的主要区别

**字符串操作**
- `join()`和`+`拼接字符串的性能差异
- 格式化字符串的几种方式：`%`、`format()`、f-string的对比
- 字符串切片的底层实现原理
- 常用字符串方法的时间复杂度

#### 1.1.3 容器类型
**列表（List）**
- 列表的底层实现原理（动态数组）
- 列表的时间复杂度：append、insert、pop、index
- 列表推导式与生成器表达式的区别
- 浅拷贝与深拷贝的区别及应用场景
- 列表切片的内存行为

**元组（Tuple）**
- 元组的不可变性是如何实现的？
- 元组与列表的性能对比
- 元组作为字典键的条件
- 命名元组（namedtuple）的使用场景

**字典（Dict）**
- 字典的底层实现原理（哈希表）
- Python3.7+字典有序性的实现
- 哈希冲突的解决方法
- 字典的时间复杂度分析
- `defaultdict`和`Counter`的使用场景
- 字典推导式的应用

**集合（Set）**
- 集合的底层实现原理
- 集合操作的时间复杂度
- 可变集合与不可变集合（frozenset）
- 集合运算：交集、并集、差集的应用

### 1.2 变量与作用域

#### 1.2.1 变量机制
**变量本质**
- Python中变量的本质是什么？（引用/指针）
- 可变对象与不可变对象的区别
- 对象的身份、类型、值分别是什么？
- `is`与`==`的区别

**变量赋值**
- 链式赋值与多重赋值的区别
- 解包赋值的使用场景
- 交换变量值的Python惯用法
- 增量赋值运算符的特殊性（`+=`对可变/不可变对象）

#### 1.2.2 作用域与命名空间
**LEGB规则**
- LEGB作用域查找顺序是什么？
- 局部作用域与全局作用域的区别
- `global`和`nonlocal`关键字的使用场景
- 闭包中的自由变量

**命名空间**
- 什么是命名空间？有哪几种？
- 命名空间的生命周期
- `locals()`和`globals()`的区别
- `__dict__`属性的作用

### 1.3 运算符与表达式

#### 1.3.1 运算符
**算术与比较运算符**
- `/`和`//`的区别
- `**`运算符的优先级
- 比较运算符的链式使用
- `in`运算符的时间复杂度（不同数据结构）

**逻辑运算符**
- `and`、`or`、`not`的短路求值
- 逻辑运算符返回值的特点
- 布尔运算的应用技巧

**位运算符**
- 位运算符的基本操作
- 位运算的应用场景
- 位运算的性能优势

#### 1.3.2 表达式特性
**三元表达式**
- Python三元表达式的语法
- 与if-else语句的区别

**海象运算符**
- Python 3.8+海象运算符`:=`的使用场景
- 海象运算符的优势与注意事项

## 2. 函数与函数式编程

### 2.1 函数基础

#### 2.1.1 函数定义与调用
**函数参数**
- 位置参数、默认参数、可变参数、关键字参数的区别
- `*args`和`**kwargs`的使用场景
- 参数顺序规则
- 默认参数的陷阱（可变对象作为默认参数）
- 强制关键字参数（keyword-only arguments）
- 强制位置参数（positional-only arguments，Python 3.8+）

**函数返回值**
- Python函数如何返回多个值？
- 没有return语句时的返回值
- `return`与`yield`的区别

#### 2.1.2 函数对象
**函数是一等公民**
- 函数作为对象的特性
- 函数作为参数传递
- 函数作为返回值
- 函数属性和注解

**匿名函数**
- `lambda`表达式的语法和限制
- `lambda`与`def`定义函数的区别
- `lambda`的使用场景

### 2.2 高级函数特性

#### 2.2.1 闭包
**闭包概念**
- 什么是闭包？闭包的构成条件
- 闭包的应用场景
- 闭包中的变量查找规则
- 闭包陷阱：循环中创建闭包

**自由变量**
- 自由变量的概念
- `nonlocal`关键字的作用
- 闭包与全局变量的区别

#### 2.2.2 装饰器
**装饰器原理**
- 装饰器的本质是什么？
- 装饰器的语法糖
- 装饰器的执行时机
- 多个装饰器的执行顺序

**装饰器类型**
- 函数装饰器与类装饰器
- 带参数的装饰器实现
- 类方法装饰器：`@staticmethod`、`@classmethod`、`@property`
- `functools.wraps`的作用

**装饰器应用**
- 常见装饰器应用场景：日志、性能测试、缓存、权限验证
- 实现一个计时装饰器
- 实现一个缓存装饰器（LRU Cache）
- `functools.lru_cache`的使用

#### 2.2.3 函数式编程工具
**内置高阶函数**
- `map()`、`filter()`、`reduce()`的用法和区别
- 列表推导式与`map/filter`的对比
- `sorted()`函数的key参数

**functools模块**
- `partial()`的使用场景
- `reduce()`的应用
- `wraps()`的作用
- `total_ordering`的使用

**itertools模块**
- 常用迭代工具：`chain`、`combinations`、`permutations`
- 无限迭代器：`count`、`cycle`、`repeat`
- `groupby()`的使用

### 2.3 递归与生成器

#### 2.3.1 递归
**递归原理**
- 递归的基本要素
- 递归调用栈的工作机制
- Python递归深度限制及修改方法
- 尾递归优化（Python不支持）

**递归应用**
- 递归与迭代的选择
- 递归的经典问题：斐波那契、汉诺塔、树遍历

#### 2.3.2 生成器
**生成器概念**
- 生成器的定义方式：`yield`关键字
- 生成器与普通函数的区别
- 生成器的状态保存机制
- 生成器表达式与列表推导式的区别

**生成器方法**
- `next()`函数与`__next__()`方法
- `send()`方法的作用
- `throw()`和`close()`方法
- 生成器的异常处理

**生成器应用**
- 惰性求值的优势
- 生成器在内存优化中的应用
- 生成器实现协程的基础
- `yield from`的使用

## 3. 面向对象编程

### 3.1 类与对象

#### 3.1.1 类的定义
**类的基本结构**
- 类的定义语法
- `__init__()`构造方法
- `self`参数的含义
- 类属性与实例属性的区别
- 属性查找顺序

**实例化过程**
- `__new__()`与`__init__()`的区别
- 对象创建的完整过程
- 单例模式的实现方式

#### 3.1.2 方法类型
**实例方法、类方法、静态方法**
- 实例方法的特点
- `@classmethod`的使用场景
- `@staticmethod`的使用场景
- 三种方法的调用方式和区别

**特殊方法**
- `__call__()`：可调用对象
- `__str__()`与`__repr__()`的区别
- `__del__()`析构方法的注意事项

### 3.2 封装、继承与多态

#### 3.2.1 封装
**属性访问控制**
- Python中的私有属性和方法（命名约定）
- 名称改写（name mangling）机制
- `@property`装饰器的使用
- getter、setter、deleter的实现

**属性描述符**
- 描述符协议：`__get__`、`__set__`、`__delete__`
- 数据描述符与非数据描述符
- 描述符的应用场景
- `property`的底层实现

#### 3.2.2 继承
**单继承与多继承**
- 继承的基本语法
- `super()`函数的作用和用法
- 方法重写（override）
- 多继承的问题和解决方案

**方法解析顺序（MRO）**
- MRO是什么？如何查看？
- C3线性化算法
- 菱形继承问题
- `super()`在多继承中的行为

**抽象基类**
- `abc`模块的使用
- `@abstractmethod`装饰器
- 抽象基类的应用场景
- 接口的实现方式

#### 3.2.3 多态
**多态概念**
- Python中的多态是如何实现的？
- 鸭子类型（Duck Typing）
- 多态的应用场景

**类型检查**
- `isinstance()`与`type()`的区别
- `issubclass()`的使用
- 类型提示（Type Hints）的作用

### 3.3 魔法方法与元编程

#### 3.3.1 魔法方法
**对象表示**
- `__str__()`与`__repr__()`
- `__format__()`的使用
- `__bytes__()`和`__hash__()`

**容器协议**
- `__len__()`、`__getitem__()`、`__setitem__()`、`__delitem__()`
- `__contains__()`：实现`in`运算符
- `__iter__()`：实现可迭代对象
- 实现自定义序列类型

**运算符重载**
- 算术运算符：`__add__`、`__sub__`、`__mul__`等
- 比较运算符：`__eq__`、`__lt__`、`__gt__`等
- 反向运算符和就地运算符
- 运算符重载的应用场景

**上下文管理器**
- `__enter__()`和`__exit__()`方法
- `with`语句的工作原理
- `contextlib`模块的使用
- 实现自定义上下文管理器

#### 3.3.2 元类
**元类基础**
- 什么是元类？类与元类的关系
- `type`作为元类的使用
- `__new__`与`__init__`在元类中的作用
- 元类的应用场景

**类的创建过程**
- 类的创建流程
- `__prepare__`方法
- `__init_subclass__`钩子方法
- 元类与装饰器的对比

**元编程技巧**
- 动态创建类
- 动态修改类
- 属性验证的实现
- ORM框架中的元类应用

#### 3.3.3 属性管理
**`__getattr__`系列**
- `__getattr__`与`__getattribute__`的区别
- `__setattr__`与`__delattr__`
- 属性访问陷阱
- 代理模式的实现

**`__slots__`**
- `__slots__`的作用和原理
- 使用`__slots__`的优缺点
- `__slots__`对内存的影响
- `__slots__`的继承行为

## 4. 迭代器与生成器

### 4.1 迭代协议

#### 4.1.1 可迭代对象与迭代器
**迭代协议**
- 可迭代对象（Iterable）的定义
- 迭代器（Iterator）的定义
- `__iter__()`和`__next__()`方法
- 可迭代对象与迭代器的区别

**迭代器使用**
- `iter()`和`next()`函数
- `StopIteration`异常
- 迭代器的特点：惰性求值、单向、一次性
- 实现自定义迭代器

#### 4.1.2 内置迭代工具
**range、enumerate、zip**
- `range()`的特点和内存优化
- `enumerate()`的使用场景
- `zip()`的行为和应用
- `zip_longest()`的使用

**reversed、sorted**
- `reversed()`的使用
- `sorted()`与列表的`sort()`方法区别
- 自定义排序key

### 4.2 生成器进阶

#### 4.2.1 生成器表达式
**生成器表达式特性**
- 生成器表达式语法
- 与列表推导式的内存对比
- 生成器表达式的应用场景
- 多层嵌套生成器表达式

#### 4.2.2 协程基础
**基于生成器的协程**
- `yield`实现协程的原理
- `send()`方法的双向通信
- 协程的状态
- 协程的应用场景

**yield from**
- `yield from`的语法和作用
- 子生成器的委托
- `yield from`在协程中的应用

## 5. 模块与包

### 5.1 模块系统

#### 5.1.1 模块基础
**模块的导入**
- `import`语句的工作原理
- `from...import`的使用
- `import *`的问题
- `__all__`的作用
- 相对导入与绝对导入

**模块的查找**
- `sys.path`的作用
- 模块搜索路径的顺序
- `PYTHONPATH`环境变量
- `.pyc`文件的作用

**模块属性**
- `__name__`属性的作用
- `if __name__ == '__main__'`的含义
- `__file__`、`__doc__`等特殊属性
- `dir()`函数查看模块内容

#### 5.1.2 包管理
**包的结构**
- 包的定义和结构
- `__init__.py`的作用
- 命名空间包（Namespace Package）
- 子包和相对导入

**包的导入**
- 包的导入机制
- `__path__`属性
- 包的延迟导入

### 5.2 常用标准库

#### 5.2.1 系统相关
**os与sys**
- `os`模块的常用功能：文件操作、路径操作、环境变量
- `sys`模块的常用功能：命令行参数、解释器信息、路径管理
- `os.path`与`pathlib`的对比

**subprocess**
- 执行外部命令的方法
- `subprocess.run()`的使用
- 管道和重定向

#### 5.2.2 数据处理
**collections**
- `namedtuple`：具名元组
- `deque`：双端队列
- `Counter`：计数器
- `defaultdict`：带默认值的字典
- `OrderedDict`：有序字典（Python3.7+已不必要）
- `ChainMap`：链式字典

**array与struct**
- `array`模块的使用场景
- `struct`模块的二进制数据处理

**json与pickle**
- JSON序列化与反序列化
- `pickle`的使用和安全问题
- 自定义对象的序列化

#### 5.2.3 时间与日期
**datetime模块**
- `datetime`、`date`、`time`、`timedelta`的使用
- 时间格式化与解析
- 时区处理

**time模块**
- `time()`、`sleep()`的使用
- 时间戳的概念

#### 5.2.4 正则表达式
**re模块**
- 正则表达式的基本语法
- `match()`、`search()`、`findall()`、`sub()`的区别
- 编译正则表达式的优势
- 分组和捕获
- 贪婪匹配与非贪婪匹配

## 6. 文件操作与IO

### 6.1 文件操作

#### 6.1.1 文件读写
**文件打开模式**
- 不同打开模式：`r`、`w`、`a`、`rb`、`wb`等
- 文本模式与二进制模式的区别
- `+`模式的使用

**文件读取方法**
- `read()`、`readline()`、`readlines()`的区别
- 文件迭代器的使用
- 大文件读取的最佳实践

**文件写入**
- `write()`和`writelines()`
- 缓冲区的概念
- `flush()`的作用

#### 6.1.2 上下文管理
**with语句**
- `with`语句的优势
- 文件自动关闭机制
- 多个文件的上下文管理

**文件对象**
- 文件对象的方法和属性
- `tell()`和`seek()`的使用
- 文件关闭的重要性

### 6.2 路径操作

#### 6.2.1 os.path模块
**路径操作**
- `join()`、`split()`、`dirname()`、`basename()`
- `exists()`、`isfile()`、`isdir()`
- `abspath()`、`relpath()`
- 路径规范化

#### 6.2.2 pathlib模块
**Path对象**
- `Path`类的使用
- 面向对象的路径操作
- `pathlib`与`os.path`的对比
- 路径的遍历和匹配

### 6.3 文件系统操作

#### 6.3.1 目录操作
**目录管理**
- 创建和删除目录
- 遍历目录树：`os.walk()`
- `glob`模块的文件匹配

#### 6.3.2 文件元数据
**文件信息**
- 获取文件大小、修改时间等信息
- 文件权限的查看和修改

## 7. 异常处理

### 7.1 异常基础

#### 7.1.1 异常机制
**异常的概念**
- 什么是异常？异常的作用
- Python异常的层次结构
- 常见内置异常类型
- 异常对象的属性

**异常的传播**
- 异常的传播机制
- 未捕获异常的行为
- 异常链的概念

#### 7.1.2 异常处理
**try-except**
- `try-except`语句的基本语法
- 捕获多个异常
- `except`子句的顺序
- 捕获异常对象

**else与finally**
- `else`子句的使用场景
- `finally`子句的执行时机
- `finally`中的return语句

**raise语句**
- 抛出异常的方法
- 重新抛出异常
- 异常链：`raise...from`
- `raise`不带参数的用法

### 7.2 自定义异常

#### 7.2.1 异常类设计
**自定义异常类**
- 如何定义自定义异常
- 异常类的继承关系
- 异常类的命名约定
- 添加异常属性和方法

**异常层次**
- 设计异常层次结构
- 异常粒度的选择

#### 7.2.2 异常处理最佳实践
**异常处理原则**
- 何时使用异常？
- EAFP vs LBYL编程风格
- 不要过度使用异常
- 异常的性能开销

**异常处理模式**
- 资源清理的异常处理
- 上下文管理器与异常处理
- 记录异常日志
- 异常的转换和包装

## 8. 并发与并行

### 8.1 多线程

#### 8.1.1 线程基础
**threading模块**
- `Thread`类的使用
- 创建和启动线程
- 线程的等待：`join()`
- 守护线程（Daemon Thread）

**线程同步**
- `Lock`：互斥锁
- `RLock`：可重入锁
- `Semaphore`：信号量
- `Event`：事件
- `Condition`：条件变量

#### 8.1.2 GIL
**全局解释器锁**
- GIL是什么？GIL的作用
- GIL对多线程的影响
- 为什么有GIL？
- 如何避免GIL的限制？

**线程安全**
- 什么是线程安全？
- 竞态条件和死锁
- Python中哪些操作是线程安全的？
- `queue.Queue`的线程安全特性

### 8.2 多进程

#### 8.2.1 multiprocessing模块
**进程创建**
- `Process`类的使用
- 进程的启动方法：fork、spawn、forkserver
- 进程间的数据隔离

**进程通信**
- `Queue`：进程安全队列
- `Pipe`：管道
- `Value`和`Array`：共享内存
- `Manager`：共享对象管理器

**进程同步**
- `Lock`、`Semaphore`、`Event`在多进程中的使用
- 进程池：`Pool`
- `map()`和`apply()`的使用

#### 8.2.2 进程与线程对比
**选择依据**
- CPU密集型 vs IO密集型
- 进程与线程的开销对比
- 数据共享的便利性
- 何时选择多进程？何时选择多线程？

### 8.3 异步编程

#### 8.3.1 asyncio基础
**协程概念**
- 协程的定义
- `async`和`await`关键字
- 协程函数与协程对象
- 事件循环的概念

**asyncio核心API**
- `asyncio.run()`
- `asyncio.create_task()`
- `asyncio.gather()`
- `asyncio.wait()`

#### 8.3.2 异步IO操作
**异步编程模式**
- 异步函数的定义和调用
- 异步上下文管理器
- 异步迭代器
- 异步生成器

**并发任务管理**
- 创建和管理任务
- 任务取消和超时
- 异常处理

#### 8.3.3 异步与多线程对比
**异步编程优势**
- 异步编程的适用场景
- 协程与线程的性能对比
- 何时使用异步？何时使用多线程？

## 9. 内存管理与性能优化

### 9.1 内存管理

#### 9.1.1 内存管理机制
**引用计数**
- Python的引用计数机制
- `sys.getrefcount()`的使用
- 引用计数的优缺点
- 循环引用问题

**垃圾回收**
- Python的垃圾回收机制
- 分代回收算法
- `gc`模块的使用
- 手动触发垃圾回收

**内存池**
- Python的内存池机制
- 小对象的内存管理
- 内存碎片问题

#### 9.1.2 内存优化
**对象大小**
- `sys.getsizeof()`的使用
- 不同数据结构的内存占用
- `__slots__`的内存优化
- 生成器的内存优势

**内存泄漏**
- Python中常见的内存泄漏原因
- 如何检测内存泄漏
- 避免循环引用
- 弱引用（weakref）的使用

### 9.2 性能优化

#### 9.2.1 性能分析
**性能测量**
- `timeit`模块的使用
- `cProfile`性能分析器
- `line_profiler`逐行分析
- 性能瓶颈的定位

**内存分析**
- `memory_profiler`的使用
- 内存快照分析
- 内存使用趋势监控

#### 9.2.2 优化技巧
**代码优化**
- 局部变量优化
- 避免全局变量查找
- 列表推导式vs循环
- 使用内置函数和库
- 字符串拼接优化

**数据结构选择**
- 选择合适的数据结构
- `set`和`dict`的查找优势
- `deque`的性能优势
- `array`的内存优势

**算法优化**
- 时间复杂度优化
- 缓存和记忆化
- 延迟计算
- 批量操作

#### 9.2.3 扩展优化
**C扩展**
- 为什么使用C扩展？
- Cython的使用
- ctypes的使用
- CFFI的使用

**JIT编译**
- PyPy的使用
- Numba的使用

## 10. 测试与调试

### 10.1 测试

#### 10.1.1 单元测试
**unittest框架**
- `unittest`的基本使用
- 测试用例的编写
- `setUp()`和`tearDown()`
- 断言方法
- 测试套件和测试运行器

**pytest框架**
- pytest的优势
- 简单的测试函数
- fixture的使用
- 参数化测试
- 插件生态

#### 10.1.2 测试技巧
**测试覆盖率**
- `coverage`工具的使用
- 测试覆盖率的意义
- 如何提高测试覆盖率

**Mock测试**
- `unittest.mock`的使用
- `Mock`对象和`MagicMock`
- `patch`装饰器和上下文管理器
- 模拟外部依赖

**测试最佳实践**
- 测试命名规范
- 测试的独立性
- 测试的可读性
- TDD开发模式

### 10.2 调试

#### 10.2.1 调试工具
**pdb调试器**
- pdb的基本使用
- 设置断点
- 单步执行
- 查看变量
- 常用pdb命令

**IDE调试**
- PyCharm、VSCode的调试功能
- 条件断点
- 表达式求值

#### 10.2.2 调试技巧
**日志调试**
- `logging`模块的使用
- 日志级别
- 日志格式化
- 日志处理器和过滤器

**print调试**
- `print()`调试的优缺点
- `pprint`模块的使用
- `repr()`与`str()`在调试中的应用

**异常信息**
- 异常栈追踪的解读
- `traceback`模块的使用
- 异常信息的记录

## 11. Python高级特性

### 11.1 上下文管理器

#### 11.1.1 上下文管理器协议
**`__enter__`和`__exit__`**
- 上下文管理器的实现
- `__exit__`的参数和返回值
- 异常处理

**contextlib模块**
- `@contextmanager`装饰器
- `closing()`的使用
- `suppress()`的使用
- `redirect_stdout()`和`redirect_stderr()`

### 11.2 描述符

#### 11.2.1 描述符协议
**描述符方法**
- `__get__`、`__set__`、`__delete__`
- 数据描述符与非数据描述符
- 描述符的调用优先级

**描述符应用**
- 属性验证
- 延迟计算的属性
- 缓存属性
- 类型检查

### 11.3 类型提示

#### 11.3.1 类型注解
**基本类型注解**
- 变量类型注解
- 函数参数和返回值注解
- 类属性注解

**typing模块**
- `List`、`Dict`、`Tuple`、`Set`等泛型
- `Optional`和`Union`
- `Callable`类型
- `TypeVar`和泛型函数
- `Protocol`和结构化子类型

#### 11.3.2 类型检查
**静态类型检查**
- `mypy`的使用
- 类型检查的好处
- 渐进式类型系统

### 11.4 数据类

#### 11.4.1 dataclass
**`@dataclass`装饰器**
- dataclass的基本使用
- 自动生成的方法
- 字段定义和默认值
- 不可变数据类
- 继承和字段排序

**与namedtuple对比**
- dataclass与namedtuple的区别
- 何时使用dataclass？

### 11.5 枚举类型

#### 11.5.1 enum模块
**枚举的使用**
- `Enum`类的基本使用
- 枚举成员的访问
- 枚举的比较
- `IntEnum`和`Flag`
- 自定义枚举方法

## 12. Python编程规范与最佳实践

### 12.1 编程规范

#### 12.1.1 PEP8规范
**代码风格**
- 命名规范：变量、函数、类、常量
- 缩进和空格
- 行长度限制
- 空行使用
- 导入语句规范

**代码组织**
- 模块的组织结构
- 函数和类的顺序
- 注释和文档字符串

#### 12.1.2 代码质量工具
**Linter工具**
- `pylint`的使用
- `flake8`的使用
- `black`代码格式化
- `isort`导入排序

### 12.2 设计模式

#### 12.2.1 常用设计模式
**创建型模式**
- 单例模式
- 工厂模式
- 建造者模式

**结构型模式**
- 装饰器模式
- 代理模式
- 适配器模式

**行为型模式**
- 策略模式
- 观察者模式
- 迭代器模式

### 12.3 最佳实践

#### 12.3.1 编程习惯
**Pythonic代码**
- EAFP vs LBYL
- 使用列表推导式
- 使用生成器
- 使用上下文管理器
- 链式比较
- 使用`enumerate`和`zip`

**代码可读性**
- 有意义的命名
- 函数单一职责
- 避免过深的嵌套
- 使用类型提示

#### 12.3.2 项目结构
**项目组织**
- 标准项目结构
- `__init__.py`的使用
- 配置文件管理
- 依赖管理：`requirements.txt`、`setup.py`、`pyproject.toml`

**虚拟环境**
- `venv`的使用
- `virtualenv`的使用
- `conda`环境管理
- 为什么使用虚拟环境？

## 13. 常用第三方库

### 13.1 数据处理

#### 13.1.1 NumPy
**数组操作**
- NumPy数组的特点
- 数组的创建和索引
- 数组运算的向量化
- 广播机制

#### 13.1.2 Pandas
**数据结构**
- Series和DataFrame
- 数据的读取和写入
- 数据清洗和转换
- 分组和聚合

### 13.2 Web开发

#### 13.2.1 Flask/Django
**Web框架基础**
- Flask的轻量级特点
- Django的全栈特性
- 路由和视图
- 模板引擎

#### 13.2.2 Requests
**HTTP请求**
- `requests`库的使用
- GET和POST请求
- 请求头和参数
- 会话管理

### 13.3 其他常用库

#### 13.3.1 网络爬虫
**爬虫库**
- `BeautifulSoup`：HTML解析
- `Scrapy`：爬虫框架
- `Selenium`：浏览器自动化

#### 13.3.2 科学计算
**科学计算库**
- `SciPy`：科学计算
- `Matplotlib`：数据可视化
- `scikit-learn`：机器学习

## 14. Python语言特性与底层原理

### 14.1 Python解释器

#### 14.1.1 CPython实现
**解释器特性**
- CPython的工作原理
- 字节码的概念
- Python虚拟机
- `dis`模块查看字节码

**其他实现**
- PyPy、Jython、IronPython
- 不同实现的特点和适用场景

### 14.2 动态特性

#### 14.2.1 反射
**反射机制**
- `getattr()`、`setattr()`、`hasattr()`、`delattr()`
- `vars()`和`dir()`
- `__dict__`属性
- 动态调用方法

#### 14.2.2 动态导入
**importlib模块**
- 动态导入模块
- `__import__()`函数
- 插件系统的实现

### 14.3 Python2与Python3

#### 14.3.1 主要差异
**核心差异**
- `print`：函数vs语句
- 字符串：Unicode处理
- 整数除法：`/`和`//`
- `range()`与`xrange()`
- 异常语法
- `dict`的`keys()`、`values()`、`items()`

**兼容性处理**
- `__future__`模块
- `six`库的使用
- 代码迁移工具

## 15. 实践与综合应用

### 15.1 常见算法实现

#### 15.1.1 排序与搜索
**排序算法**
- 快速排序、归并排序的Python实现
- `sorted()`的底层实现（Timsort）
- 自定义排序

**搜索算法**
- 二分查找
- 深度优先搜索（DFS）
- 广度优先搜索（BFS）

#### 15.1.2 数据结构实现
**常见数据结构**
- 链表的实现
- 栈和队列的实现
- 二叉树的实现
- 哈希表的实现

### 15.2 实际问题解决

#### 15.2.1 编程实践
**常见编程题**
- 字符串处理
- 数组操作
- 递归问题
- 动态规划

**系统设计**
- LRU缓存的实现
- 线程池的实现
- 简单的ORM实现
- 装饰器的实际应用

#### 15.2.2 代码审查
**常见问题**
- 性能问题识别
- 内存泄漏识别
- 线程安全问题
- 代码可维护性评估

