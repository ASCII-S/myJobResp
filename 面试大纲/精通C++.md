# 精通C++ 面试大纲
---

[[toc]]


## 面试目标
全面考察应届生对C++语言的掌握程度，从基础语法到高级特性，从理论知识到实际应用能力，确保候选人具备扎实的C++编程功底。

## 面试时长
建议总时长：90-120分钟

## 考核维度权重
- 基础语法和概念：12%
- 面向对象编程：13%
- 内存管理：13%
- STL和模板：12%
- C++并发编程：18%
- 网络编程：15%
- 现代C++特性：8%
- 性能优化：4%
- 实际编程能力：5%
---

## 第一部分：C++基础概念和语法（15-20分钟）

### 1.1 语言基础
**考核要点：**
- C++与C的区别和联系
- 编译过程和链接机制
- 头文件和源文件的组织

**核心问题：**
1. **编译链接过程**
   - [描述C++程序从源代码到可执行文件的完整过程](../notes/C++/C++程序从源代码到可执行文件的完整过程.md)
   - 解释预处理、编译、汇编、链接各阶段的作用
   - [使用编译优化选项时，哪个或哪些阶段得到了优化？](../notes/C++/使用编译优化选项时，哪个或哪些阶段得到了优化？.md)
   - [静态链接和动态链接](../notes/C++/静态链接和动态链接.md)
   - [什么是符号表？链接时如何解决符号引用？](../notes/C++/什么是符号表？链接时如何解决符号引用？.md)
   - [重定位表怎么工作的？](../notes/C++/重定位表怎么工作的？.md)
   - [定义一个100大小的数组，但是通过下标访问101位置，会发生什么？](../notes/C++/定义一个100大小的数组，但是通过下标访问101位置，会发生什么？.md)

2. **头文件机制**
   - [#include的工作原理](../notes/C++/include的工作原理.md)
   - 如何防止头文件重复包含？比较`#pragma once`和`#ifndef`的优缺点
   - 前向声明的作用和使用场景

3. **名空间机制**
   - 为什么需要命名空间？如何避免命名空间？[为什么需要命名空间？如何避免命名空间？](../notes/C++/为什么需要命名空间？如何避免命名空间？.md)
   - `using`声明和`using`指令的区别
   - ADL（参数依赖查找）是什么？举例说明

### 1.2 数据类型和变量
**考核要点：**
- 基本数据类型的特点和使用
- 类型转换机制
- 常量和变量的声明

**核心问题：**
1. **类型系统**
   - C++中有哪些基本数据类型？各占多少字节？
   - [指针和引用的区别](../notes/C++/指针和引用的区别.md)
   - [`int`、`long`、`long long`在不同平台上的差异](../notes/C++/int、long、long_long在不同平台上的差异.md)
   - `size_t`和`ptrdiff_t`的用途和区别

2. **类型转换**
   - 隐式类型转换的规则和潜在问题
   - [四种显式类型转换的区别和使用场景](../notes/C++/四种显式类型转换的区别和使用场景.md)
   - `const_cast`什么时候使用？有什么风险？

3. **常量机制**
   - [const关键字](../notes/C++/const关键字.md)
   - [constexpr与const的区别](../notes/C++/constexpr与const的区别.md)
   - 编译期常量与运行期常量的区别
   - [static关键字](../notes/C++/static关键字.md)
   - [静态局部变量，全局变量，局部变量](../notes/C++/静态局部变量，全局变量，局部变量.md)
4. **其他关键字**
   - [define和typedef的区别](../notes/C++/define和typedef的区别.md)
---

## 第二部分：面向对象编程（20-25分钟）

### 2.1 类和对象基础
**考核要点：**
- 类的定义和对象的创建
- 构造函数和析构函数
- 访问控制机制

**核心问题：**
1. **构造和析构**
   - 默认构造函数什么时候会被编译器生成？
   - 构造函数初始化列表的作用和必要性
   - 析构函数的调用时机和虚析构函数的重要性
   - [explicit关键字](../notes/C++/explicit关键字.md)

2. **拷贝控制**
   - 什么是"三五法则"？为什么重要？
   - [深拷贝和浅拷贝的区别，什么时候需要深拷贝？](../notes/C++/深拷贝和浅拷贝的区别，什么时候需要深拷贝？.md)
   - 移动构造函数和移动赋值运算符的作用

3. **访问控制**
   - `public`、`private`、`protected`的访问规则
   - `friend`关键字的使用场景和设计考量
   - 类的封装性如何体现？

### 2.2 继承和多态
**考核要点：**
- 继承机制和访问控制
- 虚函数和多态实现
- 抽象类和接口设计

**核心问题：**
1. **继承机制**
   - 公有继承、私有继承、保护继承的区别和使用场景
   - 多重继承的问题和解决方案
   - 虚继承解决了什么问题？实现原理是什么？
   - [类继承中的内存布局](../notes/C++/类继承中的内存布局.md)

2. **多态实现**
   - [动态多态和静态多态的区别](../notes/C++/动态多态和静态多态的区别.md)
   - [虚函数的实现机制（虚函数表）](../notes/C++/虚函数的实现机制（虚函数表）.md)
   - [调用虚函数的执行流程](../notes/C++/调用虚函数的执行流程.md)
   - [纯虚函数和抽象类的作用](../notes/C++/纯虚函数和抽象类的作用.md)
   - [简述虚析构函数及作用](../notes/C++/简述虚析构函数及作用.md)
   - [为什么没有虚构造函数](../notes/C++/为什么没有虚构造函数.md)
   - 虚函数的性能开销和优化考虑

3. **高级继承概念**
   - RTTI（运行时类型信息）的使用
   - [`dynamic_cast`的工作原理](../notes/C++/dynamic_cast的工作原理.md)
   - 接口设计的最佳实践

---

## 第三部分：内存管理（15-20分钟）

### 3.1 内存布局和管理
**考核要点：**
- 程序内存布局
- 动态内存分配
- 内存泄漏和野指针问题

**核心问题：**
1. **内存区域**
   - [栈、堆、全局区、常量区的特点和用途](../notes/C++/栈、堆、全局区、常量区的特点和用途.md)
   - [栈溢出和堆溢出的原因和预防](../notes/C++/栈溢出和堆溢出的原因和预防.md)
   - 内存对齐的原理和影响

2. **动态内存管理**
   - [new和malloc的区别](../notes/C++/new和malloc的区别.md)
   - `new`/`delete`与`malloc`/`free`的区别
   - [new[]和delete[]的使用注意事项](../notes/C++/new[]和delete[]的使用注意事项.md)
   - [内存池和对象池的设计思想](../notes/C++/内存池和对象池的设计思想.md)

3. **常见内存问题**
   - 内存泄漏的检测和预防方法
   - [野指针和悬空指针的区别](../notes/C++/野指针和悬空指针的区别.md)
   - 缓冲区溢出的危害和防护

### 3.2 智能指针和RAII
**考核要点：**
- RAII设计模式
- 智能指针的使用
- 资源管理最佳实践

**核心问题：**
1. **RAII原则**
   - RAII的核心思想和优势
   - 如何用RAII管理各种资源（内存、文件、锁等）
   - 异常安全性的三个级别

2. **智能指针详解**
   - [`unique_ptr`、`shared_ptr`、`weak_ptr`的使用场景](../notes/C++/unique_ptr、shared_ptr、weak_ptr的使用场景.md)
   - [循环引用问题及解决方案](../notes/C++/循环引用问题及解决方案.md)
   - 自定义删除器的使用

---

## 第四部分：STL和模板编程（15-20分钟）

### 4.1 STL容器和算法
**考核要点：**
- 常用容器的特点和选择
- 迭代器的使用
- STL算法的应用

**核心问题：**
1. **容器选择**
   - `vector`、`list`、`deque`的性能特点和适用场景
   - [`map`、`unordered_map`的实现原理和性能差异](../notes/C++/map、unordered_map的实现原理和性能差异.md)
   - [容器的内存管理和扩容策略](../notes/C++/容器的内存管理和扩容策略.md)

2. **迭代器系统**
   - 五种迭代器类型的特点和使用
   - [迭代器失效的原因和预防](../notes/C++/迭代器失效的原因和预防.md)
   - 自定义迭代器的实现要点

3. **算法库使用**
   - 常用算法的复杂度分析
   - 函数对象和lambda表达式的使用
   - 算法的定制和扩展

### 4.2 模板编程
**考核要点：**
- 函数模板和类模板
- 模板特化和偏特化
- 模板元编程基础

**核心问题：**
1. **模板基础**
   - 模板的实例化过程和编译期多态
   - 模板参数推导的规则
   - 模板的二次编译检查

2. **高级模板技术**
   - 特化和偏特化的使用场景
   - SFINAE技术的应用
   - 变参模板的使用

---

## 第五部分：C++并发编程（20-25分钟）

### 5.1 多线程基础
**考核要点：**
- 线程的创建和管理
- 线程同步机制
- 线程间通信

**核心问题：**
1. **线程生命周期**
   - [`std::thread`的创建和销毁](../notes/C++/std::thread的创建和销毁.md)
   - [`join()`和`detach()`的区别和使用场景](../notes/C++/join()和detach()的区别和使用场景.md)
   - [多线程中的子线程抛异常会发生什么？](../notes/C++/多线程中的子线程抛异常会发生什么？.md)
   - 线程的可连接状态和资源管理
   - 如何安全地传递参数给线程函数？

2. **线程同步基础**
   - [什么是竞态条件？如何避免？](../notes/C++/什么是竞态条件？如何避免？.md)
   - [死锁的四个必要条件和预防策略](../notes/C++/死锁的四个必要条件和预防策略.md)
   - [`std::mutex`的基本使用和RAII封装](../notes/C++/std::mutex的基本使用和RAII封装.md)
   - 递归锁`std::recursive_mutex`的使用场景

3. **锁的管理**
   - [`std::lock_guard`和`std::unique_lock`的区别](../notes/C++/std::lock_guard和std::unique_lock的区别.md)
   - [延迟加锁是什么](../notes/C++/延迟加锁是什么.md)
   - `std::shared_lock`的作用和读写锁实现
   - 如何避免锁的性能开销？
   - 锁的粒度设计原则

### 5.2 高级同步机制
**考核要点：**
- 条件变量和信号量
- 原子操作和内存模型
- 线程池设计

**核心问题：**
1. **条件变量**
   - [`std::condition_variable`的使用模式](../notes/C++/std::condition_variable的使用模式.md)
   - 为什么条件变量需要配合互斥锁使用？
   - 虚假唤醒问题及其解决方案
   - 生产者-消费者模式的实现

2. **原子操作**
   - [`std::atomic`的基本使用](../notes/C++/std::atomic的基本使用.md)
   - [内存序（memory ordering）的六种类型](../notes/C++/内存序（memory_ordering）的六种类型.md)
   - `memory_order_relaxed`、`memory_order_acquire`、`memory_order_release`的区别
   - 无锁编程的优势和挑战
   - ABA问题及其解决方案

3. **高级并发工具**
   - `std::future`和`std::promise`的使用
   - `std::async`的不同启动策略
   - `std::packaged_task`的应用场景
   - 线程池的设计原理和实现要点

### 5.3 并发编程实践
**考核要点：**
- 线程安全的数据结构设计
- 性能优化和调试技巧
- 常见并发模式

**核心问题：**
1. **线程安全设计**
   - 如何设计线程安全的单例模式？
   - 线程安全的队列如何实现？
   - 读写锁在什么场景下比互斥锁更高效？
   - 如何实现一个线程安全的引用计数？

2. **性能考虑**
   - 上下文切换的开销和优化
   - 缓存一致性问题对多线程性能的影响
   - 如何选择合适的线程数量？
   - NUMA架构对并发程序的影响

3. **调试和测试**
   - 如何调试多线程程序？
   - 常用的线程调试工具
   - 如何检测死锁和竞态条件？
   - 压力测试和性能分析方法

### 5.4 现代并发特性
**考核要点：**
- C++20协程基础
- 并行算法
- 内存模型深入理解

**核心问题：**
1. **协程入门**
   - 协程与线程的区别
   - `co_await`、`co_yield`、`co_return`的基本使用
   - 协程的性能优势和适用场景
   - 协程的调度和执行模型

2. **并行算法**
   - `std::execution`策略的使用
   - 并行版本的STL算法性能特点
   - 如何选择合适的执行策略？
   - 并行算法的异常处理

3. **内存模型深入**
   - CPU缓存一致性协议
   - 内存屏障的作用机制
   - 弱内存模型vs强内存模型
   - 如何分析多线程程序的内存访问模式？

---

## 第六部分：C++网络编程（15-20分钟）

### 6.1 网络编程基础
**考核要点：**
- Socket编程基础
- TCP/UDP协议理解
- 网络I/O模型

**核心问题：**
1. **Socket编程基础**
   - [Socket的创建、绑定、监听、连接流程](../notes/C++/Socket的创建、绑定、监听、连接流程.md)
   - `socket()`、`bind()`、`listen()`、`accept()`、`connect()`函数的作用
   - 网络字节序与主机字节序的转换（`htonl`、`ntohl`等）
   - `sockaddr_in`结构体的使用
   - 如何处理Socket编程中的错误？

2. **TCP vs UDP**
   - TCP和UDP的区别和适用场景
   - TCP的三次握手和四次挥手过程
   - TCP的流控制和拥塞控制机制
   - UDP如何实现可靠传输？
   - 半关闭连接的概念和应用

3. **地址和端口管理**
   - IP地址的表示和转换（`inet_addr`、`inet_ntoa`）
   - 端口号的作用和分配规则
   - `SO_REUSEADDR`、`SO_REUSEPORT`选项的作用
   - 如何处理端口占用问题？

### 6.2 高级网络I/O技术
**考核要点：**
- 阻塞与非阻塞I/O
- I/O多路复用技术
- 异步I/O编程

**核心问题：**
1. **I/O模型对比**
   - 阻塞I/O、非阻塞I/O、I/O多路复用、异步I/O的区别
   - 各种I/O模型的性能特点和适用场景
   - 同步I/O与异步I/O的本质区别
   - 为什么需要非阻塞I/O？

2. **I/O多路复用**
   - `select()`、`poll()`、`epoll()`的工作原理和区别
   - `epoll`的ET（边缘触发）和LT（水平触发）模式
   - 如何处理`epoll`中的事件？
   - `epoll`为什么比`select`和`poll`性能更好？
   - 跨平台I/O多路复用的解决方案

3. **异步I/O编程**
   - Linux的AIO机制和使用方法
   - `io_uring`的基本概念和优势
   - 异步I/O的回调处理模式
   - 如何设计异步网络库的架构？

### 6.3 网络编程实践
**考核要点：**
- 客户端-服务器模型
- 网络协议设计
- 性能优化技巧

**核心问题：**
1. **服务器架构模式**
   - 多进程、多线程、事件驱动的服务器模型对比
   - Reactor和Proactor模式的区别
   - 连接池和线程池在网络编程中的应用
   - 如何设计一个高并发的服务器？
   - 如何处理C10K问题？

2. **协议设计**
   - 应用层协议的设计原则
   - 如何解决TCP粘包问题？
   - 消息边界的确定方法（定长、分隔符、长度前缀）
   - 心跳机制的设计和实现
   - 如何设计一个简单的RPC协议？

3. **错误处理和异常情况**
   - 网络异常的常见类型和处理方法
   - 如何检测连接断开？
   - 超时处理的实现策略
   - 重连机制的设计考虑
   - 如何处理网络拥塞和丢包？

### 6.4 现代C++网络编程
**考核要点：**
- ASIO库的使用
- 协程在网络编程中的应用
- 现代网络库设计

**核心问题：**
1. **ASIO库使用**
   - `boost::asio`或`standalone asio`的基本使用
   - 异步操作的回调和错误处理
   - `io_context`的作用和线程模型
   - 如何使用ASIO实现TCP客户端和服务器？
   - ASIO的定时器和信号处理

2. **协程网络编程**
   - C++20协程在网络编程中的优势
   - 如何用协程简化异步网络代码？
   - 协程与传统回调模式的对比
   - 协程中的异常处理和取消机制

3. **网络库设计**
   - 现代网络库的设计原则
   - 线程安全的网络库设计考虑
   - 内存管理和对象池在网络编程中的应用
   - 如何设计可扩展的网络框架？

### 6.5 网络编程调试和优化
**考核要点：**
- 网络调试工具
- 性能分析和优化
- 安全考虑

**核心问题：**
1. **调试工具和方法**
   - `tcpdump`、`wireshark`等网络抓包工具的使用
   - `netstat`、`ss`、`lsof`等系统工具的使用
   - 如何调试网络连接问题？
   - 网络编程中的日志记录策略

2. **性能优化**
   - 网络编程中的性能瓶颈分析
   - 零拷贝技术（`sendfile`、`splice`）的应用
   - 缓冲区大小的调优
   - 如何减少系统调用的开销？
   - 网络编程中的内存池使用

3. **安全考虑**
   - 缓冲区溢出在网络编程中的防护
   - 如何防止DoS攻击？
   - SSL/TLS编程基础
   - 输入验证和数据净化
   - 网络编程中的常见安全漏洞

---

## 第七部分：现代C++特性（10-15分钟）

### 7.1 C++11/14核心特性
**考核要点：**
- 右值引用和移动语义
- 自动类型推导
- 范围for循环

**核心问题：**
1. **移动语义**
   - [左值和右值的区别](../notes/C++/左值和右值的区别.md)
   - [右值引用与移动语义](../notes/C++/右值引用与移动语义.md)
   - 移动构造函数的实现和使用
   - [移动语义和std::move的区别](../notes/C++/移动语义和std::move的区别.md)
   - 完美转发的原理和应用

2. **类型推导**
   - [`auto`关键字的使用场景和限制](../notes/C++/auto关键字的使用场景和限制.md)
   - [`decltype`的推导规则](../notes/C++/decltype的推导规则.md)
   - [尾置返回类型的作用](../notes/C++/尾置返回类型的作用.md)
   - [通用引用](../notes/C++/通用引用.md)

### 7.2 C++17/20新特性
**考核要点：**
- 结构化绑定
- 概念和约束
- 协程基础

**核心问题：**
1. **实用特性**
   - `std::optional`和`std::variant`的使用
   - 结构化绑定的应用场景
   - `if constexpr`的编译期分支

2. **现代特性**
   - Concepts的作用和语法
   - 协程的基本概念和使用
   - 模块系统的优势

---

## 第八部分：性能优化和最佳实践（5-10分钟）

### 8.1 性能优化技术
**考核要点：**
- 编译器优化
- 缓存友好的代码
- 并发编程基础

**核心问题：**
1. **优化策略**
   - 编译器优化的类型和限制
   - 内联函数的使用和注意事项
   - 分支预测和循环优化

2. **代码优化实践**
   - 避免不必要的拷贝和临时对象
   - 合理使用移动语义
   - 模板特化优化

### 8.2 代码质量和设计模式
**考核要点：**
- 常用设计模式
- 代码规范和风格
- 调试和测试方法

**核心问题：**
1. **设计模式应用**
   - 单例模式的线程安全实现
   - [工厂模式和抽象工厂模式](../notes/C++/工厂模式和抽象工厂模式.md)
   - 观察者模式的C++实现

---

## 第九部分：实际编程考核（10-15分钟）

### 9.1 代码实现题
**选择其中2-3题进行考核：**

1. **智能指针实现**
   ```cpp
   // 实现一个简单的unique_ptr
   template<typename T>
   class my_unique_ptr {
       // 要求实现构造、析构、移动语义、reset、release等
   };
   ```

2. **线程安全的单例模式**
   ```cpp
   // 实现一个线程安全的单例类
   class Singleton {
       // 要求考虑双检锁、内存序等问题
   };
   ```

3. **简单的String类**
   ```cpp
   // 实现一个基本的字符串类
   class MyString {
       // 要求实现构造、拷贝、移动、赋值等操作
   };
   ```

4. **线程安全的计数器**
   ```cpp
   // 实现一个线程安全的计数器
   class SafeCounter {
   public:
       void increment();
       void decrement();
       int get() const;
       // 要求考虑原子操作、内存序等问题
   };
   ```

5. **生产者-消费者队列**
   ```cpp
   // 实现一个线程安全的有界队列
   template<typename T>
   class BoundedQueue {
   public:
       BoundedQueue(size_t capacity);
       void push(const T& item);
       T pop();
       // 要求使用条件变量实现阻塞式操作
   };
   ```

6. **简单的TCP服务器**
   ```cpp
   // 实现一个基于epoll的简单TCP Echo服务器
   class TcpServer {
   public:
       TcpServer(int port);
       void start();
       void stop();
   private:
       void handleNewConnection();
       void handleClientData(int client_fd);
       // 要求使用epoll实现非阻塞I/O
   };
   ```

7. **网络缓冲区类**
   ```cpp
   // 实现一个网络I/O缓冲区
   class Buffer {
   public:
       Buffer(size_t initial_size = 1024);
       void append(const char* data, size_t len);
       void append(const std::string& str);
       void retrieve(size_t len);
       const char* peek() const;
       size_t readableBytes() const;
       size_t writableBytes() const;
       // 要求考虑扩容、数据移动等性能问题
   };
   ```

### 9.2 代码分析题
**分析以下代码的问题并给出改进方案：**

1. **内存管理问题**
   ```cpp
   class ResourceManager {
   public:
       ResourceManager() : ptr(new int[100]) {}
       ~ResourceManager() { delete ptr; }  // 问题在哪里？
   private:
       int* ptr;
   };
   ```

2. **多态使用问题**
   ```cpp
   class Base {
   public:
       void process() { /* ... */ }  // 缺少什么？
   };
   
   void func(Base base) {  // 参数传递有什么问题？
       base.process();
   }
   ```

3. **并发编程问题**
   ```cpp
   class DataProcessor {
   private:
       std::vector<int> data;
       std::mutex mtx;
   public:
       void addData(int value) {
           std::lock_guard<std::mutex> lock(mtx);
           data.push_back(value);
       }
       
       std::vector<int> getData() {  // 这里有什么问题？
           return data;
       }
   };
   ```

4. **死锁风险代码**
   ```cpp
   class Account {
   private:
       std::mutex mtx;
       int balance;
   public:
       void transfer(Account& to, int amount) {
           std::lock_guard<std::mutex> lock1(mtx);
           std::lock_guard<std::mutex> lock2(to.mtx);  // 潜在死锁
           balance -= amount;
           to.balance += amount;
       }
   };
   ```

5. **网络编程错误处理**
   ```cpp
   void handleClient(int client_fd) {
       char buffer[1024];
       while (true) {
           int n = recv(client_fd, buffer, sizeof(buffer), 0);
           if (n > 0) {
               send(client_fd, buffer, n, 0);  // 这里有什么问题？
           } else if (n == 0) {
               break;  // 客户端关闭连接
           }
           // 缺少什么处理？
       }
       close(client_fd);
   }
   ```

6. **epoll使用问题**
   ```cpp
   void epollServer() {
       int epfd = epoll_create1(0);
       int listen_fd = socket(AF_INET, SOCK_STREAM, 0);
       // ... 绑定和监听代码 ...
       
       struct epoll_event ev, events[MAX_EVENTS];
       ev.events = EPOLLIN;
       ev.data.fd = listen_fd;
       epoll_ctl(epfd, EPOLL_CTL_ADD, listen_fd, &ev);
       
       while (true) {
           int nfds = epoll_wait(epfd, events, MAX_EVENTS, -1);
           for (int i = 0; i < nfds; i++) {
               if (events[i].data.fd == listen_fd) {
                   int client_fd = accept(listen_fd, NULL, NULL);
                   ev.events = EPOLLIN;  // 这里有什么潜在问题？
                   ev.data.fd = client_fd;
                   epoll_ctl(epfd, EPOLL_CTL_ADD, client_fd, &ev);
               } else {
                   // 处理客户端数据...
                   close(events[i].data.fd);  // 直接关闭有什么问题？
               }
           }
       }
   }
   ```

---

## 面试评分标准

### 优秀（90-100分）
- 深入理解C++核心概念和机制
- 熟练掌握现代C++特性和最佳实践
- 精通多线程编程和并发安全设计
- 具备扎实的网络编程基础，理解各种I/O模型和性能优化技术
- 能够分析复杂的代码问题并提供优雅的解决方案
- 具备良好的代码设计能力和性能优化意识

### 良好（80-89分）
- 掌握C++基础知识和面向对象编程
- 了解STL和模板编程的基本使用
- 理解多线程编程基础概念和同步机制
- 掌握Socket编程基础，了解常见的网络I/O技术
- 能够识别常见的代码问题并给出解决方案
- 对现代C++特性有一定了解

### 合格（70-79分）
- 具备C++基础语法和编程能力
- 理解基本的面向对象概念
- 了解基本的线程概念，但缺乏实际经验
- 对网络编程有基本认识，了解TCP/UDP基础概念
- 能够完成简单的编程任务
- 对内存管理有基本认识

### 不合格（<70分）
- C++基础知识不扎实
- 缺乏面向对象编程经验
- 对并发编程和网络编程缺乏基本理解
- 代码质量和规范性较差
- 无法独立解决编程问题

---

## 面试官注意事项

1. **循序渐进**：从基础概念开始，根据候选人表现调整难度
2. **理论结合实践**：不仅考察理论知识，更要关注实际编程能力
3. **关注思路**：重点考察解决问题的思路和方法，而非死记硬背
4. **适度引导**：在候选人遇到困难时给予适当提示，观察学习能力
5. **全面评估**：结合技术能力、沟通能力、学习态度等多个维度

## 常见追问方向

- 对于回答正确的问题，可以深入追问实现细节或应用场景
- 对于回答不完整的问题，可以从不同角度继续提问
- 结合实际项目经验，询问具体的使用场景和遇到的问题
- 网络编程方面可以从性能优化、错误处理、安全性等角度深入
- 并发编程可以结合网络编程场景，考察线程池、异步I/O等综合应用
- 关注候选人的学习方法和技术成长路径
- 可以询问对开源网络库（如muduo、libevent、boost.asio）的了解和使用经验
